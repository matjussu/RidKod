# üß™ Comment Fonctionne le Syst√®me de Tests

## üéØ Pourquoi des Tests Unitaires ?

Les tests unitaires vous permettent de :

1. **D√©tecter les bugs rapidement** : Les tests v√©rifient automatiquement que votre code fonctionne comme pr√©vu
2. **√âviter les r√©gressions** : Quand vous modifiez du code, les tests s'assurent que rien n'est cass√©
3. **Documenter le code** : Les tests montrent comment utiliser vos composants/fonctions
4. **Gagner du temps** : Plus besoin de tester manuellement dans le navigateur √† chaque modification
5. **D√©ployer en confiance** : Vous savez que tout fonctionne avant la mise en production

---

## üöÄ Utilisation Rapide

### Lancer les tests
```bash
npm test
```

Les tests se lancent en **mode watch** : ils se relancent automatiquement quand vous modifiez un fichier. Parfait pour le d√©veloppement !

### Lancer les tests une fois (pour CI/CD)
```bash
npm run test:run
```

### Interface graphique interactive
```bash
npm run test:ui
```

Ouvre une interface web pour voir vos tests, filtrer, debug, etc.

### G√©n√©rer un rapport de couverture
```bash
npm run test:coverage
```

Montre quel % de votre code est test√©.

---

## üìÇ Structure des Tests

Tous les tests sont dans `src/tests/` :

```
src/tests/
‚îú‚îÄ‚îÄ setup.js                          # Configuration globale
‚îú‚îÄ‚îÄ __mocks__/
‚îÇ   ‚îî‚îÄ‚îÄ firebase.js                   # Mocks Firebase
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ progressService.test.js       # Tests logique XP/niveaux
‚îú‚îÄ‚îÄ context/
‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.test.jsx          # Tests authentification
‚îî‚îÄ‚îÄ components/
    ‚îú‚îÄ‚îÄ OptionButton.test.jsx         # Tests boutons r√©ponse
    ‚îî‚îÄ‚îÄ ActionButton.test.jsx         # Tests bouton Valider/Continuer
```

Chaque test est √† c√¥t√© du fichier qu'il teste, mais dans le dossier `tests/`.

---

## üß† Comment √áa Marche ?

### 1. Framework : Vitest

**Vitest** est comme Jest mais **ultra-rapide** et optimis√© pour Vite. Il fournit :
- `describe()` : Grouper des tests
- `it()` ou `test()` : D√©finir un test
- `expect()` : Faire des assertions

```javascript
describe('OptionButton', () => {
  it('devrait afficher la valeur', () => {
    // Test ici
  });
});
```

### 2. Testing Library : Tester comme un utilisateur

**React Testing Library** permet de tester vos composants comme un utilisateur r√©el :

```javascript
// Rendre le composant
render(<OptionButton value="Option A" />);

// Trouver un √©l√©ment comme le ferait l'utilisateur
const button = screen.getByRole('button');

// V√©rifier qu'il contient le bon texte
expect(button).toHaveTextContent('Option A');

// Simuler un clic
fireEvent.click(button);
```

**Principe :** On ne teste PAS l'impl√©mentation interne, on teste le comportement visible.

### 3. Mocks : Simuler Firebase

Les tests ne font **jamais d'appels r√©seau r√©els**. On simule Firebase :

```javascript
// Mock de signInWithEmailAndPassword
vi.mock('firebase/auth', () => ({
  signInWithEmailAndPassword: vi.fn()
}));

// Dans le test, on simule une r√©ponse
signInWithEmailAndPassword.mockResolvedValue({
  user: { email: 'test@example.com' }
});
```

---

## üìù Anatomie d'un Test

Voici un test complet annot√© :

```javascript
// 1. Imports
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import OptionButton from '../../components/exercise/OptionButton';

// 2. Groupe de tests
describe('OptionButton', () => {

  // 3. Test individuel
  it('devrait afficher la valeur', () => {

    // 4. ARRANGE : Pr√©parer le test
    const value = 'Option A';
    const handleClick = vi.fn(); // Mock de fonction

    // 5. ACT : Ex√©cuter l'action
    render(
      <OptionButton
        value={value}
        isSelected={false}
        isCorrect={false}
        isSubmitted={false}
        onClick={handleClick}
      />
    );

    // 6. ASSERT : V√©rifier le r√©sultat
    const button = screen.getByRole('button');
    expect(button).toHaveTextContent('Option A');

    // 7. Test d'interaction
    fireEvent.click(button);
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

**Pattern AAA : Arrange, Act, Assert**

---

## üéØ Matchers Communs

Les matchers sont les fonctions apr√®s `expect()` :

### Pr√©sence dans le DOM
```javascript
expect(element).toBeInTheDocument();
expect(element).not.toBeInTheDocument();
```

### Texte
```javascript
expect(element).toHaveTextContent('Hello');
expect(element).toContainText('World');
```

### Classes CSS
```javascript
expect(element).toHaveClass('active');
expect(element).not.toHaveClass('disabled');
```

### √âtat disabled/enabled
```javascript
expect(button).toBeDisabled();
expect(button).not.toBeDisabled();
```

### Valeur d'input
```javascript
expect(input).toHaveValue('test@example.com');
```

### Appels de fonction
```javascript
expect(mockFunction).toHaveBeenCalled();
expect(mockFunction).toHaveBeenCalledTimes(3);
expect(mockFunction).toHaveBeenCalledWith('arg1', 'arg2');
expect(mockFunction).not.toHaveBeenCalled();
```

### √âgalit√©
```javascript
expect(value).toBe(42);
expect(object).toEqual({ name: 'John' });
expect(array).toContain('item');
```

---

## üîç Queries Testing Library

### Par r√¥le (RECOMMAND√â)
```javascript
screen.getByRole('button');
screen.getByRole('textbox');
screen.getByRole('heading', { level: 1 });
```

### Par texte
```javascript
screen.getByText('Submit');
screen.getByText(/submit/i); // Insensible √† la casse
```

### Par label (formulaires)
```javascript
screen.getByLabelText('Email');
```

### Par test ID (dernier recours)
```javascript
screen.getByTestId('submit-button');
```

### Variantes
- `getBy` : Trouve UN √©l√©ment (erreur si 0 ou 2+)
- `queryBy` : Trouve UN √©l√©ment (null si 0)
- `findBy` : Trouve UN √©l√©ment (async, attend qu'il apparaisse)
- `getAllBy` : Trouve PLUSIEURS √©l√©ments

---

## üß™ Exemples Concrets

### Tester un composant simple
```javascript
it('devrait afficher le nom', () => {
  render(<UserCard name="Alice" />);
  expect(screen.getByText('Alice')).toBeInTheDocument();
});
```

### Tester un clic
```javascript
it('devrait appeler onClick', () => {
  const handleClick = vi.fn();
  render(<Button onClick={handleClick}>Click me</Button>);

  fireEvent.click(screen.getByRole('button'));
  expect(handleClick).toHaveBeenCalledTimes(1);
});
```

### Tester un formulaire
```javascript
it('devrait soumettre le formulaire', () => {
  const handleSubmit = vi.fn();
  render(<LoginForm onSubmit={handleSubmit} />);

  // Remplir les champs
  const emailInput = screen.getByLabelText('Email');
  fireEvent.change(emailInput, { target: { value: 'test@example.com' } });

  const passwordInput = screen.getByLabelText('Password');
  fireEvent.change(passwordInput, { target: { value: 'password123' } });

  // Soumettre
  fireEvent.click(screen.getByRole('button', { name: /submit/i }));

  // V√©rifier
  expect(handleSubmit).toHaveBeenCalledWith({
    email: 'test@example.com',
    password: 'password123'
  });
});
```

### Tester un √©tat async
```javascript
it('devrait charger les donn√©es', async () => {
  render(<DataList />);

  // V√©rifier le loading
  expect(screen.getByText('Loading...')).toBeInTheDocument();

  // Attendre que les donn√©es apparaissent
  const items = await screen.findByRole('list');
  expect(items).toBeInTheDocument();

  // V√©rifier les donn√©es
  expect(screen.getByText('Item 1')).toBeInTheDocument();
});
```

### Tester avec Context
```javascript
it('devrait utiliser le contexte', () => {
  render(
    <AuthProvider>
      <ProtectedComponent />
    </AuthProvider>
  );

  expect(screen.getByText('Welcome, user!')).toBeInTheDocument();
});
```

---

## üêõ Debugging Tests

### Afficher le DOM
```javascript
const { debug } = render(<MyComponent />);
debug(); // Affiche tout le DOM
debug(screen.getByRole('button')); // Affiche un √©l√©ment sp√©cifique
```

### Lancer un seul test
```bash
npm test -- OptionButton.test.jsx
```

### Lancer un seul describe/it
```javascript
describe.only('Mon groupe', () => { ... });
it.only('Mon test', () => { ... });
```

### Ignorer un test
```javascript
it.skip('Ce test ne marche pas encore', () => { ... });
```

### Mode verbose
```bash
npm test -- --reporter=verbose
```

---

## ‚úÖ Bonnes Pratiques

### √Ä FAIRE ‚úÖ
1. **Tester le comportement, pas l'impl√©mentation**
   ```javascript
   // ‚úÖ BON
   expect(button).toHaveTextContent('Valider');

   // ‚ùå MAUVAIS
   expect(component.state.isSubmitted).toBe(false);
   ```

2. **Utiliser les queries accessibles**
   ```javascript
   // ‚úÖ BON
   screen.getByRole('button', { name: 'Submit' })

   // ‚ùå MAUVAIS
   document.querySelector('.submit-button')
   ```

3. **Un test = une responsabilit√©**
   ```javascript
   // ‚úÖ BON : Tests s√©par√©s
   it('devrait afficher le texte', () => { ... });
   it('devrait √™tre cliquable', () => { ... });

   // ‚ùå MAUVAIS : Test qui fait tout
   it('devrait faire plein de trucs', () => {
     // 50 lignes de code...
   });
   ```

4. **Tester les edge cases**
   - Valeurs null/undefined
   - Tableaux vides
   - Cha√Ænes tr√®s longues
   - Valeurs n√©gatives

### √Ä √âVITER ‚ùå
1. **Tester des d√©tails d'impl√©mentation**
2. **Tests flaky (qui √©chouent al√©atoirement)**
3. **Tests trop longs (>50 lignes par test)**
4. **D√©pendances entre tests**
5. **Mocks trop complexes**

---

## üìä Couverture de Code

### Qu'est-ce que c'est ?

La **couverture** mesure quel % de votre code est ex√©cut√© par les tests.

### G√©n√©rer le rapport
```bash
npm run test:coverage
```

### Lire le rapport
```
File                | % Stmts | % Branch | % Funcs | % Lines
--------------------|---------|----------|---------|--------
progressService.js  |   100   |   100    |   100   |   100
AuthContext.jsx     |    90   |    85    |    95   |    90
OptionButton.jsx    |    85   |    80    |    90   |    85
```

- **% Stmts** : % de lignes ex√©cut√©es
- **% Branch** : % de conditions (if/else) test√©es
- **% Funcs** : % de fonctions appel√©es
- **% Lines** : % de lignes de code ex√©cut√©es

### Objectif

Visez **80%+ de couverture** pour les parties critiques :
- Services (logique m√©tier)
- Contexts (state management)
- Composants UI principaux

Pas besoin de 100% partout, mais les parties importantes doivent √™tre bien test√©es.

---

## üî• Astuces Avanc√©es

### Tester les erreurs
```javascript
it('devrait g√©rer les erreurs', async () => {
  const mockFetch = vi.fn().mockRejectedValue(new Error('Network error'));

  render(<DataFetcher fetchFn={mockFetch} />);

  await waitFor(() => {
    expect(screen.getByText(/error/i)).toBeInTheDocument();
  });
});
```

### Tester les timers
```javascript
it('devrait afficher apr√®s 1 seconde', () => {
  vi.useFakeTimers();

  render(<DelayedMessage />);
  expect(screen.queryByText('Hello')).not.toBeInTheDocument();

  vi.advanceTimersByTime(1000);
  expect(screen.getByText('Hello')).toBeInTheDocument();

  vi.useRealTimers();
});
```

### Tester le localStorage
```javascript
beforeEach(() => {
  localStorage.clear();
});

it('devrait sauvegarder dans localStorage', () => {
  render(<SaveButton />);
  fireEvent.click(screen.getByRole('button'));

  expect(localStorage.getItem('saved')).toBe('true');
});
```

---

## üìö Ressources

### Documentation officielle
- **Vitest** : https://vitest.dev
- **Testing Library** : https://testing-library.com/react

### Guides
- **Common mistakes** : https://kentcdodds.com/blog/common-mistakes-with-react-testing-library
- **Testing principles** : https://testing-library.com/docs/guiding-principles

### Dans ce projet
- **[TESTING.md](TESTING.md)** - Guide complet des tests ReadCod
- **[TEST_RESULTS.md](TEST_RESULTS.md)** - R√©sultats des tests actuels

---

## üéâ Conclusion

Les tests unitaires vous font gagner du temps et vous donnent confiance dans votre code. Avec Vitest + Testing Library :

1. ‚úÖ Tests **ultra-rapides** (2-3 secondes)
2. ‚úÖ Tests **faciles √† √©crire** (comme un utilisateur)
3. ‚úÖ Tests **fiables** (pas de faux positifs)
4. ‚úÖ Feedback **imm√©diat** (mode watch)

**Commencez petit** : testez d'abord les composants/fonctions critiques, puis √©tendez progressivement.

**Happy Testing !** üß™‚ú®

---

**Derni√®re mise √† jour :** 25 octobre 2025
**Version :** 1.0

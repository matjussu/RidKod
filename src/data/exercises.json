[
  {
    "id": "py_easy_001",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "shopping_cart = ['pain', 'lait', 'œufs']\nshopping_cart.append('fromage')\ntotal_items = len(shopping_cart)\nprint(total_items)",
    "options": ["3", "4", "5", "Error"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : On crée une liste shopping_cart avec 3 items initiaux\n\nLigne 2 : append('fromage') ajoute un nouvel élément → maintenant 4 items au total\n\nLigne 3 : len(shopping_cart) compte tous les éléments → retourne 4\n\nLigne 4 : print() affiche le résultat : 4",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["lists", "methods", "len"]
  },
  {
    "id": "py_easy_002",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "user_score = 0\nfor level in range(3):\n    user_score += 10\nprint(user_score)",
    "options": ["10", "30", "3", "0"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : user_score démarre à 0\n\nLigne 2 : range(3) génère [0, 1, 2] → la boucle s'exécute 3 fois\n\nLigne 3 : À chaque itération, on ajoute 10 au score\n• 1ère fois : 0 + 10 = 10\n• 2ème fois : 10 + 10 = 20\n• 3ème fois : 20 + 10 = 30\n\nLigne 4 : print() affiche le score final : 30",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["loops", "range", "arithmetic"]
  },
  {
    "id": "py_easy_003",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "employee_name = 'Alice'\nwelcome_message = 'Bonjour ' + employee_name\nprint(len(welcome_message))",
    "options": ["5", "8", "13", "14"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : employee_name stocke 'Alice' (5 caractères)\n\nLigne 2 : Concaténation de chaînes\n• 'Bonjour ' = 8 caractères (avec l'espace)\n• + 'Alice' = 5 caractères\n• Résultat : 'Bonjour Alice' = 13 caractères total\n\nLigne 3 : len() compte tous les caractères → retourne 13",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["strings", "concatenation", "len"]
  },
  {
    "id": "py_easy_004",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "temperature = 15\nif temperature > 20:\n    comfort_level = 'chaud'\nelse:\n    comfort_level = 'froid'\nprint(comfort_level)",
    "options": ["chaud", "froid", "15", "Error"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : temperature vaut 15\n\nLigne 2 : Condition if temperature > 20\n• 15 > 20 est False\n• Donc on saute le bloc if (ligne 3)\n\nLigne 4-5 : On exécute le bloc else\n• comfort_level = 'froid'\n\nLigne 6 : print() affiche 'froid'",
    "highlightedLines": [2, 5],
    "xpGain": 10,
    "tags": ["conditions", "if-else", "comparison"]
  },
  {
    "id": "py_easy_005",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "inventory = [10, 5, 8]\nfirst_item = inventory[0]\nlast_item = inventory[-1]\nresult = first_item + last_item\nprint(result)",
    "options": ["13", "18", "15", "23"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : inventory contient [10, 5, 8]\n\nLigne 2 : inventory[0] récupère le premier élément → 10\n\nLigne 3 : inventory[-1] récupère le dernier élément → 8\n\nLigne 4 : Addition 10 + 8 = 18\n\nLigne 5 : print() affiche 18",
    "highlightedLines": [2, 3, 4],
    "xpGain": 10,
    "tags": ["lists", "indexing", "arithmetic"]
  },
  {
    "id": "py_easy_006",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "price = 50\ndiscount = 10\nfinal_price = price - discount\nprint(final_price)",
    "acceptedAnswers": ["40", "40.0"],
    "explanation": "Ligne 1 : price vaut 50\n\nLigne 2 : discount vaut 10\n\nLigne 3 : Soustraction 50 - 10 = 40\n\nLigne 4 : print() affiche 40",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "subtraction"]
  },
  {
    "id": "py_easy_007",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [2, 4, 6, 8]\ntotal = 0\nfor num in numbers:\n    total += num\nprint(total)",
    "acceptedAnswers": ["20", "20.0"],
    "explanation": "Ligne 2 : total démarre à 0\n\nLigne 3-4 : Boucle qui additionne tous les nombres\n• 0 + 2 = 2\n• 2 + 4 = 6\n• 6 + 6 = 12\n• 12 + 8 = 20\n\nLigne 5 : print() affiche 20",
    "highlightedLines": [3, 4],
    "xpGain": 10,
    "tags": ["loops", "arithmetic", "sum"]
  },
  {
    "id": "py_easy_008",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nsubstring = text[0:3]\nprint(substring)",
    "options": ["Pyt", "Pyth", "Python", "hon"],
    "correctAnswer": 0,
    "explanation": "Ligne 1 : text contient 'Python'\n\nLigne 2 : Slicing text[0:3]\n• Commence à l'index 0 (inclus) : 'P'\n• S'arrête à l'index 3 (exclus) : jusqu'à 't'\n• Résultat : 'Pyt'\n\nLigne 3 : print() affiche 'Pyt'",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["strings", "slicing", "indexing"]
  },
  {
    "id": "py_easy_009",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "counter = 5\nwhile counter > 0:\n    counter -= 2\nprint(counter)",
    "acceptedAnswers": ["-1", "-1.0"],
    "explanation": "Ligne 1 : counter démarre à 5\n\nLigne 2-3 : Boucle while tant que counter > 0\n• Itération 1 : counter = 5 - 2 = 3 (encore > 0)\n• Itération 2 : counter = 3 - 2 = 1 (encore > 0)\n• Itération 3 : counter = 1 - 2 = -1 (plus > 0, on sort)\n\nLigne 4 : print() affiche -1",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["while", "loops", "counter"]
  },
  {
    "id": "py_easy_010",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [1, 2, 3, 4, 5]\nresult = numbers[2] * 2\nprint(result)",
    "options": ["4", "6", "8", "10"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : numbers contient [1, 2, 3, 4, 5]\n\nLigne 2 : numbers[2] accède au 3ème élément (index 2) → 3\n• Puis multiplication par 2 : 3 * 2 = 6\n\nLigne 3 : print() affiche 6",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "indexing", "arithmetic"]
  },
  {
    "id": "py_easy_011",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "age = 25\nname = 'Marc'\nprint('Tu as', age, 'ans)\nprint('Bonjour', name)",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 3,
    "explanation": "Ligne 3 : Erreur de syntaxe - guillemet fermant manquant\n\nLa chaîne commence par un guillemet simple ' mais ne se termine pas avant la parenthèse.\n\nCorrection : print('Tu as', age, 'ans')",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["syntax", "strings", "quotes"]
  },
  {
    "id": "py_easy_012",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de x ?",
    "code": "x = 10\nx = x + 5\nx = x * 2\nprint(x)",
    "acceptedAnswers": ["30", "30.0"],
    "explanation": "Ligne 1 : x = 10\n\nLigne 2 : x = 10 + 5 = 15\n\nLigne 3 : x = 15 * 2 = 30\n\nLigne 4 : print() affiche 30",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "assignment"]
  },
  {
    "id": "py_easy_013",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "fruits = ['pomme', 'banane', 'orange']\nfor fruit in fruits:\n    print(fruit.upper())",
    "options": [
      "Affiche chaque fruit en minuscules",
      "Affiche chaque fruit en majuscules",
      "Compte le nombre de fruits",
      "Trie les fruits par ordre alphabétique"
    ],
    "correctAnswer": 1,
    "explanation": "La méthode .upper() convertit une chaîne en MAJUSCULES.\n\nLa boucle for parcourt chaque élément de la liste fruits et affiche sa version en majuscules :\n• POMME\n• BANANE\n• ORANGE",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["strings", "methods", "loops"]
  },
  {
    "id": "py_easy_014",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "numbers = [1, 2, 3]\nfor i in range(3):\n  result = numbers[i] * 2\n    print(result)",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 4,
    "explanation": "Ligne 4 : Erreur d'indentation\n\nLe print() a une indentation incorrecte (4 espaces au lieu de 2). En Python, tous les statements dans un même bloc doivent avoir la même indentation.\n\nCorrection : aligner print(result) avec result = ...",
    "highlightedLines": [4],
    "xpGain": 10,
    "tags": ["syntax", "indentation", "loops"]
  },
  {
    "id": "py_easy_015",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "a = 7\nb = 3\nresult = a // b\nprint(result)",
    "acceptedAnswers": ["2", "2.0"],
    "explanation": "Ligne 3 : L'opérateur // est la division entière (floor division)\n\n7 // 3 donne le quotient entier sans la partie décimale :\n• 7 / 3 = 2.333...\n• 7 // 3 = 2 (partie entière seulement)\n\nLigne 4 : print() affiche 2",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["arithmetic", "operators", "division"]
  },
  {
    "id": "py_easy_016",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "message = 'Bonjour'\nif len(message) > 5:\n    print('Message long')\nelse:\n    print('Message court')",
    "options": [
      "Affiche 'Message long'",
      "Affiche 'Message court'",
      "Compte les lettres",
      "Affiche le message"
    ],
    "correctAnswer": 0,
    "explanation": "Ligne 1 : message = 'Bonjour' (7 caractères)\n\nLigne 2 : len(message) retourne 7, et 7 > 5 est True\n\nDonc le programme exécute le bloc if et affiche 'Message long'",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["strings", "len", "conditions"]
  },
  {
    "id": "py_easy_017",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de count ?",
    "code": "count = 0\nfor i in range(5):\n    count += 1\nprint(count)",
    "acceptedAnswers": ["5", "5.0"],
    "explanation": "Ligne 1 : count démarre à 0\n\nLigne 2 : range(5) génère [0, 1, 2, 3, 4] → 5 itérations\n\nLigne 3 : À chaque itération, count augmente de 1\n• count = 1, 2, 3, 4, 5\n\nLigne 4 : print() affiche 5",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["loops", "counter", "range"]
  },
  {
    "id": "py_easy_018",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "name = 'Alice'\nage = 30\nresultat = name + age\nprint(resultat)",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 3,
    "explanation": "Ligne 3 : TypeError - Impossible de concaténer str + int\n\nPython ne peut pas additionner directement une chaîne ('Alice') avec un nombre (30).\n\nCorrection : resultat = name + str(age) ou utiliser f-string",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["types", "strings", "concatenation", "errors"]
  },
  {
    "id": "py_easy_019",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [10, 20, 30]\nnumbers.pop()\nprint(len(numbers))",
    "options": ["0", "1", "2", "3"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : numbers contient 3 éléments [10, 20, 30]\n\nLigne 2 : pop() supprime et retourne le dernier élément (30)\n• numbers devient [10, 20] → 2 éléments\n\nLigne 3 : len(numbers) retourne 2",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "methods", "pop", "len"]
  },
  {
    "id": "py_easy_020",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de total ?",
    "code": "total = 100\ntotal -= 20\ntotal *= 2\nprint(total)",
    "acceptedAnswers": ["160", "160.0"],
    "explanation": "Ligne 1 : total = 100\n\nLigne 2 : total -= 20 → total = 100 - 20 = 80\n\nLigne 3 : total *= 2 → total = 80 * 2 = 160\n\nLigne 4 : print() affiche 160",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "operators"]
  },
  {
    "id": "py_easy_021",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait cette fonction ?",
    "code": "def double(x):\n    return x * 2\n\nresult = double(5)\nprint(result)",
    "options": [
      "Affiche 5",
      "Affiche 10",
      "Affiche 25",
      "Provoque une erreur"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1-2 : La fonction double() prend un paramètre x et retourne x * 2\n\nLigne 4 : double(5) appelle la fonction avec x = 5\n• Retourne 5 * 2 = 10\n\nLigne 5 : print() affiche 10",
    "highlightedLines": [2, 4],
    "xpGain": 10,
    "tags": ["functions", "parameters", "return"]
  },
  {
    "id": "py_easy_022",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "colors = ['rouge', 'vert', 'bleu']\nprint(colors[3])\nprint('Couleur trouvée')",
    "clickableLines": [1, 2, 3],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : IndexError - list index out of range\n\nLa liste colors a 3 éléments aux index 0, 1, 2.\nL'index 3 n'existe pas !\n\nCorrection : utiliser colors[0], colors[1] ou colors[2]",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "indexing", "errors", "range"]
  },
  {
    "id": "py_easy_023",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "x = 12\ny = 5\nresult = x % y\nprint(result)",
    "acceptedAnswers": ["2", "2.0"],
    "explanation": "Ligne 3 : L'opérateur % calcule le reste de la division (modulo)\n\n12 % 5 :\n• 12 / 5 = 2 avec un reste de 2\n• 5 * 2 = 10, il reste 12 - 10 = 2\n\nLigne 4 : print() affiche 2",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["arithmetic", "operators", "modulo"]
  },
  {
    "id": "py_easy_024",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "numbers = [5, 2, 8, 1, 9]\nnumbers.sort()\nprint(numbers[0])",
    "options": [
      "Affiche le plus grand nombre",
      "Affiche le plus petit nombre",
      "Affiche le premier nombre",
      "Affiche la longueur de la liste"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 2 : sort() trie la liste par ordre croissant\n• numbers devient [1, 2, 5, 8, 9]\n\nLigne 3 : numbers[0] accède au premier élément après le tri\n• Premier élément = plus petit nombre = 1",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["lists", "methods", "sort", "indexing"]
  },
  {
    "id": "py_easy_025",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "def greet(name):\n    print('Bonjour', nom)\n\ngreet('Alice')",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : NameError - variable 'nom' non définie\n\nLe paramètre de la fonction s'appelle 'name', pas 'nom'.\n\nCorrection : print('Bonjour', name)",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["functions", "variables", "errors", "scope"]
  },
  {
    "id": "py_easy_026",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de n ?",
    "code": "n = 3\nn = n ** 2\nn = n + 1\nprint(n)",
    "acceptedAnswers": ["10", "10.0"],
    "explanation": "Ligne 1 : n = 3\n\nLigne 2 : n = 3 ** 2 (3 puissance 2) = 9\n\nLigne 3 : n = 9 + 1 = 10\n\nLigne 4 : print() affiche 10",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "power"]
  },
  {
    "id": "py_easy_027",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nprint(text[-1])",
    "options": ["P", "y", "n", "h"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : text = 'Python'\n\nLigne 2 : text[-1] accède au dernier caractère avec un index négatif\n• Index -1 = dernier élément = 'n'\n\nprint() affiche 'n'",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["strings", "indexing", "negative_index"]
  },
  {
    "id": "py_easy_028",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "score = 85\nif score >= 50\n    print('Réussi')\nelse:\n    print('Échoué')",
    "clickableLines": [1, 2, 3, 4, 5],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : Erreur de syntaxe - deux-points manquants\n\nEn Python, toute instruction if doit se terminer par :\n\nCorrection : if score >= 50:",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["syntax", "conditions", "if"]
  },
  {
    "id": "py_easy_029",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [2, 4, 6]\nresult = sum(numbers)\nprint(result)",
    "acceptedAnswers": ["12", "12.0"],
    "explanation": "Ligne 1 : numbers = [2, 4, 6]\n\nLigne 2 : sum() additionne tous les éléments de la liste\n• 2 + 4 + 6 = 12\n\nLigne 3 : print() affiche 12",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "sum", "functions"]
  },
  {
    "id": "py_easy_030",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "numbers = [1, 2, 3]\ntotal = 0\nfor num in numbers\n    total += num\nprint(total)",
    "clickableLines": [1, 2, 3, 4, 5],
    "correctAnswer": 3,
    "explanation": "Ligne 3 : Erreur de syntaxe - deux-points manquants\n\nToute boucle for doit se terminer par :\n\nCorrection : for num in numbers:",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["syntax", "loops", "for"]
  },
  {
    "id": "py_medium_001",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def multiplier(x):\n    return lambda y: x * y\n\ndouble = multiplier(2)\nresult = double(5)\nprint(result)",
    "options": ["2", "5", "10", "Error"],
    "correctAnswer": 2,
    "explanation": "⚠️ PIÈGE : Ce code utilise une closure (lambda qui capture x)\n\nLigne 1-2 : multiplier(x) retourne une fonction lambda qui multiplie par x\n\nLigne 4 : double = multiplier(2) crée une fonction qui multiplie par 2\n\nLigne 5 : double(5) exécute la lambda avec y=5\n• La lambda retourne x * y = 2 * 5 = 10\n\nLigne 6 : print() affiche 10\n\n💡 Solution piégeuse : On pourrait penser que c'est 2 (valeur de x) ou 5 (valeur de y), mais c'est bien leur multiplication.",
    "highlightedLines": [2, 4, 5],
    "xpGain": 20,
    "tags": ["functions", "lambda", "closures"]
  },
  {
    "id": "py_medium_002",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [1, 2, 3, 4, 5]\nresult = [x * 2 for x in numbers if x % 2 == 0]\nprint(len(result))",
    "options": ["2", "5", "10", "4"],
    "correctAnswer": 0,
    "explanation": "⚠️ PIÈGE : La list comprehension filtre ET transforme les éléments\n\nLigne 1 : numbers = [1, 2, 3, 4, 5]\n\nLigne 2 : List comprehension avec condition\n• if x % 2 == 0 : garde seulement les pairs (2, 4)\n• x * 2 : multiplie par 2\n• result = [2*2, 4*2] = [4, 8]\n\nLigne 3 : len([4, 8]) = 2\n\n💡 Solution piégeuse : On pourrait compter tous les éléments (5) ou penser au résultat doublé (10), mais on ne garde que les pairs avant de doubler.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["list-comprehension", "filter", "modulo"]
  },
  {
    "id": "py_medium_003",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de x ?",
    "code": "x = 5\ndef modifier():\n    x = 10\n    return x\n\nmodifier()\nprint(x)",
    "acceptedAnswers": ["5", "5.0"],
    "explanation": "⚠️ PIÈGE : Scope des variables (local vs global)\n\nLigne 1 : x = 5 (variable GLOBALE)\n\nLigne 2-4 : Fonction modifier() qui crée une variable x LOCALE = 10\n• Cette variable locale x n'affecte PAS la variable globale x\n• Elle existe seulement dans la fonction\n\nLigne 6 : modifier() s'exécute mais ne modifie pas x global\n\nLigne 7 : print(x) affiche la variable GLOBALE x = 5\n\n💡 Solution piégeuse : On pourrait penser que x devient 10, mais sans le mot-clé 'global', la fonction crée une nouvelle variable locale qui n'affecte pas x global.",
    "highlightedLines": [2, 3],
    "xpGain": 20,
    "tags": ["scope", "functions", "variables"]
  },
  {
    "id": "py_medium_004",
    "language": "python",
    "difficulty": 2,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur logique ?",
    "code": "def calculer_moyenne(notes):\n    total = sum(notes)\n    moyenne = total / len(notes)\n    return round(moyenne)\n\nresultat = calculer_moyenne([])\nprint(resultat)",
    "clickableLines": [1, 2, 3, 4, 5, 6, 7],
    "correctAnswer": 6,
    "explanation": "⚠️ PIÈGE : Division par zéro avec liste vide\n\nLigne 6 : calculer_moyenne([]) appelle la fonction avec une liste vide\n\nDans la fonction :\n• total = sum([]) = 0\n• moyenne = 0 / len([]) = 0 / 0 → ZeroDivisionError\n\nErreur : On ne vérifie pas si la liste est vide avant de diviser\n\n💡 Correction :\ndef calculer_moyenne(notes):\n    if len(notes) == 0:\n        return 0\n    total = sum(notes)\n    moyenne = total / len(notes)\n    return round(moyenne)",
    "highlightedLines": [6],
    "xpGain": 20,
    "tags": ["functions", "errors", "edge-cases"]
  },
  {
    "id": "py_medium_005",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nresult = text[1:4]\nprint(result)",
    "options": ["Pyt", "yth", "ytho", "tho"],
    "correctAnswer": 1,
    "explanation": "⚠️ PIÈGE : Le slicing exclut l'index de fin\n\nLigne 1 : text = 'Python'\n• Indices : P=0, y=1, t=2, h=3, o=4, n=5\n\nLigne 2 : text[1:4] extrait depuis l'index 1 INCLUS jusqu'à 4 EXCLU\n• Index 1 : 'y'\n• Index 2 : 't'\n• Index 3 : 'h'\n• Index 4 : EXCLU\n• result = 'yth'\n\nLigne 3 : print() affiche 'yth'\n\n💡 Solution piégeuse : On pourrait penser que [1:4] inclut l'index 4, mais Python exclut toujours la borne supérieure dans le slicing.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["strings", "slicing", "indexing"]
  },
  {
    "id": "py_medium_006",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "data = {'a': 1, 'b': 2}\ndata['c'] = data.get('a', 0) + data.get('d', 0)\nprint(data['c'])",
    "options": ["0", "1", "2", "3"],
    "correctAnswer": 1,
    "explanation": "⚠️ PIÈGE : La méthode .get() avec valeur par défaut\n\nLigne 1 : data = {'a': 1, 'b': 2}\n\nLigne 2 : Calcul de data['c']\n• data.get('a', 0) : clé 'a' existe → retourne 1\n• data.get('d', 0) : clé 'd' n'existe PAS → retourne la valeur par défaut 0\n• data['c'] = 1 + 0 = 1\n\nLigne 3 : print(data['c']) affiche 1\n\n💡 Solution piégeuse : On pourrait penser que .get('d', 0) génère une erreur, mais c'est justement l'intérêt de .get() : retourner une valeur par défaut si la clé n'existe pas.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["dictionaries", "get", "methods"]
  },
  {
    "id": "py_medium_007",
    "language": "python",
    "difficulty": 2,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "def factorielle(n):\n    if n <= 1:\n        return 1\n    return n * factorielle(n - 1)\n\nresult = factorielle(5)",
    "options": [
      "Calcule 5 + 4 + 3 + 2 + 1",
      "Calcule 5 * 4 * 3 * 2 * 1",
      "Calcule 5^4",
      "Génère une erreur (récursion infinie)"
    ],
    "correctAnswer": 1,
    "explanation": "⚠️ PIÈGE : Reconnaître une fonction récursive\n\nCe code calcule la factorielle de n de manière récursive\n\nExécution pour factorielle(5) :\n• factorielle(5) = 5 * factorielle(4)\n• factorielle(4) = 4 * factorielle(3)\n• factorielle(3) = 3 * factorielle(2)\n• factorielle(2) = 2 * factorielle(1)\n• factorielle(1) = 1 (cas de base)\n\nRésultat : 5 * 4 * 3 * 2 * 1 = 120\n\n💡 Solution piégeuse : La récursion peut sembler générer une erreur, mais le cas de base (n <= 1) arrête bien la récursion.",
    "highlightedLines": [2, 3, 4],
    "xpGain": 20,
    "tags": ["recursion", "functions", "factorielle"]
  },
  {
    "id": "py_medium_008",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Combien d'itérations la boucle effectue-t-elle ?",
    "code": "count = 0\nfor i in range(2, 10, 3):\n    count += 1\nprint(count)",
    "acceptedAnswers": ["3", "3.0"],
    "explanation": "⚠️ PIÈGE : range(start, stop, step) avec pas personnalisé\n\nLigne 2 : range(2, 10, 3) génère une séquence avec :\n• Départ : 2\n• Fin : 10 (EXCLU)\n• Pas : 3\n\nValeurs générées :\n• i = 2 (2 < 10) → count = 1\n• i = 5 (2+3, 5 < 10) → count = 2\n• i = 8 (5+3, 8 < 10) → count = 3\n• i = 11 (8+3, 11 >= 10) → STOP\n\nLa boucle s'exécute 3 fois\n\n💡 Solution piégeuse : On pourrait calculer (10-2)/3 = 2.67 et arrondir à 2, mais il faut compter précisément les valeurs < 10.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["range", "loops", "step"]
  },
  {
    "id": "py_medium_009",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def modifier_liste(lst):\n    lst.append(4)\n    return lst\n\noriginal = [1, 2, 3]\nnouvelle = modifier_liste(original)\nprint(len(original))",
    "options": ["3", "4", "7", "Error"],
    "correctAnswer": 1,
    "explanation": "⚠️ PIÈGE : Les listes sont mutables et passées par référence\n\nLigne 4 : original = [1, 2, 3]\n\nLigne 5 : modifier_liste(original) reçoit une RÉFÉRENCE à original\n• lst pointe vers la MÊME liste que original\n• lst.append(4) modifie directement original\n• original devient [1, 2, 3, 4]\n\nLigne 6 : print(len(original)) affiche 4\n\n💡 Solution piégeuse : On pourrait penser que original reste [1, 2, 3] car on crée 'nouvelle', mais en Python les listes sont mutables et passées par référence. Pour éviter cela, il faudrait utiliser lst = lst.copy() ou lst = lst[:].",
    "highlightedLines": [2, 5],
    "xpGain": 20,
    "tags": ["lists", "mutability", "references"]
  },
  {
    "id": "py_medium_010",
    "language": "python",
    "difficulty": 2,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "predefined",
    "question": "Quel est le type de 'result' ?",
    "code": "values = [1, 2, 3]\nresult = map(lambda x: x ** 2, values)\nprint(type(result).__name__)",
    "acceptedAnswers": ["map"],
    "explanation": "⚠️ PIÈGE : map() retourne un objet map, pas une liste\n\nLigne 1 : values = [1, 2, 3]\n\nLigne 2 : map(lambda x: x ** 2, values)\n• map() applique la fonction lambda à chaque élément\n• MAIS map() retourne un OBJET MAP (itérateur), pas une liste\n• Pour obtenir une liste, il faudrait : list(map(...))\n\nLigne 3 : type(result).__name__ retourne 'map'\n\n💡 Solution piégeuse : On pourrait penser que result est une liste [1, 4, 9], mais map() retourne un itérateur pour optimiser la mémoire. Il faut explicitement convertir en list() pour obtenir les valeurs.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["map", "lambda", "types", "iterators"]
  },
  {
    "id": "py_hard_001",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "class Compteur:\n    count = 0\n    def __init__(self):\n        Compteur.count += 1\n\na = Compteur()\nb = Compteur()\nc = Compteur()\nprint(Compteur.count)",
    "options": ["0", "1", "3", "Error"],
    "correctAnswer": 2,
    "explanation": "⚠️ PIÈGE : Variable de classe vs variable d'instance\n\nLigne 2 : count = 0 est une VARIABLE DE CLASSE (partagée par toutes les instances)\n\nLigne 3-4 : À chaque création d'instance, __init__() incrémente Compteur.count\n• a = Compteur() → Compteur.count = 1\n• b = Compteur() → Compteur.count = 2\n• c = Compteur() → Compteur.count = 3\n\nLigne 9 : print(Compteur.count) affiche 3\n\n💡 Solution piégeuse : On pourrait penser que chaque instance a son propre count = 1, mais count est une variable de CLASSE donc partagée entre toutes les instances. C'est différent de self.count qui serait une variable d'instance.",
    "highlightedLines": [2, 4],
    "xpGain": 30,
    "tags": ["classes", "class-variables", "instances"]
  },
  {
    "id": "py_hard_002",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def generateur():\n    for i in range(3):\n        yield i * 2\n\ng = generateur()\nprint(next(g) + next(g))",
    "options": ["0", "2", "4", "6"],
    "correctAnswer": 1,
    "explanation": "⚠️ PIÈGE : Les générateurs maintiennent leur état entre les appels next()\n\nLigne 1-3 : generateur() est une fonction génératrice (yield)\n\nLigne 5 : g = generateur() crée un générateur (ne l'exécute pas encore)\n\nLigne 6 : Deux appels à next(g)\n• Premier next(g) :\n  - i = 0, yield 0 * 2 = 0\n  - La fonction se met en pause\n• Deuxième next(g) :\n  - Reprend où elle s'était arrêtée\n  - i = 1, yield 1 * 2 = 2\n• Calcul : 0 + 2 = 2\n\n💡 Solution piégeuse : On pourrait penser que next(g) retourne toujours 0 (réinitialise), ou que le résultat est 0+4=4 (skip une valeur), mais le générateur maintient son état et retourne les valeurs successivement.",
    "highlightedLines": [3, 6],
    "xpGain": 30,
    "tags": ["generators", "yield", "next"]
  },
  {
    "id": "py_hard_003",
    "language": "python",
    "difficulty": 3,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne causera une erreur à l'exécution ?",
    "code": "def calculer(a, b=5, c):\n    return a + b + c\n\nresult = calculer(1, 2, 3)\nprint(result)",
    "clickableLines": [1, 2, 3, 4, 5],
    "correctAnswer": 1,
    "explanation": "⚠️ PIÈGE : Ordre des paramètres avec valeurs par défaut\n\nLigne 1 : SyntaxError - paramètre avec défaut avant paramètre sans défaut\n\nEn Python, les paramètres avec valeur par défaut doivent venir APRÈS ceux sans défaut\n\nErreur : def calculer(a, b=5, c) → c n'a pas de défaut mais vient après b qui en a\n\n💡 Corrections possibles :\n• def calculer(a, c, b=5):\n• def calculer(a, b=5, c=0):\n• def calculer(a, b, c):\n\nCette erreur est détectée AVANT l'exécution (SyntaxError), pas pendant.",
    "highlightedLines": [1],
    "xpGain": 30,
    "tags": ["functions", "parameters", "defaults", "syntax"]
  },
  {
    "id": "py_hard_004",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de result ?",
    "code": "values = [1, 2, 3, 4, 5]\nresult = sum([x for x in values if x % 2 != 0])\nprint(result)",
    "acceptedAnswers": ["9", "9.0"],
    "explanation": "⚠️ PIÈGE : Combinaison list comprehension + sum + condition modulo\n\nLigne 1 : values = [1, 2, 3, 4, 5]\n\nLigne 2 : List comprehension avec filtrage\n• if x % 2 != 0 : garde les nombres IMPAIRS\n  - 1 % 2 = 1 (!=0) ✓\n  - 2 % 2 = 0 (==0) ✗\n  - 3 % 2 = 1 (!=0) ✓\n  - 4 % 2 = 0 (==0) ✗\n  - 5 % 2 = 1 (!=0) ✓\n• Liste filtrée : [1, 3, 5]\n• sum([1, 3, 5]) = 9\n\nLigne 3 : print() affiche 9\n\n💡 Solution piégeuse : Il faut bien comprendre que x % 2 != 0 sélectionne les impairs (1, 3, 5), pas les pairs. La somme 1+3+5 = 9.",
    "highlightedLines": [2],
    "xpGain": 30,
    "tags": ["list-comprehension", "sum", "modulo", "filtering"]
  },
  {
    "id": "py_hard_005",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "try:\n    x = int('abc')\nexcept ValueError:\n    x = 0\nexcept:\n    x = -1\nfinally:\n    x += 10\nprint(x)",
    "options": ["-1", "0", "10", "Error"],
    "correctAnswer": 2,
    "explanation": "⚠️ PIÈGE : L'ordre d'exécution try-except-finally et les types d'erreurs\n\nLigne 2 : int('abc') génère une ValueError (conversion impossible)\n\nLigne 3-4 : Le bloc except ValueError attrape l'erreur\n• x = 0\n\nLigne 5-6 : Le bloc except générique N'EST PAS exécuté (l'erreur est déjà attrapée)\n\nLigne 7-8 : Le bloc finally s'exécute TOUJOURS\n• x += 10 → x = 0 + 10 = 10\n\nLigne 9 : print(x) affiche 10\n\n💡 Solution piégeuse : On pourrait penser que x reste à 0, mais finally s'exécute TOUJOURS après un try-except, même si une erreur a été attrapée. C'est utilisé pour nettoyer les ressources (fermer fichiers, connexions, etc.).",
    "highlightedLines": [3, 4, 7, 8],
    "xpGain": 30,
    "tags": ["exceptions", "try-except", "finally", "error-handling"]
  },
  {
    "id": "py_hard_006",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "matrix = [[1, 2], [3, 4], [5, 6]]\nresult = [row[1] for row in matrix]\nprint(sum(result))",
    "options": ["6", "9", "12", "21"],
    "correctAnswer": 2,
    "explanation": "⚠️ PIÈGE : List comprehension sur matrice 2D avec indexation\n\nLigne 1 : matrix = [[1, 2], [3, 4], [5, 6]]\n• 3 lignes, 2 colonnes chacune\n\nLigne 2 : [row[1] for row in matrix] extrait la 2e colonne\n• row = [1, 2] → row[1] = 2\n• row = [3, 4] → row[1] = 4\n• row = [5, 6] → row[1] = 6\n• result = [2, 4, 6]\n\nLigne 3 : sum([2, 4, 6]) = 12\n\n💡 Solution piégeuse : On pourrait penser qu'on additionne toute la matrice (1+2+3+4+5+6=21), ou seulement la première ligne (1+2=3), mais on extrait spécifiquement la 2e colonne (index 1) de chaque ligne.",
    "highlightedLines": [2],
    "xpGain": 30,
    "tags": ["list-comprehension", "2d-lists", "indexing"]
  },
  {
    "id": "py_hard_007",
    "language": "python",
    "difficulty": 3,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce code ?",
    "code": "def decorator(func):\n    def wrapper(*args, **kwargs):\n        print('Avant')\n        result = func(*args, **kwargs)\n        print('Après')\n        return result\n    return wrapper\n\n@decorator\ndef dire_bonjour(nom):\n    print(f'Bonjour {nom}')",
    "options": [
      "Affiche seulement 'Bonjour {nom}'",
      "Affiche 'Avant', 'Bonjour {nom}', 'Après'",
      "Génère une erreur de syntaxe",
      "Remplace dire_bonjour par decorator"
    ],
    "correctAnswer": 1,
    "explanation": "⚠️ PIÈGE : Comprendre les décorateurs Python\n\nLe @decorator avant dire_bonjour est équivalent à :\ndire_bonjour = decorator(dire_bonjour)\n\nQuand on appelle dire_bonjour('Alice') :\n1. C'est wrapper() qui s'exécute\n2. wrapper() exécute print('Avant')\n3. wrapper() appelle func() (l'original dire_bonjour)\n4. func() exécute print('Bonjour Alice')\n5. wrapper() exécute print('Après')\n\nRésultat affiché :\nAvant\nBonjour Alice\nAprès\n\n💡 Solution piégeuse : Les décorateurs permettent d'ajouter du code avant/après une fonction sans modifier son code. C'est comme une enveloppe autour de la fonction originale.",
    "highlightedLines": [1, 2, 3, 4, 5, 9],
    "xpGain": 30,
    "tags": ["decorators", "functions", "wrappers"]
  },
  {
    "id": "py_hard_008",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Combien de fois 'test' est-il affiché ?",
    "code": "for i in range(5):\n    if i == 2:\n        continue\n    if i == 4:\n        break\n    print('test')",
    "acceptedAnswers": ["3", "3.0"],
    "explanation": "⚠️ PIÈGE : Combinaison continue et break dans une boucle\n\nDéroulement détaillé :\n\n• i = 0 : pas de condition → print('test') ✓ (1ère fois)\n\n• i = 1 : pas de condition → print('test') ✓ (2ème fois)\n\n• i = 2 : if i == 2 → continue (saute le print)\n\n• i = 3 : pas de condition → print('test') ✓ (3ème fois)\n\n• i = 4 : if i == 4 → break (sort de la boucle, ne print pas)\n\nTotal : 'test' affiché 3 fois\n\n💡 Solution piégeuse : On pourrait compter 5 (toutes les itérations) ou 4 (en oubliant continue), mais il faut bien suivre le flow : continue saute i=2, break sort à i=4 avant le print.",
    "highlightedLines": [2, 3, 4, 5],
    "xpGain": 30,
    "tags": ["loops", "continue", "break", "control-flow"]
  },
  {
    "id": "py_hard_009",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def mystere(lst=[]):\n    lst.append(1)\n    return lst\n\na = mystere()\nb = mystere()\nprint(len(b))",
    "options": ["1", "2", "0", "Error"],
    "correctAnswer": 1,
    "explanation": "⚠️ PIÈGE CLASSIQUE : Valeur par défaut mutable en Python\n\nLa liste [] par défaut est créée UNE SEULE FOIS à la définition de la fonction, pas à chaque appel !\n\nLigne 4 : a = mystere()\n• lst = [] (liste par défaut)\n• lst.append(1) → lst = [1]\n• return [1]\n\nLigne 5 : b = mystere()\n• lst = MÊME liste que précédemment [1] !\n• lst.append(1) → lst = [1, 1]\n• return [1, 1]\n\nLigne 6 : len(b) = len([1, 1]) = 2\n\n💡 Solution piégeuse : C'est une erreur fréquente ! La liste par défaut est partagée entre tous les appels. Pour éviter : def mystere(lst=None): if lst is None: lst = []",
    "highlightedLines": [1, 2, 4, 5],
    "xpGain": 30,
    "tags": ["functions", "mutable-defaults", "tricky", "common-mistakes"]
  },
  {
    "id": "py_hard_010",
    "language": "python",
    "difficulty": 3,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "predefined",
    "question": "Quel est le type de 'unique' ?",
    "code": "numbers = [1, 2, 2, 3, 3, 3]\nunique = {x for x in numbers}\nprint(type(unique).__name__)",
    "acceptedAnswers": ["set"],
    "explanation": "⚠️ PIÈGE : Différence entre list comprehension [...] et set comprehension {...}\n\nLigne 1 : numbers = [1, 2, 2, 3, 3, 3]\n\nLigne 2 : {x for x in numbers} est une SET COMPREHENSION (accolades {})\n• Comme [x for x in numbers] mais avec {}\n• Un set élimine automatiquement les doublons\n• unique = {1, 2, 3} (type: set)\n\nLigne 3 : type(unique).__name__ retourne 'set'\n\n💡 Solution piégeuse :\n• [...] → list\n• (...) → generator (tuple si pas de for)\n• {...} → set (ou dict si key:value)\n\nLes sets sont non ordonnés et n'acceptent pas les doublons, parfait pour obtenir les valeurs uniques !",
    "highlightedLines": [2],
    "xpGain": 30,
    "tags": ["sets", "comprehensions", "types", "duplicates"]
  }
]

[
  {
    "id": "py_easy_001",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "shopping_cart = ['pain', 'lait', 'œufs']\nshopping_cart.append('fromage')\ntotal_items = len(shopping_cart)\nprint(total_items)",
    "options": ["3", "4", "5", "Error"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : On crée une liste shopping_cart avec 3 items initiaux\n\nLigne 2 : append('fromage') ajoute un nouvel élément → maintenant 4 items au total\n\nLigne 3 : len(shopping_cart) compte tous les éléments → retourne 4\n\nLigne 4 : print() affiche le résultat : 4",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["lists", "methods", "len"]
  },
  {
    "id": "py_easy_002",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "user_score = 0\nfor level in range(3):\n    user_score += 10\nprint(user_score)",
    "options": ["10", "30", "3", "0"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : user_score démarre à 0\n\nLigne 2 : range(3) génère [0, 1, 2] → la boucle s'exécute 3 fois\n\nLigne 3 : À chaque itération, on ajoute 10 au score\n• 1ère fois : 0 + 10 = 10\n• 2ème fois : 10 + 10 = 20\n• 3ème fois : 20 + 10 = 30\n\nLigne 4 : print() affiche le score final : 30",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["loops", "range", "arithmetic"]
  },
  {
    "id": "py_easy_003",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "employee_name = 'Alice'\nwelcome_message = 'Bonjour ' + employee_name\nprint(len(welcome_message))",
    "options": ["5", "8", "13", "14"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : employee_name stocke 'Alice' (5 caractères)\n\nLigne 2 : Concaténation de chaînes\n• 'Bonjour ' = 8 caractères (avec l'espace)\n• + 'Alice' = 5 caractères\n• Résultat : 'Bonjour Alice' = 13 caractères total\n\nLigne 3 : len() compte tous les caractères → retourne 13",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["strings", "concatenation", "len"]
  },
  {
    "id": "py_easy_004",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "temperature = 15\nif temperature > 20:\n    comfort_level = 'chaud'\nelse:\n    comfort_level = 'froid'\nprint(comfort_level)",
    "options": ["chaud", "froid", "15", "Error"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : temperature vaut 15\n\nLigne 2 : Condition if temperature > 20\n• 15 > 20 est False\n• Donc on saute le bloc if (ligne 3)\n\nLigne 4-5 : On exécute le bloc else\n• comfort_level = 'froid'\n\nLigne 6 : print() affiche 'froid'",
    "highlightedLines": [2, 5],
    "xpGain": 10,
    "tags": ["conditions", "if-else", "comparison"]
  },
  {
    "id": "py_easy_005",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "inventory = [10, 5, 8]\nfirst_item = inventory[0]\nlast_item = inventory[-1]\nresult = first_item + last_item\nprint(result)",
    "options": ["13", "18", "15", "23"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : inventory contient [10, 5, 8]\n\nLigne 2 : inventory[0] récupère le premier élément → 10\n\nLigne 3 : inventory[-1] récupère le dernier élément → 8\n\nLigne 4 : Addition 10 + 8 = 18\n\nLigne 5 : print() affiche 18",
    "highlightedLines": [2, 3, 4],
    "xpGain": 10,
    "tags": ["lists", "indexing", "arithmetic"]
  },
  {
    "id": "py_easy_006",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "price = 50\ndiscount = 10\nfinal_price = price - discount\nprint(final_price)",
    "acceptedAnswers": ["40", "40.0"],
    "explanation": "Ligne 1 : price vaut 50\n\nLigne 2 : discount vaut 10\n\nLigne 3 : Soustraction 50 - 10 = 40\n\nLigne 4 : print() affiche 40",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "subtraction"]
  },
  {
    "id": "py_easy_007",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [2, 4, 6, 8]\ntotal = 0\nfor num in numbers:\n    total += num\nprint(total)",
    "acceptedAnswers": ["20", "20.0"],
    "explanation": "Ligne 2 : total démarre à 0\n\nLigne 3-4 : Boucle qui additionne tous les nombres\n• 0 + 2 = 2\n• 2 + 4 = 6\n• 6 + 6 = 12\n• 12 + 8 = 20\n\nLigne 5 : print() affiche 20",
    "highlightedLines": [3, 4],
    "xpGain": 10,
    "tags": ["loops", "arithmetic", "sum"]
  },
  {
    "id": "py_easy_008",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nsubstring = text[0:3]\nprint(substring)",
    "options": ["Pyt", "Pyth", "Python", "hon"],
    "correctAnswer": 0,
    "explanation": "Ligne 1 : text contient 'Python'\n\nLigne 2 : Slicing text[0:3]\n• Commence à l'index 0 (inclus) : 'P'\n• S'arrête à l'index 3 (exclus) : jusqu'à 't'\n• Résultat : 'Pyt'\n\nLigne 3 : print() affiche 'Pyt'",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["strings", "slicing", "indexing"]
  },
  {
    "id": "py_easy_009",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "counter = 5\nwhile counter > 0:\n    counter -= 2\nprint(counter)",
    "acceptedAnswers": ["-1", "-1.0"],
    "explanation": "Ligne 1 : counter démarre à 5\n\nLigne 2-3 : Boucle while tant que counter > 0\n• Itération 1 : counter = 5 - 2 = 3 (encore > 0)\n• Itération 2 : counter = 3 - 2 = 1 (encore > 0)\n• Itération 3 : counter = 1 - 2 = -1 (plus > 0, on sort)\n\nLigne 4 : print() affiche -1",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["while", "loops", "counter"]
  },
  {
    "id": "py_easy_010",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [1, 2, 3, 4, 5]\nresult = numbers[2] * 2\nprint(result)",
    "options": ["4", "6", "8", "10"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : numbers contient [1, 2, 3, 4, 5]\n\nLigne 2 : numbers[2] accède au 3ème élément (index 2) → 3\n• Puis multiplication par 2 : 3 * 2 = 6\n\nLigne 3 : print() affiche 6",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "indexing", "arithmetic"]
  },
  {
    "id": "py_easy_011",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "age = 25\nname = 'Marc'\nprint('Tu as', age, 'ans)\nprint('Bonjour', name)",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 3,
    "explanation": "Ligne 3 : Erreur de syntaxe - guillemet fermant manquant\n\nLa chaîne commence par un guillemet simple ' mais ne se termine pas avant la parenthèse.\n\nCorrection : print('Tu as', age, 'ans')",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["syntax", "strings", "quotes"]
  },
  {
    "id": "py_easy_012",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de x ?",
    "code": "x = 10\nx = x + 5\nx = x * 2\nprint(x)",
    "acceptedAnswers": ["30", "30.0"],
    "explanation": "Ligne 1 : x = 10\n\nLigne 2 : x = 10 + 5 = 15\n\nLigne 3 : x = 15 * 2 = 30\n\nLigne 4 : print() affiche 30",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "assignment"]
  },
  {
    "id": "py_easy_013",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "fruits = ['pomme', 'banane', 'orange']\nfor fruit in fruits:\n    print(fruit.upper())",
    "options": [
      "Affiche chaque fruit en minuscules",
      "Affiche chaque fruit en majuscules",
      "Compte le nombre de fruits",
      "Trie les fruits par ordre alphabétique"
    ],
    "correctAnswer": 1,
    "explanation": "La méthode .upper() convertit une chaîne en MAJUSCULES.\n\nLa boucle for parcourt chaque élément de la liste fruits et affiche sa version en majuscules :\n• POMME\n• BANANE\n• ORANGE",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["strings", "methods", "loops"]
  },
  {
    "id": "py_easy_014",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "numbers = [1, 2, 3]\nfor i in range(3):\n  result = numbers[i] * 2\n    print(result)",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 4,
    "explanation": "Ligne 4 : Erreur d'indentation\n\nLe print() a une indentation incorrecte (4 espaces au lieu de 2). En Python, tous les statements dans un même bloc doivent avoir la même indentation.\n\nCorrection : aligner print(result) avec result = ...",
    "highlightedLines": [4],
    "xpGain": 10,
    "tags": ["syntax", "indentation", "loops"]
  },
  {
    "id": "py_easy_015",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "a = 7\nb = 3\nresult = a // b\nprint(result)",
    "acceptedAnswers": ["2", "2.0"],
    "explanation": "Ligne 3 : L'opérateur // est la division entière (floor division)\n\n7 // 3 donne le quotient entier sans la partie décimale :\n• 7 / 3 = 2.333...\n• 7 // 3 = 2 (partie entière seulement)\n\nLigne 4 : print() affiche 2",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["arithmetic", "operators", "division"]
  },
  {
    "id": "py_easy_016",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "message = 'Bonjour'\nif len(message) > 5:\n    print('Message long')\nelse:\n    print('Message court')",
    "options": [
      "Affiche 'Message long'",
      "Affiche 'Message court'",
      "Compte les lettres",
      "Affiche le message"
    ],
    "correctAnswer": 0,
    "explanation": "Ligne 1 : message = 'Bonjour' (7 caractères)\n\nLigne 2 : len(message) retourne 7, et 7 > 5 est True\n\nDonc le programme exécute le bloc if et affiche 'Message long'",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["strings", "len", "conditions"]
  },
  {
    "id": "py_easy_017",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de count ?",
    "code": "count = 0\nfor i in range(5):\n    count += 1\nprint(count)",
    "acceptedAnswers": ["5", "5.0"],
    "explanation": "Ligne 1 : count démarre à 0\n\nLigne 2 : range(5) génère [0, 1, 2, 3, 4] → 5 itérations\n\nLigne 3 : À chaque itération, count augmente de 1\n• count = 1, 2, 3, 4, 5\n\nLigne 4 : print() affiche 5",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["loops", "counter", "range"]
  },
  {
    "id": "py_easy_018",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "name = 'Alice'\nage = 30\nresultat = name + age\nprint(resultat)",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 3,
    "explanation": "Ligne 3 : TypeError - Impossible de concaténer str + int\n\nPython ne peut pas additionner directement une chaîne ('Alice') avec un nombre (30).\n\nCorrection : resultat = name + str(age) ou utiliser f-string",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["types", "strings", "concatenation", "errors"]
  },
  {
    "id": "py_easy_019",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [10, 20, 30]\nnumbers.pop()\nprint(len(numbers))",
    "options": ["0", "1", "2", "3"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : numbers contient 3 éléments [10, 20, 30]\n\nLigne 2 : pop() supprime et retourne le dernier élément (30)\n• numbers devient [10, 20] → 2 éléments\n\nLigne 3 : len(numbers) retourne 2",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "methods", "pop", "len"]
  },
  {
    "id": "py_easy_020",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de total ?",
    "code": "total = 100\ntotal -= 20\ntotal *= 2\nprint(total)",
    "acceptedAnswers": ["160", "160.0"],
    "explanation": "Ligne 1 : total = 100\n\nLigne 2 : total -= 20 → total = 100 - 20 = 80\n\nLigne 3 : total *= 2 → total = 80 * 2 = 160\n\nLigne 4 : print() affiche 160",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "operators"]
  },
  {
    "id": "py_easy_021",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait cette fonction ?",
    "code": "def double(x):\n    return x * 2\n\nresult = double(5)\nprint(result)",
    "options": [
      "Affiche 5",
      "Affiche 10",
      "Affiche 25",
      "Provoque une erreur"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1-2 : La fonction double() prend un paramètre x et retourne x * 2\n\nLigne 4 : double(5) appelle la fonction avec x = 5\n• Retourne 5 * 2 = 10\n\nLigne 5 : print() affiche 10",
    "highlightedLines": [2, 4],
    "xpGain": 10,
    "tags": ["functions", "parameters", "return"]
  },
  {
    "id": "py_easy_022",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "colors = ['rouge', 'vert', 'bleu']\nprint(colors[3])\nprint('Couleur trouvée')",
    "clickableLines": [1, 2, 3],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : IndexError - list index out of range\n\nLa liste colors a 3 éléments aux index 0, 1, 2.\nL'index 3 n'existe pas !\n\nCorrection : utiliser colors[0], colors[1] ou colors[2]",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "indexing", "errors", "range"]
  },
  {
    "id": "py_easy_023",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "x = 12\ny = 5\nresult = x % y\nprint(result)",
    "acceptedAnswers": ["2", "2.0"],
    "explanation": "Ligne 3 : L'opérateur % calcule le reste de la division (modulo)\n\n12 % 5 :\n• 12 / 5 = 2 avec un reste de 2\n• 5 * 2 = 10, il reste 12 - 10 = 2\n\nLigne 4 : print() affiche 2",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["arithmetic", "operators", "modulo"]
  },
  {
    "id": "py_easy_024",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "numbers = [5, 2, 8, 1, 9]\nnumbers.sort()\nprint(numbers[0])",
    "options": [
      "Affiche le plus grand nombre",
      "Affiche le plus petit nombre",
      "Affiche le premier nombre",
      "Affiche la longueur de la liste"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 2 : sort() trie la liste par ordre croissant\n• numbers devient [1, 2, 5, 8, 9]\n\nLigne 3 : numbers[0] accède au premier élément après le tri\n• Premier élément = plus petit nombre = 1",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["lists", "methods", "sort", "indexing"]
  },
  {
    "id": "py_easy_025",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "def greet(name):\n    print('Bonjour', nom)\n\ngreet('Alice')",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : NameError - variable 'nom' non définie\n\nLe paramètre de la fonction s'appelle 'name', pas 'nom'.\n\nCorrection : print('Bonjour', name)",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["functions", "variables", "errors", "scope"]
  },
  {
    "id": "py_easy_026",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de n ?",
    "code": "n = 3\nn = n ** 2\nn = n + 1\nprint(n)",
    "acceptedAnswers": ["10", "10.0"],
    "explanation": "Ligne 1 : n = 3\n\nLigne 2 : n = 3 ** 2 (3 puissance 2) = 9\n\nLigne 3 : n = 9 + 1 = 10\n\nLigne 4 : print() affiche 10",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "power"]
  },
  {
    "id": "py_easy_027",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nprint(text[-1])",
    "options": ["P", "y", "n", "h"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : text = 'Python'\n\nLigne 2 : text[-1] accède au dernier caractère avec un index négatif\n• Index -1 = dernier élément = 'n'\n\nprint() affiche 'n'",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["strings", "indexing", "negative_index"]
  },
  {
    "id": "py_easy_028",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "score = 85\nif score >= 50\n    print('Réussi')\nelse:\n    print('Échoué')",
    "clickableLines": [1, 2, 3, 4, 5],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : Erreur de syntaxe - deux-points manquants\n\nEn Python, toute instruction if doit se terminer par :\n\nCorrection : if score >= 50:",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["syntax", "conditions", "if"]
  },
  {
    "id": "py_easy_029",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [2, 4, 6]\nresult = sum(numbers)\nprint(result)",
    "acceptedAnswers": ["12", "12.0"],
    "explanation": "Ligne 1 : numbers = [2, 4, 6]\n\nLigne 2 : sum() additionne tous les éléments de la liste\n• 2 + 4 + 6 = 12\n\nLigne 3 : print() affiche 12",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "sum", "functions"]
  },
  {
    "id": "py_easy_030",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "numbers = [1, 2, 3]\ntotal = 0\nfor num in numbers\n    total += num\nprint(total)",
    "clickableLines": [1, 2, 3, 4, 5],
    "correctAnswer": 3,
    "explanation": "Ligne 3 : Erreur de syntaxe - deux-points manquants\n\nToute boucle for doit se terminer par :\n\nCorrection : for num in numbers:",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["syntax", "loops", "for"]
  },
  {
    "id": "py_medium_001",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def multiplier(x):\n    return lambda y: x * y\n\ndouble = multiplier(2)\nresult = double(5)\nprint(result)",
    "options": ["2", "5", "10", "Error"],
    "correctAnswer": 2,
    "explanation": "Ligne 1-2 : La fonction multiplier(x) retourne une fonction lambda qui multiplie par x\n\nLigne 4 : double = multiplier(2) crée une nouvelle fonction\n• Cette fonction lambda garde en mémoire x = 2\n\nLigne 5 : double(5) appelle la lambda avec y = 5\n• La lambda calcule x * y = 2 * 5 = 10\n\nLigne 6 : print() affiche le résultat : 10",
    "highlightedLines": [2, 4, 5],
    "xpGain": 20,
    "tags": ["functions", "lambda", "closures"]
  },
  {
    "id": "py_medium_002",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [1, 2, 3, 4, 5]\nresult = [x * 2 for x in numbers if x % 2 == 0]\nprint(len(result))",
    "options": ["2", "5", "10", "4"],
    "correctAnswer": 0,
    "explanation": "Ligne 1 : numbers = [1, 2, 3, 4, 5]\n\nLigne 2 : La list comprehension filtre et transforme\n• if x % 2 == 0 garde seulement les nombres pairs\n• Nombres pairs : 2 et 4\n• x * 2 multiplie chaque nombre par 2\n• result = [2*2, 4*2] = [4, 8]\n\nLigne 3 : len(result) compte les éléments de la liste\n• len([4, 8]) = 2\n\nLe programme affiche 2",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["list-comprehension", "filter", "modulo"]
  },
  {
    "id": "py_medium_003",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de x ?",
    "code": "x = 5\ndef modifier():\n    x = 10\n    return x\n\nmodifier()\nprint(x)",
    "acceptedAnswers": ["5", "5.0"],
    "explanation": "Ligne 1 : x = 5 (variable globale)\n\nLigne 2-4 : La fonction modifier() crée une nouvelle variable x = 10\n• Cette variable x est LOCALE à la fonction\n• Elle est différente du x global\n• Elle n'affecte pas le x global\n\nLigne 6 : modifier() s'exécute\n• Le x local = 10 existe seulement dans la fonction\n• Le x global reste inchangé\n\nLigne 7 : print(x) affiche le x global = 5\n\nPour modifier x global, il faudrait utiliser le mot-clé 'global' dans la fonction",
    "highlightedLines": [2, 3],
    "xpGain": 20,
    "tags": ["scope", "functions", "variables"]
  },
  {
    "id": "py_medium_004",
    "language": "python",
    "difficulty": 2,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur logique ?",
    "code": "def calculer_moyenne(notes):\n    total = sum(notes)\n    moyenne = total / len(notes)\n    return round(moyenne)\n\nresultat = calculer_moyenne([])\nprint(resultat)",
    "clickableLines": [1, 2, 3, 4, 5, 6, 7],
    "correctAnswer": 6,
    "explanation": "Ligne 6 : calculer_moyenne([]) appelle la fonction avec une liste vide\n\nDans la fonction :\n• Ligne 2 : total = sum([]) = 0\n• Ligne 3 : moyenne = total / len(notes)\n  - len([]) = 0\n  - moyenne = 0 / 0 → ZeroDivisionError !\n\nErreur : Division par zéro car la liste est vide\n\nCorrection : Vérifier si la liste est vide avant de calculer\n\ndef calculer_moyenne(notes):\n    if len(notes) == 0:\n        return 0\n    total = sum(notes)\n    moyenne = total / len(notes)\n    return round(moyenne)",
    "highlightedLines": [6],
    "xpGain": 20,
    "tags": ["functions", "errors", "edge-cases"]
  },
  {
    "id": "py_medium_005",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nresult = text[1:4]\nprint(result)",
    "options": ["Pyt", "yth", "ytho", "tho"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : text = 'Python'\n• Les indices sont : P=0, y=1, t=2, h=3, o=4, n=5\n\nLigne 2 : text[1:4] extrait une partie de la chaîne\n• Démarre à l'index 1 (inclus) : 'y'\n• S'arrête à l'index 4 (exclu) : ne prend pas 'o'\n• Extrait les caractères aux indices 1, 2, 3\n• Index 1 : 'y'\n• Index 2 : 't'\n• Index 3 : 'h'\n• result = 'yth'\n\nLigne 3 : print() affiche 'yth'\n\nRemarque : En Python, le slicing [début:fin] inclut début mais exclut fin",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["strings", "slicing", "indexing"]
  },
  {
    "id": "py_medium_006",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "data = {'a': 1, 'b': 2}\ndata['c'] = data.get('a', 0) + data.get('d', 0)\nprint(data['c'])",
    "options": ["0", "1", "2", "3"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : data = {'a': 1, 'b': 2}\n• Dictionnaire avec 2 clés : 'a' et 'b'\n\nLigne 2 : Calcul de la valeur de data['c']\n• data.get('a', 0) cherche la clé 'a'\n  - La clé existe → retourne 1\n• data.get('d', 0) cherche la clé 'd'\n  - La clé n'existe pas → retourne la valeur par défaut 0\n• data['c'] = 1 + 0 = 1\n\nLigne 3 : print(data['c']) affiche 1\n\nRemarque : .get(clé, défaut) permet d'éviter les erreurs si la clé n'existe pas",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["dictionaries", "get", "methods"]
  },
  {
    "id": "py_medium_007",
    "language": "python",
    "difficulty": 2,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "def factorielle(n):\n    if n <= 1:\n        return 1\n    return n * factorielle(n - 1)\n\nresult = factorielle(5)",
    "options": [
      "Calcule 5 + 4 + 3 + 2 + 1",
      "Calcule 5 * 4 * 3 * 2 * 1",
      "Calcule 5^4",
      "Génère une erreur (récursion infinie)"
    ],
    "correctAnswer": 1,
    "explanation": "Ce code calcule la factorielle de n de manière récursive\n\nLigne 2-3 : Cas de base\n• Si n <= 1, la fonction retourne 1\n• Cela arrête la récursion\n\nLigne 4 : Cas récursif\n• La fonction s'appelle elle-même avec n-1\n• Multiplie n par le résultat\n\nExécution pour factorielle(5) :\n• factorielle(5) = 5 * factorielle(4)\n• factorielle(4) = 4 * factorielle(3)\n• factorielle(3) = 3 * factorielle(2)\n• factorielle(2) = 2 * factorielle(1)\n• factorielle(1) = 1 (cas de base)\n\nRésultat : 5 * 4 * 3 * 2 * 1 = 120\n\nLe programme calcule donc 5 * 4 * 3 * 2 * 1",
    "highlightedLines": [2, 3, 4],
    "xpGain": 20,
    "tags": ["recursion", "functions", "factorielle"]
  },
  {
    "id": "py_medium_008",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Combien d'itérations la boucle effectue-t-elle ?",
    "code": "count = 0\nfor i in range(2, 10, 3):\n    count += 1\nprint(count)",
    "acceptedAnswers": ["3", "3.0"],
    "explanation": "Ligne 1 : count = 0\n\nLigne 2 : range(2, 10, 3) génère une séquence\n• Départ : 2\n• Fin : 10 (exclu)\n• Pas : 3 (on avance de 3 en 3)\n\nValeurs générées par range :\n• i = 2 → count = 1\n• i = 5 (2+3) → count = 2\n• i = 8 (5+3) → count = 3\n• i = 11 (8+3) → trop grand (11 >= 10), la boucle s'arrête\n\nLigne 4 : print(count) affiche 3\n\nLa boucle s'exécute 3 fois",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["range", "loops", "step"]
  },
  {
    "id": "py_medium_009",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def modifier_liste(lst):\n    lst.append(4)\n    return lst\n\noriginal = [1, 2, 3]\nnouvelle = modifier_liste(original)\nprint(len(original))",
    "options": ["3", "4", "7", "Error"],
    "correctAnswer": 1,
    "explanation": "Ligne 1-3 : La fonction modifier_liste prend une liste en paramètre\n• Ligne 2 : Ajoute 4 à la liste\n• Ligne 3 : Retourne la liste modifiée\n\nLigne 5 : original = [1, 2, 3]\n\nLigne 6 : modifier_liste(original)\n• En Python, les listes sont passées par référence\n• lst dans la fonction pointe vers la même liste que original\n• lst.append(4) modifie directement original\n• original devient [1, 2, 3, 4]\n\nLigne 7 : print(len(original)) affiche 4\n\nRemarque : La liste original a été modifiée par la fonction car les listes sont mutables",
    "highlightedLines": [2, 5],
    "xpGain": 20,
    "tags": ["lists", "mutability", "references"]
  },
  {
    "id": "py_medium_010",
    "language": "python",
    "difficulty": 2,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "predefined",
    "question": "Quel est le type de 'result' ?",
    "code": "values = [1, 2, 3]\nresult = map(lambda x: x ** 2, values)\nprint(type(result).__name__)",
    "acceptedAnswers": ["map"],
    "explanation": "Ligne 1 : values = [1, 2, 3]\n\nLigne 2 : map(lambda x: x ** 2, values)\n• map() applique la fonction lambda à chaque élément\n• lambda x: x ** 2 calcule le carré de x\n• map() retourne un objet map (itérateur), pas une liste directement\n• Pour obtenir une liste, il faudrait écrire : list(map(...))\n\nLigne 3 : type(result).__name__ retourne le nom du type\n• result est de type 'map'\n\nLe programme affiche 'map'\n\nRemarque : Pour obtenir [1, 4, 9], il faudrait utiliser list(map(lambda x: x ** 2, values))",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["map", "lambda", "types", "iterators"]
  },
  {
    "id": "py_hard_001",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "class Compteur:\n    count = 0\n    def __init__(self):\n        Compteur.count += 1\n\na = Compteur()\nb = Compteur()\nc = Compteur()\nprint(Compteur.count)",
    "options": ["0", "1", "3", "Error"],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : count = 0 est une variable de classe\n• Elle est partagée par toutes les instances de Compteur\n\nLigne 3-4 : Méthode __init__() appelée à chaque création d'instance\n• Compteur.count += 1 incrémente la variable de classe\n\nCréation des instances :\n• Ligne 6 : a = Compteur() → Compteur.count = 1\n• Ligne 7 : b = Compteur() → Compteur.count = 2\n• Ligne 8 : c = Compteur() → Compteur.count = 3\n\nLigne 9 : print(Compteur.count) affiche 3\n\nRemarque : Une variable de classe est partagée entre toutes les instances, contrairement à une variable d'instance (self.count)",
    "highlightedLines": [2, 4],
    "xpGain": 30,
    "tags": ["classes", "class-variables", "instances"]
  },
  {
    "id": "py_hard_002",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def generateur():\n    for i in range(3):\n        yield i * 2\n\ng = generateur()\nprint(next(g) + next(g))",
    "options": ["0", "2", "4", "6"],
    "correctAnswer": 1,
    "explanation": "Ligne 1-3 : generateur() est une fonction génératrice\n• Le mot-clé yield fait de cette fonction un générateur\n\nLigne 5 : g = generateur() crée l'objet générateur\n• Le code ne s'exécute pas encore\n\nLigne 6 : Deux appels à next(g)\n\nPremier appel next(g) :\n• i = 0 dans la boucle\n• yield 0 * 2 = 0\n• La fonction se met en pause et retourne 0\n\nDeuxième appel next(g) :\n• La fonction reprend là où elle s'était arrêtée\n• i = 1 dans la boucle\n• yield 1 * 2 = 2\n• La fonction retourne 2\n\nCalcul final : 0 + 2 = 2\n\nRemarque : Un générateur garde son état entre les appels next()",
    "highlightedLines": [3, 6],
    "xpGain": 30,
    "tags": ["generators", "yield", "next"]
  },
  {
    "id": "py_hard_003",
    "language": "python",
    "difficulty": 3,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne causera une erreur à l'exécution ?",
    "code": "def calculer(a, b=5, c):\n    return a + b + c\n\nresult = calculer(1, 2, 3)\nprint(result)",
    "clickableLines": [1, 2, 3, 4, 5],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : Erreur de syntaxe dans la définition de la fonction\n\nRègle Python : Les paramètres avec valeur par défaut doivent venir APRÈS les paramètres sans défaut\n\nProblème dans def calculer(a, b=5, c) :\n• a : paramètre sans défaut ✓\n• b=5 : paramètre avec défaut ✓\n• c : paramètre sans défaut ✗ (vient après b qui a un défaut)\n\nCette erreur génère une SyntaxError avant même l'exécution du programme\n\nCorrections possibles :\n• def calculer(a, c, b=5): - Mettre c avant b\n• def calculer(a, b=5, c=0): - Donner un défaut à c aussi\n• def calculer(a, b, c): - Retirer le défaut de b",
    "highlightedLines": [1],
    "xpGain": 30,
    "tags": ["functions", "parameters", "defaults", "syntax"]
  },
  {
    "id": "py_hard_004",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de result ?",
    "code": "values = [1, 2, 3, 4, 5]\nresult = sum([x for x in values if x % 2 != 0])\nprint(result)",
    "acceptedAnswers": ["9", "9.0"],
    "explanation": "Ligne 1 : values = [1, 2, 3, 4, 5]\n\nLigne 2 : List comprehension avec condition\n• if x % 2 != 0 garde seulement les nombres impairs\n• L'opérateur % (modulo) donne le reste de la division\n\nVérification pour chaque nombre :\n• 1 % 2 = 1 (≠ 0) → 1 est impair ✓\n• 2 % 2 = 0 (= 0) → 2 est pair ✗\n• 3 % 2 = 1 (≠ 0) → 3 est impair ✓\n• 4 % 2 = 0 (= 0) → 4 est pair ✗\n• 5 % 2 = 1 (≠ 0) → 5 est impair ✓\n\nListe des impairs : [1, 3, 5]\nsum([1, 3, 5]) = 1 + 3 + 5 = 9\n\nLigne 3 : print() affiche 9",
    "highlightedLines": [2],
    "xpGain": 30,
    "tags": ["list-comprehension", "sum", "modulo", "filtering"]
  },
  {
    "id": "py_hard_005",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "try:\n    x = int('abc')\nexcept ValueError:\n    x = 0\nexcept:\n    x = -1\nfinally:\n    x += 10\nprint(x)",
    "options": ["-1", "0", "10", "Error"],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : int('abc') tente de convertir 'abc' en entier\n• Cette conversion est impossible\n• Génère une ValueError\n\nLigne 3-4 : Le bloc except ValueError attrape l'erreur spécifique\n• x = 0\n\nLigne 5-6 : Le bloc except générique n'est PAS exécuté\n• L'erreur a déjà été attrapée par except ValueError\n\nLigne 7-8 : Le bloc finally s'exécute TOUJOURS\n• Peu importe s'il y a eu une erreur ou non\n• x += 10 → x = 0 + 10 = 10\n\nLigne 9 : print(x) affiche 10\n\nRemarque : Le bloc finally s'exécute dans tous les cas, c'est utile pour nettoyer les ressources (fermer des fichiers, connexions, etc.)",
    "highlightedLines": [3, 4, 7, 8],
    "xpGain": 30,
    "tags": ["exceptions", "try-except", "finally", "error-handling"]
  },
  {
    "id": "py_hard_006",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "matrix = [[1, 2], [3, 4], [5, 6]]\nresult = [row[1] for row in matrix]\nprint(sum(result))",
    "options": ["6", "9", "12", "21"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : matrix = [[1, 2], [3, 4], [5, 6]]\n• Matrice 2D : 3 lignes, 2 colonnes chacune\n\nLigne 2 : List comprehension [row[1] for row in matrix]\n• Itère sur chaque ligne (row) de la matrice\n• Extrait le 2e élément (index 1) de chaque ligne\n\nExtraction détaillée :\n• row = [1, 2] → row[1] = 2\n• row = [3, 4] → row[1] = 4\n• row = [5, 6] → row[1] = 6\n• result = [2, 4, 6]\n\nLigne 3 : sum([2, 4, 6]) = 2 + 4 + 6 = 12\n\nRemarque : row[1] extrait la 2e colonne de la matrice (index 1), pas la 1ère (index 0)",
    "highlightedLines": [2],
    "xpGain": 30,
    "tags": ["list-comprehension", "2d-lists", "indexing"]
  },
  {
    "id": "py_hard_007",
    "language": "python",
    "difficulty": 3,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce code ?",
    "code": "def decorator(func):\n    def wrapper(*args, **kwargs):\n        print('Avant')\n        result = func(*args, **kwargs)\n        print('Après')\n        return result\n    return wrapper\n\n@decorator\ndef dire_bonjour(nom):\n    print(f'Bonjour {nom}')",
    "options": [
      "Affiche seulement 'Bonjour {nom}'",
      "Affiche 'Avant', 'Bonjour {nom}', 'Après'",
      "Génère une erreur de syntaxe",
      "Remplace dire_bonjour par decorator"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1-7 : Définition du décorateur\n• decorator() prend une fonction en paramètre\n• wrapper() est une fonction interne qui enrobe func\n• *args, **kwargs permettent de passer tous types d'arguments\n• wrapper() retourne le résultat de func()\n\nLigne 9-11 : @decorator avant dire_bonjour\n• Équivalent à : dire_bonjour = decorator(dire_bonjour)\n• dire_bonjour devient wrapper avec func = dire_bonjour original\n\nExécution de dire_bonjour('Alice') :\n1. wrapper() s'exécute\n2. Ligne 3 : print('Avant')\n3. Ligne 4 : func('Alice') appelle dire_bonjour original\n4. Ligne 11 : print('Bonjour Alice')\n5. Ligne 5 : print('Après')\n\nRésultat affiché :\nAvant\nBonjour Alice\nAprès\n\nRemarque : Les décorateurs permettent d'ajouter du code avant/après une fonction sans modifier son code source",
    "highlightedLines": [1, 2, 3, 4, 5, 9],
    "xpGain": 30,
    "tags": ["decorators", "functions", "wrappers"]
  },
  {
    "id": "py_hard_008",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Combien de fois 'test' est-il affiché ?",
    "code": "for i in range(5):\n    if i == 2:\n        continue\n    if i == 4:\n        break\n    print('test')",
    "acceptedAnswers": ["3", "3.0"],
    "explanation": "Ligne 1 : Boucle for i in range(5)\n• i prend les valeurs 0, 1, 2, 3, 4\n\nDéroulement détaillé :\n\nItération i = 0 :\n• Ligne 2-3 : 0 ≠ 2, pas de continue\n• Ligne 4-5 : 0 ≠ 4, pas de break\n• Ligne 6 : print('test') ✓ (1ère fois)\n\nItération i = 1 :\n• Ligne 2-3 : 1 ≠ 2, pas de continue\n• Ligne 4-5 : 1 ≠ 4, pas de break\n• Ligne 6 : print('test') ✓ (2ème fois)\n\nItération i = 2 :\n• Ligne 2-3 : i == 2 → continue\n• Le continue saute le reste de l'itération (pas de print)\n\nItération i = 3 :\n• Ligne 2-3 : 3 ≠ 2, pas de continue\n• Ligne 4-5 : 3 ≠ 4, pas de break\n• Ligne 6 : print('test') ✓ (3ème fois)\n\nItération i = 4 :\n• Ligne 2-3 : 4 ≠ 2, pas de continue\n• Ligne 4-5 : i == 4 → break\n• Le break sort de la boucle (pas de print)\n\nTotal : 'test' affiché 3 fois\n\nRemarque : continue saute l'itération actuelle, break sort complètement de la boucle",
    "highlightedLines": [2, 3, 4, 5],
    "xpGain": 30,
    "tags": ["loops", "continue", "break", "control-flow"]
  },
  {
    "id": "py_hard_009",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def mystere(lst=[]):\n    lst.append(1)\n    return lst\n\na = mystere()\nb = mystere()\nprint(len(b))",
    "options": ["1", "2", "0", "Error"],
    "correctAnswer": 1,
    "explanation": "Ligne 1-3 : Fonction mystere avec paramètre par défaut lst=[]\n\nAttention : La liste [] par défaut est créée UNE SEULE FOIS à la définition de la fonction\n• Elle est partagée entre tous les appels de mystere()\n• Ce n'est PAS une nouvelle liste à chaque appel\n\nPremier appel - Ligne 4 : a = mystere()\n• lst pointe vers la liste par défaut []\n• Ligne 2 : lst.append(1) → lst devient [1]\n• Ligne 3 : return [1]\n• a = [1]\n\nDeuxième appel - Ligne 5 : b = mystere()\n• lst pointe vers la MÊME liste [1] (partagée)\n• Ligne 2 : lst.append(1) → lst devient [1, 1]\n• Ligne 3 : return [1, 1]\n• b = [1, 1]\n\nLigne 6 : len(b) = len([1, 1]) = 2\n\nRemarque : C'est une erreur Python classique ! Les valeurs par défaut mutables (listes, dictionnaires) sont partagées. Pour éviter : def mystere(lst=None): if lst is None: lst = []",
    "highlightedLines": [1, 2, 4, 5],
    "xpGain": 30,
    "tags": ["functions", "mutable-defaults", "tricky", "common-mistakes"]
  },
  {
    "id": "py_hard_010",
    "language": "python",
    "difficulty": 3,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "predefined",
    "question": "Quel est le type de 'unique' ?",
    "code": "numbers = [1, 2, 2, 3, 3, 3]\nunique = {x for x in numbers}\nprint(type(unique).__name__)",
    "acceptedAnswers": ["set"],
    "explanation": "Ligne 1 : numbers = [1, 2, 2, 3, 3, 3]\n• Liste avec doublons\n\nLigne 2 : {x for x in numbers} est une SET COMPREHENSION\n• Les accolades {} indiquent un set (pas une liste)\n• Syntaxe similaire à list comprehension [x for x in numbers]\n• Différence : un set élimine automatiquement les doublons\n\nConstruction du set :\n• 1 est ajouté → {1}\n• 2 est ajouté → {1, 2}\n• 2 est déjà présent → {1, 2} (ignoré)\n• 3 est ajouté → {1, 2, 3}\n• 3 est déjà présent → {1, 2, 3} (ignoré)\n• 3 est déjà présent → {1, 2, 3} (ignoré)\n\nRésultat : unique = {1, 2, 3} (type: set)\n\nLigne 3 : type(unique).__name__ retourne 'set'\n\nRemarque sur les comprehensions :\n• [...] → list\n• {...} → set (ou dict si key:value)\n• (...) → generator\n\nLes sets sont non ordonnés et n'acceptent pas les doublons",
    "highlightedLines": [2],
    "xpGain": 30,
    "tags": ["sets", "comprehensions", "types", "duplicates"]
  }
]

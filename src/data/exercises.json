[
  {
    "id": "py_easy_001",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "shopping_cart = ['pain', 'lait', '≈ìufs']\nshopping_cart.append('fromage')\ntotal_items = len(shopping_cart)\nprint(total_items)",
    "options": ["3", "4", "5", "Error"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : On cr√©e une liste shopping_cart avec 3 items initiaux\n\nLigne 2 : append('fromage') ajoute un nouvel √©l√©ment ‚Üí maintenant 4 items au total\n\nLigne 3 : len(shopping_cart) compte tous les √©l√©ments ‚Üí retourne 4\n\nLigne 4 : print() affiche le r√©sultat : 4",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["lists", "methods", "len"]
  },
  {
    "id": "py_easy_002",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "user_score = 0\nfor level in range(3):\n    user_score += 10\nprint(user_score)",
    "options": ["10", "30", "3", "0"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : user_score d√©marre √† 0\n\nLigne 2 : range(3) g√©n√®re [0, 1, 2] ‚Üí la boucle s'ex√©cute 3 fois\n\nLigne 3 : √Ä chaque it√©ration, on ajoute 10 au score\n‚Ä¢ 1√®re fois : 0 + 10 = 10\n‚Ä¢ 2√®me fois : 10 + 10 = 20\n‚Ä¢ 3√®me fois : 20 + 10 = 30\n\nLigne 4 : print() affiche le score final : 30",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["loops", "range", "arithmetic"]
  },
  {
    "id": "py_easy_003",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "employee_name = 'Alice'\nwelcome_message = 'Bonjour ' + employee_name\nprint(len(welcome_message))",
    "options": ["5", "8", "13", "14"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : employee_name stocke 'Alice' (5 caract√®res)\n\nLigne 2 : Concat√©nation de cha√Ænes\n‚Ä¢ 'Bonjour ' = 8 caract√®res (avec l'espace)\n‚Ä¢ + 'Alice' = 5 caract√®res\n‚Ä¢ R√©sultat : 'Bonjour Alice' = 13 caract√®res total\n\nLigne 3 : len() compte tous les caract√®res ‚Üí retourne 13",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["strings", "concatenation", "len"]
  },
  {
    "id": "py_easy_004",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "temperature = 15\nif temperature > 20:\n    comfort_level = 'chaud'\nelse:\n    comfort_level = 'froid'\nprint(comfort_level)",
    "options": ["chaud", "froid", "15", "Error"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : temperature vaut 15\n\nLigne 2 : Condition if temperature > 20\n‚Ä¢ 15 > 20 est False\n‚Ä¢ Donc on saute le bloc if (ligne 3)\n\nLigne 4-5 : On ex√©cute le bloc else\n‚Ä¢ comfort_level = 'froid'\n\nLigne 6 : print() affiche 'froid'",
    "highlightedLines": [2, 5],
    "xpGain": 10,
    "tags": ["conditions", "if-else", "comparison"]
  },
  {
    "id": "py_easy_005",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "inventory = [10, 5, 8]\nfirst_item = inventory[0]\nlast_item = inventory[-1]\nresult = first_item + last_item\nprint(result)",
    "options": ["13", "18", "15", "23"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : inventory contient [10, 5, 8]\n\nLigne 2 : inventory[0] r√©cup√®re le premier √©l√©ment ‚Üí 10\n\nLigne 3 : inventory[-1] r√©cup√®re le dernier √©l√©ment ‚Üí 8\n\nLigne 4 : Addition 10 + 8 = 18\n\nLigne 5 : print() affiche 18",
    "highlightedLines": [2, 3, 4],
    "xpGain": 10,
    "tags": ["lists", "indexing", "arithmetic"]
  },
  {
    "id": "py_easy_006",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "price = 50\ndiscount = 10\nfinal_price = price - discount\nprint(final_price)",
    "acceptedAnswers": ["40", "40.0"],
    "explanation": "Ligne 1 : price vaut 50\n\nLigne 2 : discount vaut 10\n\nLigne 3 : Soustraction 50 - 10 = 40\n\nLigne 4 : print() affiche 40",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "subtraction"]
  },
  {
    "id": "py_easy_007",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [2, 4, 6, 8]\ntotal = 0\nfor num in numbers:\n    total += num\nprint(total)",
    "acceptedAnswers": ["20", "20.0"],
    "explanation": "Ligne 2 : total d√©marre √† 0\n\nLigne 3-4 : Boucle qui additionne tous les nombres\n‚Ä¢ 0 + 2 = 2\n‚Ä¢ 2 + 4 = 6\n‚Ä¢ 6 + 6 = 12\n‚Ä¢ 12 + 8 = 20\n\nLigne 5 : print() affiche 20",
    "highlightedLines": [3, 4],
    "xpGain": 10,
    "tags": ["loops", "arithmetic", "sum"]
  },
  {
    "id": "py_easy_008",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nsubstring = text[0:3]\nprint(substring)",
    "options": ["Pyt", "Pyth", "Python", "hon"],
    "correctAnswer": 0,
    "explanation": "Ligne 1 : text contient 'Python'\n\nLigne 2 : Slicing text[0:3]\n‚Ä¢ Commence √† l'index 0 (inclus) : 'P'\n‚Ä¢ S'arr√™te √† l'index 3 (exclus) : jusqu'√† 't'\n‚Ä¢ R√©sultat : 'Pyt'\n\nLigne 3 : print() affiche 'Pyt'",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["strings", "slicing", "indexing"]
  },
  {
    "id": "py_easy_009",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "counter = 5\nwhile counter > 0:\n    counter -= 2\nprint(counter)",
    "acceptedAnswers": ["-1", "-1.0"],
    "explanation": "Ligne 1 : counter d√©marre √† 5\n\nLigne 2-3 : Boucle while tant que counter > 0\n‚Ä¢ It√©ration 1 : counter = 5 - 2 = 3 (encore > 0)\n‚Ä¢ It√©ration 2 : counter = 3 - 2 = 1 (encore > 0)\n‚Ä¢ It√©ration 3 : counter = 1 - 2 = -1 (plus > 0, on sort)\n\nLigne 4 : print() affiche -1",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["while", "loops", "counter"]
  },
  {
    "id": "py_easy_010",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [1, 2, 3, 4, 5]\nresult = numbers[2] * 2\nprint(result)",
    "options": ["4", "6", "8", "10"],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : numbers contient [1, 2, 3, 4, 5]\n\nLigne 2 : numbers[2] acc√®de au 3√®me √©l√©ment (index 2) ‚Üí 3\n‚Ä¢ Puis multiplication par 2 : 3 * 2 = 6\n\nLigne 3 : print() affiche 6",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "indexing", "arithmetic"]
  },
  {
    "id": "py_easy_011",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "age = 25\nname = 'Marc'\nprint('Tu as', age, 'ans)\nprint('Bonjour', name)",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 3,
    "explanation": "Ligne 3 : Erreur de syntaxe - guillemet fermant manquant\n\nLa cha√Æne commence par un guillemet simple ' mais ne se termine pas avant la parenth√®se.\n\nCorrection : print('Tu as', age, 'ans')",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["syntax", "strings", "quotes"]
  },
  {
    "id": "py_easy_012",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de x ?",
    "code": "x = 10\nx = x + 5\nx = x * 2\nprint(x)",
    "acceptedAnswers": ["30", "30.0"],
    "explanation": "Ligne 1 : x = 10\n\nLigne 2 : x = 10 + 5 = 15\n\nLigne 3 : x = 15 * 2 = 30\n\nLigne 4 : print() affiche 30",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "assignment"]
  },
  {
    "id": "py_easy_013",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "fruits = ['pomme', 'banane', 'orange']\nfor fruit in fruits:\n    print(fruit.upper())",
    "options": [
      "Affiche chaque fruit en minuscules",
      "Affiche chaque fruit en majuscules",
      "Compte le nombre de fruits",
      "Trie les fruits par ordre alphab√©tique"
    ],
    "correctAnswer": 1,
    "explanation": "La m√©thode .upper() convertit une cha√Æne en MAJUSCULES.\n\nLa boucle for parcourt chaque √©l√©ment de la liste fruits et affiche sa version en majuscules :\n‚Ä¢ POMME\n‚Ä¢ BANANE\n‚Ä¢ ORANGE",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["strings", "methods", "loops"]
  },
  {
    "id": "py_easy_014",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "numbers = [1, 2, 3]\nfor i in range(3):\n  result = numbers[i] * 2\n    print(result)",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 4,
    "explanation": "Ligne 4 : Erreur d'indentation\n\nLe print() a une indentation incorrecte (4 espaces au lieu de 2). En Python, tous les statements dans un m√™me bloc doivent avoir la m√™me indentation.\n\nCorrection : aligner print(result) avec result = ...",
    "highlightedLines": [4],
    "xpGain": 10,
    "tags": ["syntax", "indentation", "loops"]
  },
  {
    "id": "py_easy_015",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "a = 7\nb = 3\nresult = a // b\nprint(result)",
    "acceptedAnswers": ["2", "2.0"],
    "explanation": "Ligne 3 : L'op√©rateur // est la division enti√®re (floor division)\n\n7 // 3 donne le quotient entier sans la partie d√©cimale :\n‚Ä¢ 7 / 3 = 2.333...\n‚Ä¢ 7 // 3 = 2 (partie enti√®re seulement)\n\nLigne 4 : print() affiche 2",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["arithmetic", "operators", "division"]
  },
  {
    "id": "py_easy_016",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "message = 'Bonjour'\nif len(message) > 5:\n    print('Message long')\nelse:\n    print('Message court')",
    "options": [
      "Affiche 'Message long'",
      "Affiche 'Message court'",
      "Compte les lettres",
      "Affiche le message"
    ],
    "correctAnswer": 0,
    "explanation": "Ligne 1 : message = 'Bonjour' (7 caract√®res)\n\nLigne 2 : len(message) retourne 7, et 7 > 5 est True\n\nDonc le programme ex√©cute le bloc if et affiche 'Message long'",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["strings", "len", "conditions"]
  },
  {
    "id": "py_easy_017",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de count ?",
    "code": "count = 0\nfor i in range(5):\n    count += 1\nprint(count)",
    "acceptedAnswers": ["5", "5.0"],
    "explanation": "Ligne 1 : count d√©marre √† 0\n\nLigne 2 : range(5) g√©n√®re [0, 1, 2, 3, 4] ‚Üí 5 it√©rations\n\nLigne 3 : √Ä chaque it√©ration, count augmente de 1\n‚Ä¢ count = 1, 2, 3, 4, 5\n\nLigne 4 : print() affiche 5",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["loops", "counter", "range"]
  },
  {
    "id": "py_easy_018",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "name = 'Alice'\nage = 30\nresultat = name + age\nprint(resultat)",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 3,
    "explanation": "Ligne 3 : TypeError - Impossible de concat√©ner str + int\n\nPython ne peut pas additionner directement une cha√Æne ('Alice') avec un nombre (30).\n\nCorrection : resultat = name + str(age) ou utiliser f-string",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["types", "strings", "concatenation", "errors"]
  },
  {
    "id": "py_easy_019",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [10, 20, 30]\nnumbers.pop()\nprint(len(numbers))",
    "options": ["0", "1", "2", "3"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : numbers contient 3 √©l√©ments [10, 20, 30]\n\nLigne 2 : pop() supprime et retourne le dernier √©l√©ment (30)\n‚Ä¢ numbers devient [10, 20] ‚Üí 2 √©l√©ments\n\nLigne 3 : len(numbers) retourne 2",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "methods", "pop", "len"]
  },
  {
    "id": "py_easy_020",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de total ?",
    "code": "total = 100\ntotal -= 20\ntotal *= 2\nprint(total)",
    "acceptedAnswers": ["160", "160.0"],
    "explanation": "Ligne 1 : total = 100\n\nLigne 2 : total -= 20 ‚Üí total = 100 - 20 = 80\n\nLigne 3 : total *= 2 ‚Üí total = 80 * 2 = 160\n\nLigne 4 : print() affiche 160",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "operators"]
  },
  {
    "id": "py_easy_021",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait cette fonction ?",
    "code": "def double(x):\n    return x * 2\n\nresult = double(5)\nprint(result)",
    "options": [
      "Affiche 5",
      "Affiche 10",
      "Affiche 25",
      "Provoque une erreur"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1-2 : La fonction double() prend un param√®tre x et retourne x * 2\n\nLigne 4 : double(5) appelle la fonction avec x = 5\n‚Ä¢ Retourne 5 * 2 = 10\n\nLigne 5 : print() affiche 10",
    "highlightedLines": [2, 4],
    "xpGain": 10,
    "tags": ["functions", "parameters", "return"]
  },
  {
    "id": "py_easy_022",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "colors = ['rouge', 'vert', 'bleu']\nprint(colors[3])\nprint('Couleur trouv√©e')",
    "clickableLines": [1, 2, 3],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : IndexError - list index out of range\n\nLa liste colors a 3 √©l√©ments aux index 0, 1, 2.\nL'index 3 n'existe pas !\n\nCorrection : utiliser colors[0], colors[1] ou colors[2]",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "indexing", "errors", "range"]
  },
  {
    "id": "py_easy_023",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "x = 12\ny = 5\nresult = x % y\nprint(result)",
    "acceptedAnswers": ["2", "2.0"],
    "explanation": "Ligne 3 : L'op√©rateur % calcule le reste de la division (modulo)\n\n12 % 5 :\n‚Ä¢ 12 / 5 = 2 avec un reste de 2\n‚Ä¢ 5 * 2 = 10, il reste 12 - 10 = 2\n\nLigne 4 : print() affiche 2",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["arithmetic", "operators", "modulo"]
  },
  {
    "id": "py_easy_024",
    "language": "python",
    "difficulty": 1,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "numbers = [5, 2, 8, 1, 9]\nnumbers.sort()\nprint(numbers[0])",
    "options": [
      "Affiche le plus grand nombre",
      "Affiche le plus petit nombre",
      "Affiche le premier nombre",
      "Affiche la longueur de la liste"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 2 : sort() trie la liste par ordre croissant\n‚Ä¢ numbers devient [1, 2, 5, 8, 9]\n\nLigne 3 : numbers[0] acc√®de au premier √©l√©ment apr√®s le tri\n‚Ä¢ Premier √©l√©ment = plus petit nombre = 1",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["lists", "methods", "sort", "indexing"]
  },
  {
    "id": "py_easy_025",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "def greet(name):\n    print('Bonjour', nom)\n\ngreet('Alice')",
    "clickableLines": [1, 2, 3, 4],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : NameError - variable 'nom' non d√©finie\n\nLe param√®tre de la fonction s'appelle 'name', pas 'nom'.\n\nCorrection : print('Bonjour', name)",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["functions", "variables", "errors", "scope"]
  },
  {
    "id": "py_easy_026",
    "language": "python",
    "difficulty": 1,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de n ?",
    "code": "n = 3\nn = n ** 2\nn = n + 1\nprint(n)",
    "acceptedAnswers": ["10", "10.0"],
    "explanation": "Ligne 1 : n = 3\n\nLigne 2 : n = 3 ** 2 (3 puissance 2) = 9\n\nLigne 3 : n = 9 + 1 = 10\n\nLigne 4 : print() affiche 10",
    "highlightedLines": [2, 3],
    "xpGain": 10,
    "tags": ["variables", "arithmetic", "power"]
  },
  {
    "id": "py_easy_027",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nprint(text[-1])",
    "options": ["P", "y", "n", "h"],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : text = 'Python'\n\nLigne 2 : text[-1] acc√®de au dernier caract√®re avec un index n√©gatif\n‚Ä¢ Index -1 = dernier √©l√©ment = 'n'\n\nprint() affiche 'n'",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["strings", "indexing", "negative_index"]
  },
  {
    "id": "py_easy_028",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "score = 85\nif score >= 50\n    print('R√©ussi')\nelse:\n    print('√âchou√©')",
    "clickableLines": [1, 2, 3, 4, 5],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : Erreur de syntaxe - deux-points manquants\n\nEn Python, toute instruction if doit se terminer par :\n\nCorrection : if score >= 50:",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["syntax", "conditions", "if"]
  },
  {
    "id": "py_easy_029",
    "language": "python",
    "difficulty": 1,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [2, 4, 6]\nresult = sum(numbers)\nprint(result)",
    "acceptedAnswers": ["12", "12.0"],
    "explanation": "Ligne 1 : numbers = [2, 4, 6]\n\nLigne 2 : sum() additionne tous les √©l√©ments de la liste\n‚Ä¢ 2 + 4 + 6 = 12\n\nLigne 3 : print() affiche 12",
    "highlightedLines": [2],
    "xpGain": 10,
    "tags": ["lists", "sum", "functions"]
  },
  {
    "id": "py_easy_030",
    "language": "python",
    "difficulty": 1,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur ?",
    "code": "numbers = [1, 2, 3]\ntotal = 0\nfor num in numbers\n    total += num\nprint(total)",
    "clickableLines": [1, 2, 3, 4, 5],
    "correctAnswer": 3,
    "explanation": "Ligne 3 : Erreur de syntaxe - deux-points manquants\n\nToute boucle for doit se terminer par :\n\nCorrection : for num in numbers:",
    "highlightedLines": [3],
    "xpGain": 10,
    "tags": ["syntax", "loops", "for"]
  },
  {
    "id": "py_medium_001",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def multiplier(x):\n    return lambda y: x * y\n\ndouble = multiplier(2)\nresult = double(5)\nprint(result)",
    "options": ["2", "5", "10", "Error"],
    "correctAnswer": 2,
    "explanation": "‚ö†Ô∏è PI√àGE : Ce code utilise une closure (lambda qui capture x)\n\nLigne 1-2 : multiplier(x) retourne une fonction lambda qui multiplie par x\n\nLigne 4 : double = multiplier(2) cr√©e une fonction qui multiplie par 2\n\nLigne 5 : double(5) ex√©cute la lambda avec y=5\n‚Ä¢ La lambda retourne x * y = 2 * 5 = 10\n\nLigne 6 : print() affiche 10\n\nüí° Solution pi√©geuse : On pourrait penser que c'est 2 (valeur de x) ou 5 (valeur de y), mais c'est bien leur multiplication.",
    "highlightedLines": [2, 4, 5],
    "xpGain": 20,
    "tags": ["functions", "lambda", "closures"]
  },
  {
    "id": "py_medium_002",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [1, 2, 3, 4, 5]\nresult = [x * 2 for x in numbers if x % 2 == 0]\nprint(len(result))",
    "options": ["2", "5", "10", "4"],
    "correctAnswer": 0,
    "explanation": "‚ö†Ô∏è PI√àGE : La list comprehension filtre ET transforme les √©l√©ments\n\nLigne 1 : numbers = [1, 2, 3, 4, 5]\n\nLigne 2 : List comprehension avec condition\n‚Ä¢ if x % 2 == 0 : garde seulement les pairs (2, 4)\n‚Ä¢ x * 2 : multiplie par 2\n‚Ä¢ result = [2*2, 4*2] = [4, 8]\n\nLigne 3 : len([4, 8]) = 2\n\nüí° Solution pi√©geuse : On pourrait compter tous les √©l√©ments (5) ou penser au r√©sultat doubl√© (10), mais on ne garde que les pairs avant de doubler.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["list-comprehension", "filter", "modulo"]
  },
  {
    "id": "py_medium_003",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de x ?",
    "code": "x = 5\ndef modifier():\n    x = 10\n    return x\n\nmodifier()\nprint(x)",
    "acceptedAnswers": ["5", "5.0"],
    "explanation": "‚ö†Ô∏è PI√àGE : Scope des variables (local vs global)\n\nLigne 1 : x = 5 (variable GLOBALE)\n\nLigne 2-4 : Fonction modifier() qui cr√©e une variable x LOCALE = 10\n‚Ä¢ Cette variable locale x n'affecte PAS la variable globale x\n‚Ä¢ Elle existe seulement dans la fonction\n\nLigne 6 : modifier() s'ex√©cute mais ne modifie pas x global\n\nLigne 7 : print(x) affiche la variable GLOBALE x = 5\n\nüí° Solution pi√©geuse : On pourrait penser que x devient 10, mais sans le mot-cl√© 'global', la fonction cr√©e une nouvelle variable locale qui n'affecte pas x global.",
    "highlightedLines": [2, 3],
    "xpGain": 20,
    "tags": ["scope", "functions", "variables"]
  },
  {
    "id": "py_medium_004",
    "language": "python",
    "difficulty": 2,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur logique ?",
    "code": "def calculer_moyenne(notes):\n    total = sum(notes)\n    moyenne = total / len(notes)\n    return round(moyenne)\n\nresultat = calculer_moyenne([])\nprint(resultat)",
    "clickableLines": [1, 2, 3, 4, 5, 6, 7],
    "correctAnswer": 6,
    "explanation": "‚ö†Ô∏è PI√àGE : Division par z√©ro avec liste vide\n\nLigne 6 : calculer_moyenne([]) appelle la fonction avec une liste vide\n\nDans la fonction :\n‚Ä¢ total = sum([]) = 0\n‚Ä¢ moyenne = 0 / len([]) = 0 / 0 ‚Üí ZeroDivisionError\n\nErreur : On ne v√©rifie pas si la liste est vide avant de diviser\n\nüí° Correction :\ndef calculer_moyenne(notes):\n    if len(notes) == 0:\n        return 0\n    total = sum(notes)\n    moyenne = total / len(notes)\n    return round(moyenne)",
    "highlightedLines": [6],
    "xpGain": 20,
    "tags": ["functions", "errors", "edge-cases"]
  },
  {
    "id": "py_medium_005",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nresult = text[1:4]\nprint(result)",
    "options": ["Pyt", "yth", "ytho", "tho"],
    "correctAnswer": 1,
    "explanation": "‚ö†Ô∏è PI√àGE : Le slicing exclut l'index de fin\n\nLigne 1 : text = 'Python'\n‚Ä¢ Indices : P=0, y=1, t=2, h=3, o=4, n=5\n\nLigne 2 : text[1:4] extrait depuis l'index 1 INCLUS jusqu'√† 4 EXCLU\n‚Ä¢ Index 1 : 'y'\n‚Ä¢ Index 2 : 't'\n‚Ä¢ Index 3 : 'h'\n‚Ä¢ Index 4 : EXCLU\n‚Ä¢ result = 'yth'\n\nLigne 3 : print() affiche 'yth'\n\nüí° Solution pi√©geuse : On pourrait penser que [1:4] inclut l'index 4, mais Python exclut toujours la borne sup√©rieure dans le slicing.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["strings", "slicing", "indexing"]
  },
  {
    "id": "py_medium_006",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "data = {'a': 1, 'b': 2}\ndata['c'] = data.get('a', 0) + data.get('d', 0)\nprint(data['c'])",
    "options": ["0", "1", "2", "3"],
    "correctAnswer": 1,
    "explanation": "‚ö†Ô∏è PI√àGE : La m√©thode .get() avec valeur par d√©faut\n\nLigne 1 : data = {'a': 1, 'b': 2}\n\nLigne 2 : Calcul de data['c']\n‚Ä¢ data.get('a', 0) : cl√© 'a' existe ‚Üí retourne 1\n‚Ä¢ data.get('d', 0) : cl√© 'd' n'existe PAS ‚Üí retourne la valeur par d√©faut 0\n‚Ä¢ data['c'] = 1 + 0 = 1\n\nLigne 3 : print(data['c']) affiche 1\n\nüí° Solution pi√©geuse : On pourrait penser que .get('d', 0) g√©n√®re une erreur, mais c'est justement l'int√©r√™t de .get() : retourner une valeur par d√©faut si la cl√© n'existe pas.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["dictionaries", "get", "methods"]
  },
  {
    "id": "py_medium_007",
    "language": "python",
    "difficulty": 2,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "def factorielle(n):\n    if n <= 1:\n        return 1\n    return n * factorielle(n - 1)\n\nresult = factorielle(5)",
    "options": [
      "Calcule 5 + 4 + 3 + 2 + 1",
      "Calcule 5 * 4 * 3 * 2 * 1",
      "Calcule 5^4",
      "G√©n√®re une erreur (r√©cursion infinie)"
    ],
    "correctAnswer": 1,
    "explanation": "‚ö†Ô∏è PI√àGE : Reconna√Ætre une fonction r√©cursive\n\nCe code calcule la factorielle de n de mani√®re r√©cursive\n\nEx√©cution pour factorielle(5) :\n‚Ä¢ factorielle(5) = 5 * factorielle(4)\n‚Ä¢ factorielle(4) = 4 * factorielle(3)\n‚Ä¢ factorielle(3) = 3 * factorielle(2)\n‚Ä¢ factorielle(2) = 2 * factorielle(1)\n‚Ä¢ factorielle(1) = 1 (cas de base)\n\nR√©sultat : 5 * 4 * 3 * 2 * 1 = 120\n\nüí° Solution pi√©geuse : La r√©cursion peut sembler g√©n√©rer une erreur, mais le cas de base (n <= 1) arr√™te bien la r√©cursion.",
    "highlightedLines": [2, 3, 4],
    "xpGain": 20,
    "tags": ["recursion", "functions", "factorielle"]
  },
  {
    "id": "py_medium_008",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Combien d'it√©rations la boucle effectue-t-elle ?",
    "code": "count = 0\nfor i in range(2, 10, 3):\n    count += 1\nprint(count)",
    "acceptedAnswers": ["3", "3.0"],
    "explanation": "‚ö†Ô∏è PI√àGE : range(start, stop, step) avec pas personnalis√©\n\nLigne 2 : range(2, 10, 3) g√©n√®re une s√©quence avec :\n‚Ä¢ D√©part : 2\n‚Ä¢ Fin : 10 (EXCLU)\n‚Ä¢ Pas : 3\n\nValeurs g√©n√©r√©es :\n‚Ä¢ i = 2 (2 < 10) ‚Üí count = 1\n‚Ä¢ i = 5 (2+3, 5 < 10) ‚Üí count = 2\n‚Ä¢ i = 8 (5+3, 8 < 10) ‚Üí count = 3\n‚Ä¢ i = 11 (8+3, 11 >= 10) ‚Üí STOP\n\nLa boucle s'ex√©cute 3 fois\n\nüí° Solution pi√©geuse : On pourrait calculer (10-2)/3 = 2.67 et arrondir √† 2, mais il faut compter pr√©cis√©ment les valeurs < 10.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["range", "loops", "step"]
  },
  {
    "id": "py_medium_009",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def modifier_liste(lst):\n    lst.append(4)\n    return lst\n\noriginal = [1, 2, 3]\nnouvelle = modifier_liste(original)\nprint(len(original))",
    "options": ["3", "4", "7", "Error"],
    "correctAnswer": 1,
    "explanation": "‚ö†Ô∏è PI√àGE : Les listes sont mutables et pass√©es par r√©f√©rence\n\nLigne 4 : original = [1, 2, 3]\n\nLigne 5 : modifier_liste(original) re√ßoit une R√âF√âRENCE √† original\n‚Ä¢ lst pointe vers la M√äME liste que original\n‚Ä¢ lst.append(4) modifie directement original\n‚Ä¢ original devient [1, 2, 3, 4]\n\nLigne 6 : print(len(original)) affiche 4\n\nüí° Solution pi√©geuse : On pourrait penser que original reste [1, 2, 3] car on cr√©e 'nouvelle', mais en Python les listes sont mutables et pass√©es par r√©f√©rence. Pour √©viter cela, il faudrait utiliser lst = lst.copy() ou lst = lst[:].",
    "highlightedLines": [2, 5],
    "xpGain": 20,
    "tags": ["lists", "mutability", "references"]
  },
  {
    "id": "py_medium_010",
    "language": "python",
    "difficulty": 2,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "predefined",
    "question": "Quel est le type de 'result' ?",
    "code": "values = [1, 2, 3]\nresult = map(lambda x: x ** 2, values)\nprint(type(result).__name__)",
    "acceptedAnswers": ["map"],
    "explanation": "‚ö†Ô∏è PI√àGE : map() retourne un objet map, pas une liste\n\nLigne 1 : values = [1, 2, 3]\n\nLigne 2 : map(lambda x: x ** 2, values)\n‚Ä¢ map() applique la fonction lambda √† chaque √©l√©ment\n‚Ä¢ MAIS map() retourne un OBJET MAP (it√©rateur), pas une liste\n‚Ä¢ Pour obtenir une liste, il faudrait : list(map(...))\n\nLigne 3 : type(result).__name__ retourne 'map'\n\nüí° Solution pi√©geuse : On pourrait penser que result est une liste [1, 4, 9], mais map() retourne un it√©rateur pour optimiser la m√©moire. Il faut explicitement convertir en list() pour obtenir les valeurs.",
    "highlightedLines": [2],
    "xpGain": 20,
    "tags": ["map", "lambda", "types", "iterators"]
  },
  {
    "id": "py_hard_001",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "class Compteur:\n    count = 0\n    def __init__(self):\n        Compteur.count += 1\n\na = Compteur()\nb = Compteur()\nc = Compteur()\nprint(Compteur.count)",
    "options": ["0", "1", "3", "Error"],
    "correctAnswer": 2,
    "explanation": "‚ö†Ô∏è PI√àGE : Variable de classe vs variable d'instance\n\nLigne 2 : count = 0 est une VARIABLE DE CLASSE (partag√©e par toutes les instances)\n\nLigne 3-4 : √Ä chaque cr√©ation d'instance, __init__() incr√©mente Compteur.count\n‚Ä¢ a = Compteur() ‚Üí Compteur.count = 1\n‚Ä¢ b = Compteur() ‚Üí Compteur.count = 2\n‚Ä¢ c = Compteur() ‚Üí Compteur.count = 3\n\nLigne 9 : print(Compteur.count) affiche 3\n\nüí° Solution pi√©geuse : On pourrait penser que chaque instance a son propre count = 1, mais count est une variable de CLASSE donc partag√©e entre toutes les instances. C'est diff√©rent de self.count qui serait une variable d'instance.",
    "highlightedLines": [2, 4],
    "xpGain": 30,
    "tags": ["classes", "class-variables", "instances"]
  },
  {
    "id": "py_hard_002",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def generateur():\n    for i in range(3):\n        yield i * 2\n\ng = generateur()\nprint(next(g) + next(g))",
    "options": ["0", "2", "4", "6"],
    "correctAnswer": 1,
    "explanation": "‚ö†Ô∏è PI√àGE : Les g√©n√©rateurs maintiennent leur √©tat entre les appels next()\n\nLigne 1-3 : generateur() est une fonction g√©n√©ratrice (yield)\n\nLigne 5 : g = generateur() cr√©e un g√©n√©rateur (ne l'ex√©cute pas encore)\n\nLigne 6 : Deux appels √† next(g)\n‚Ä¢ Premier next(g) :\n  - i = 0, yield 0 * 2 = 0\n  - La fonction se met en pause\n‚Ä¢ Deuxi√®me next(g) :\n  - Reprend o√π elle s'√©tait arr√™t√©e\n  - i = 1, yield 1 * 2 = 2\n‚Ä¢ Calcul : 0 + 2 = 2\n\nüí° Solution pi√©geuse : On pourrait penser que next(g) retourne toujours 0 (r√©initialise), ou que le r√©sultat est 0+4=4 (skip une valeur), mais le g√©n√©rateur maintient son √©tat et retourne les valeurs successivement.",
    "highlightedLines": [3, 6],
    "xpGain": 30,
    "tags": ["generators", "yield", "next"]
  },
  {
    "id": "py_hard_003",
    "language": "python",
    "difficulty": 3,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne causera une erreur √† l'ex√©cution ?",
    "code": "def calculer(a, b=5, c):\n    return a + b + c\n\nresult = calculer(1, 2, 3)\nprint(result)",
    "clickableLines": [1, 2, 3, 4, 5],
    "correctAnswer": 1,
    "explanation": "‚ö†Ô∏è PI√àGE : Ordre des param√®tres avec valeurs par d√©faut\n\nLigne 1 : SyntaxError - param√®tre avec d√©faut avant param√®tre sans d√©faut\n\nEn Python, les param√®tres avec valeur par d√©faut doivent venir APR√àS ceux sans d√©faut\n\nErreur : def calculer(a, b=5, c) ‚Üí c n'a pas de d√©faut mais vient apr√®s b qui en a\n\nüí° Corrections possibles :\n‚Ä¢ def calculer(a, c, b=5):\n‚Ä¢ def calculer(a, b=5, c=0):\n‚Ä¢ def calculer(a, b, c):\n\nCette erreur est d√©tect√©e AVANT l'ex√©cution (SyntaxError), pas pendant.",
    "highlightedLines": [1],
    "xpGain": 30,
    "tags": ["functions", "parameters", "defaults", "syntax"]
  },
  {
    "id": "py_hard_004",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de result ?",
    "code": "values = [1, 2, 3, 4, 5]\nresult = sum([x for x in values if x % 2 != 0])\nprint(result)",
    "acceptedAnswers": ["9", "9.0"],
    "explanation": "‚ö†Ô∏è PI√àGE : Combinaison list comprehension + sum + condition modulo\n\nLigne 1 : values = [1, 2, 3, 4, 5]\n\nLigne 2 : List comprehension avec filtrage\n‚Ä¢ if x % 2 != 0 : garde les nombres IMPAIRS\n  - 1 % 2 = 1 (!=0) ‚úì\n  - 2 % 2 = 0 (==0) ‚úó\n  - 3 % 2 = 1 (!=0) ‚úì\n  - 4 % 2 = 0 (==0) ‚úó\n  - 5 % 2 = 1 (!=0) ‚úì\n‚Ä¢ Liste filtr√©e : [1, 3, 5]\n‚Ä¢ sum([1, 3, 5]) = 9\n\nLigne 3 : print() affiche 9\n\nüí° Solution pi√©geuse : Il faut bien comprendre que x % 2 != 0 s√©lectionne les impairs (1, 3, 5), pas les pairs. La somme 1+3+5 = 9.",
    "highlightedLines": [2],
    "xpGain": 30,
    "tags": ["list-comprehension", "sum", "modulo", "filtering"]
  },
  {
    "id": "py_hard_005",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "try:\n    x = int('abc')\nexcept ValueError:\n    x = 0\nexcept:\n    x = -1\nfinally:\n    x += 10\nprint(x)",
    "options": ["-1", "0", "10", "Error"],
    "correctAnswer": 2,
    "explanation": "‚ö†Ô∏è PI√àGE : L'ordre d'ex√©cution try-except-finally et les types d'erreurs\n\nLigne 2 : int('abc') g√©n√®re une ValueError (conversion impossible)\n\nLigne 3-4 : Le bloc except ValueError attrape l'erreur\n‚Ä¢ x = 0\n\nLigne 5-6 : Le bloc except g√©n√©rique N'EST PAS ex√©cut√© (l'erreur est d√©j√† attrap√©e)\n\nLigne 7-8 : Le bloc finally s'ex√©cute TOUJOURS\n‚Ä¢ x += 10 ‚Üí x = 0 + 10 = 10\n\nLigne 9 : print(x) affiche 10\n\nüí° Solution pi√©geuse : On pourrait penser que x reste √† 0, mais finally s'ex√©cute TOUJOURS apr√®s un try-except, m√™me si une erreur a √©t√© attrap√©e. C'est utilis√© pour nettoyer les ressources (fermer fichiers, connexions, etc.).",
    "highlightedLines": [3, 4, 7, 8],
    "xpGain": 30,
    "tags": ["exceptions", "try-except", "finally", "error-handling"]
  },
  {
    "id": "py_hard_006",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "matrix = [[1, 2], [3, 4], [5, 6]]\nresult = [row[1] for row in matrix]\nprint(sum(result))",
    "options": ["6", "9", "12", "21"],
    "correctAnswer": 2,
    "explanation": "‚ö†Ô∏è PI√àGE : List comprehension sur matrice 2D avec indexation\n\nLigne 1 : matrix = [[1, 2], [3, 4], [5, 6]]\n‚Ä¢ 3 lignes, 2 colonnes chacune\n\nLigne 2 : [row[1] for row in matrix] extrait la 2e colonne\n‚Ä¢ row = [1, 2] ‚Üí row[1] = 2\n‚Ä¢ row = [3, 4] ‚Üí row[1] = 4\n‚Ä¢ row = [5, 6] ‚Üí row[1] = 6\n‚Ä¢ result = [2, 4, 6]\n\nLigne 3 : sum([2, 4, 6]) = 12\n\nüí° Solution pi√©geuse : On pourrait penser qu'on additionne toute la matrice (1+2+3+4+5+6=21), ou seulement la premi√®re ligne (1+2=3), mais on extrait sp√©cifiquement la 2e colonne (index 1) de chaque ligne.",
    "highlightedLines": [2],
    "xpGain": 30,
    "tags": ["list-comprehension", "2d-lists", "indexing"]
  },
  {
    "id": "py_hard_007",
    "language": "python",
    "difficulty": 3,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce code ?",
    "code": "def decorator(func):\n    def wrapper(*args, **kwargs):\n        print('Avant')\n        result = func(*args, **kwargs)\n        print('Apr√®s')\n        return result\n    return wrapper\n\n@decorator\ndef dire_bonjour(nom):\n    print(f'Bonjour {nom}')",
    "options": [
      "Affiche seulement 'Bonjour {nom}'",
      "Affiche 'Avant', 'Bonjour {nom}', 'Apr√®s'",
      "G√©n√®re une erreur de syntaxe",
      "Remplace dire_bonjour par decorator"
    ],
    "correctAnswer": 1,
    "explanation": "‚ö†Ô∏è PI√àGE : Comprendre les d√©corateurs Python\n\nLe @decorator avant dire_bonjour est √©quivalent √† :\ndire_bonjour = decorator(dire_bonjour)\n\nQuand on appelle dire_bonjour('Alice') :\n1. C'est wrapper() qui s'ex√©cute\n2. wrapper() ex√©cute print('Avant')\n3. wrapper() appelle func() (l'original dire_bonjour)\n4. func() ex√©cute print('Bonjour Alice')\n5. wrapper() ex√©cute print('Apr√®s')\n\nR√©sultat affich√© :\nAvant\nBonjour Alice\nApr√®s\n\nüí° Solution pi√©geuse : Les d√©corateurs permettent d'ajouter du code avant/apr√®s une fonction sans modifier son code. C'est comme une enveloppe autour de la fonction originale.",
    "highlightedLines": [1, 2, 3, 4, 5, 9],
    "xpGain": 30,
    "tags": ["decorators", "functions", "wrappers"]
  },
  {
    "id": "py_hard_008",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Combien de fois 'test' est-il affich√© ?",
    "code": "for i in range(5):\n    if i == 2:\n        continue\n    if i == 4:\n        break\n    print('test')",
    "acceptedAnswers": ["3", "3.0"],
    "explanation": "‚ö†Ô∏è PI√àGE : Combinaison continue et break dans une boucle\n\nD√©roulement d√©taill√© :\n\n‚Ä¢ i = 0 : pas de condition ‚Üí print('test') ‚úì (1√®re fois)\n\n‚Ä¢ i = 1 : pas de condition ‚Üí print('test') ‚úì (2√®me fois)\n\n‚Ä¢ i = 2 : if i == 2 ‚Üí continue (saute le print)\n\n‚Ä¢ i = 3 : pas de condition ‚Üí print('test') ‚úì (3√®me fois)\n\n‚Ä¢ i = 4 : if i == 4 ‚Üí break (sort de la boucle, ne print pas)\n\nTotal : 'test' affich√© 3 fois\n\nüí° Solution pi√©geuse : On pourrait compter 5 (toutes les it√©rations) ou 4 (en oubliant continue), mais il faut bien suivre le flow : continue saute i=2, break sort √† i=4 avant le print.",
    "highlightedLines": [2, 3, 4, 5],
    "xpGain": 30,
    "tags": ["loops", "continue", "break", "control-flow"]
  },
  {
    "id": "py_hard_009",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def mystere(lst=[]):\n    lst.append(1)\n    return lst\n\na = mystere()\nb = mystere()\nprint(len(b))",
    "options": ["1", "2", "0", "Error"],
    "correctAnswer": 1,
    "explanation": "‚ö†Ô∏è PI√àGE CLASSIQUE : Valeur par d√©faut mutable en Python\n\nLa liste [] par d√©faut est cr√©√©e UNE SEULE FOIS √† la d√©finition de la fonction, pas √† chaque appel !\n\nLigne 4 : a = mystere()\n‚Ä¢ lst = [] (liste par d√©faut)\n‚Ä¢ lst.append(1) ‚Üí lst = [1]\n‚Ä¢ return [1]\n\nLigne 5 : b = mystere()\n‚Ä¢ lst = M√äME liste que pr√©c√©demment [1] !\n‚Ä¢ lst.append(1) ‚Üí lst = [1, 1]\n‚Ä¢ return [1, 1]\n\nLigne 6 : len(b) = len([1, 1]) = 2\n\nüí° Solution pi√©geuse : C'est une erreur fr√©quente ! La liste par d√©faut est partag√©e entre tous les appels. Pour √©viter : def mystere(lst=None): if lst is None: lst = []",
    "highlightedLines": [1, 2, 4, 5],
    "xpGain": 30,
    "tags": ["functions", "mutable-defaults", "tricky", "common-mistakes"]
  },
  {
    "id": "py_hard_010",
    "language": "python",
    "difficulty": 3,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "predefined",
    "question": "Quel est le type de 'unique' ?",
    "code": "numbers = [1, 2, 2, 3, 3, 3]\nunique = {x for x in numbers}\nprint(type(unique).__name__)",
    "acceptedAnswers": ["set"],
    "explanation": "‚ö†Ô∏è PI√àGE : Diff√©rence entre list comprehension [...] et set comprehension {...}\n\nLigne 1 : numbers = [1, 2, 2, 3, 3, 3]\n\nLigne 2 : {x for x in numbers} est une SET COMPREHENSION (accolades {})\n‚Ä¢ Comme [x for x in numbers] mais avec {}\n‚Ä¢ Un set √©limine automatiquement les doublons\n‚Ä¢ unique = {1, 2, 3} (type: set)\n\nLigne 3 : type(unique).__name__ retourne 'set'\n\nüí° Solution pi√©geuse :\n‚Ä¢ [...] ‚Üí list\n‚Ä¢ (...) ‚Üí generator (tuple si pas de for)\n‚Ä¢ {...} ‚Üí set (ou dict si key:value)\n\nLes sets sont non ordonn√©s et n'acceptent pas les doublons, parfait pour obtenir les valeurs uniques !",
    "highlightedLines": [2],
    "xpGain": 30,
    "tags": ["sets", "comprehensions", "types", "duplicates"]
  }
]

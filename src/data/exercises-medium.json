[
  {
    "id": "py_medium_001",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def multiplier(x):\n    return lambda y: x * y\n\ndouble = multiplier(2)\nresult = double(5)\nprint(result)",
    "options": [
      "2",
      "5",
      "10",
      "Error"
    ],
    "correctAnswer": 2,
    "explanation": "Ligne 1-2 : La fonction multiplier(x) retourne une fonction lambda qui multiplie par x\n\nLigne 4 : double = multiplier(2) crée une nouvelle fonction\n• Cette fonction lambda garde en mémoire x = 2\n\nLigne 5 : double(5) appelle la lambda avec y = 5\n• La lambda calcule x * y = 2 * 5 = 10\n\nLigne 6 : print() affiche le résultat : 10",
    "highlightedLines": [
      2,
      4,
      5
    ],
    "xpGain": 20,
    "tags": [
      "functions",
      "lambda",
      "closures"
    ]
  },
  {
    "id": "py_medium_002",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "numbers = [1, 2, 3, 4, 5]\nresult = [x * 2 for x in numbers if x % 2 == 0]\nprint(len(result))",
    "options": [
      "2",
      "5",
      "10",
      "4"
    ],
    "correctAnswer": 0,
    "explanation": "Ligne 1 : numbers = [1, 2, 3, 4, 5]\n\nLigne 2 : La list comprehension filtre et transforme\n• if x % 2 == 0 garde seulement les nombres pairs\n• Nombres pairs : 2 et 4\n• x * 2 multiplie chaque nombre par 2\n• result = [2*2, 4*2] = [4, 8]\n\nLigne 3 : len(result) compte les éléments de la liste\n• len([4, 8]) = 2\n\nLe programme affiche 2",
    "highlightedLines": [
      2
    ],
    "xpGain": 20,
    "tags": [
      "list-comprehension",
      "filter",
      "modulo"
    ]
  },
  {
    "id": "py_medium_003",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de x ?",
    "code": "x = 5\ndef modifier():\n    x = 10\n    return x\n\nmodifier()\nprint(x)",
    "acceptedAnswers": [
      "5",
      "5.0"
    ],
    "explanation": "Ligne 1 : x = 5 (variable globale)\n\nLigne 2-4 : La fonction modifier() crée une nouvelle variable x = 10\n• Cette variable x est LOCALE à la fonction\n• Elle est différente du x global\n• Elle n'affecte pas le x global\n\nLigne 6 : modifier() s'exécute\n• Le x local = 10 existe seulement dans la fonction\n• Le x global reste inchangé\n\nLigne 7 : print(x) affiche le x global = 5\n\nPour modifier x global, il faudrait utiliser le mot-clé 'global' dans la fonction",
    "highlightedLines": [
      2,
      3
    ],
    "xpGain": 20,
    "tags": [
      "scope",
      "functions",
      "variables"
    ]
  },
  {
    "id": "py_medium_004",
    "language": "python",
    "difficulty": 2,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne contient une erreur logique ?",
    "code": "def calculer_moyenne(notes):\n    total = sum(notes)\n    moyenne = total / len(notes)\n    return round(moyenne)\n\nresultat = calculer_moyenne([])\nprint(resultat)",
    "clickableLines": [
      1,
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "correctAnswer": 6,
    "explanation": "Ligne 6 : calculer_moyenne([]) appelle la fonction avec une liste vide\n\nDans la fonction :\n• Ligne 2 : total = sum([]) = 0\n• Ligne 3 : moyenne = total / len(notes)\n  - len([]) = 0\n  - moyenne = 0 / 0 → ZeroDivisionError !\n\nErreur : Division par zéro car la liste est vide\n\nCorrection : Vérifier si la liste est vide avant de calculer\n\ndef calculer_moyenne(notes):\n    if len(notes) == 0:\n        return 0\n    total = sum(notes)\n    moyenne = total / len(notes)\n    return round(moyenne)",
    "highlightedLines": [
      6
    ],
    "xpGain": 20,
    "tags": [
      "functions",
      "errors",
      "edge-cases"
    ]
  },
  {
    "id": "py_medium_005",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "text = 'Python'\nresult = text[1:4]\nprint(result)",
    "options": [
      "Pyt",
      "yth",
      "ytho",
      "tho"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : text = 'Python'\n• Les indices sont : P=0, y=1, t=2, h=3, o=4, n=5\n\nLigne 2 : text[1:4] extrait une partie de la chaîne\n• Démarre à l'index 1 (inclus) : 'y'\n• S'arrête à l'index 4 (exclu) : ne prend pas 'o'\n• Extrait les caractères aux indices 1, 2, 3\n• Index 1 : 'y'\n• Index 2 : 't'\n• Index 3 : 'h'\n• result = 'yth'\n\nLigne 3 : print() affiche 'yth'\n\nRemarque : En Python, le slicing [début:fin] inclut début mais exclut fin",
    "highlightedLines": [
      2
    ],
    "xpGain": 20,
    "tags": [
      "strings",
      "slicing",
      "indexing"
    ]
  },
  {
    "id": "py_medium_006",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "data = {'a': 1, 'b': 2}\ndata['c'] = data.get('a', 0) + data.get('d', 0)\nprint(data['c'])",
    "options": [
      "0",
      "1",
      "2",
      "3"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : data = {'a': 1, 'b': 2}\n• Dictionnaire avec 2 clés : 'a' et 'b'\n\nLigne 2 : Calcul de la valeur de data['c']\n• data.get('a', 0) cherche la clé 'a'\n  - La clé existe → retourne 1\n• data.get('d', 0) cherche la clé 'd'\n  - La clé n'existe pas → retourne la valeur par défaut 0\n• data['c'] = 1 + 0 = 1\n\nLigne 3 : print(data['c']) affiche 1\n\nRemarque : .get(clé, défaut) permet d'éviter les erreurs si la clé n'existe pas",
    "highlightedLines": [
      2
    ],
    "xpGain": 20,
    "tags": [
      "dictionaries",
      "get",
      "methods"
    ]
  },
  {
    "id": "py_medium_007",
    "language": "python",
    "difficulty": 2,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce programme ?",
    "code": "def factorielle(n):\n    if n <= 1:\n        return 1\n    return n * factorielle(n - 1)\n\nresult = factorielle(5)",
    "options": [
      "Calcule 5 + 4 + 3 + 2 + 1",
      "Calcule 5 * 4 * 3 * 2 * 1",
      "Calcule 5^4",
      "Génère une erreur (récursion infinie)"
    ],
    "correctAnswer": 1,
    "explanation": "Ce code calcule la factorielle de n de manière récursive\n\nLigne 2-3 : Cas de base\n• Si n <= 1, la fonction retourne 1\n• Cela arrête la récursion\n\nLigne 4 : Cas récursif\n• La fonction s'appelle elle-même avec n-1\n• Multiplie n par le résultat\n\nExécution pour factorielle(5) :\n• factorielle(5) = 5 * factorielle(4)\n• factorielle(4) = 4 * factorielle(3)\n• factorielle(3) = 3 * factorielle(2)\n• factorielle(2) = 2 * factorielle(1)\n• factorielle(1) = 1 (cas de base)\n\nRésultat : 5 * 4 * 3 * 2 * 1 = 120\n\nLe programme calcule donc 5 * 4 * 3 * 2 * 1",
    "highlightedLines": [
      2,
      3,
      4
    ],
    "xpGain": 20,
    "tags": [
      "recursion",
      "functions",
      "factorielle"
    ]
  },
  {
    "id": "py_medium_008",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Combien d'itérations la boucle effectue-t-elle ?",
    "code": "count = 0\nfor i in range(2, 10, 3):\n    count += 1\nprint(count)",
    "acceptedAnswers": [
      "3",
      "3.0"
    ],
    "explanation": "Ligne 1 : count = 0\n\nLigne 2 : range(2, 10, 3) génère une séquence\n• Départ : 2\n• Fin : 10 (exclu)\n• Pas : 3 (on avance de 3 en 3)\n\nValeurs générées par range :\n• i = 2 → count = 1\n• i = 5 (2+3) → count = 2\n• i = 8 (5+3) → count = 3\n• i = 11 (8+3) → trop grand (11 >= 10), la boucle s'arrête\n\nLigne 4 : print(count) affiche 3\n\nLa boucle s'exécute 3 fois",
    "highlightedLines": [
      2
    ],
    "xpGain": 20,
    "tags": [
      "range",
      "loops",
      "step"
    ]
  },
  {
    "id": "py_medium_009",
    "language": "python",
    "difficulty": 2,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def modifier_liste(lst):\n    lst.append(4)\n    return lst\n\noriginal = [1, 2, 3]\nnouvelle = modifier_liste(original)\nprint(len(original))",
    "options": [
      "3",
      "4",
      "7",
      "Error"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1-3 : La fonction modifier_liste prend une liste en paramètre\n• Ligne 2 : Ajoute 4 à la liste\n• Ligne 3 : Retourne la liste modifiée\n\nLigne 5 : original = [1, 2, 3]\n\nLigne 6 : modifier_liste(original)\n• En Python, les listes sont passées par référence\n• lst dans la fonction pointe vers la même liste que original\n• lst.append(4) modifie directement original\n• original devient [1, 2, 3, 4]\n\nLigne 7 : print(len(original)) affiche 4\n\nRemarque : La liste original a été modifiée par la fonction car les listes sont mutables",
    "highlightedLines": [
      2,
      5
    ],
    "xpGain": 20,
    "tags": [
      "lists",
      "mutability",
      "references"
    ]
  },
  {
    "id": "py_medium_010",
    "language": "python",
    "difficulty": 2,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "predefined",
    "question": "Quel est le type de 'result' ?",
    "code": "values = [1, 2, 3]\nresult = map(lambda x: x ** 2, values)\nprint(type(result).__name__)",
    "acceptedAnswers": [
      "map"
    ],
    "explanation": "Ligne 1 : values = [1, 2, 3]\n\nLigne 2 : map(lambda x: x ** 2, values)\n• map() applique la fonction lambda à chaque élément\n• lambda x: x ** 2 calcule le carré de x\n• map() retourne un objet map (itérateur), pas une liste directement\n• Pour obtenir une liste, il faudrait écrire : list(map(...))\n\nLigne 3 : type(result).__name__ retourne le nom du type\n• result est de type 'map'\n\nLe programme affiche 'map'\n\nRemarque : Pour obtenir [1, 4, 9], il faudrait utiliser list(map(lambda x: x ** 2, values))",
    "highlightedLines": [
      2
    ],
    "xpGain": 20,
    "tags": [
      "map",
      "lambda",
      "types",
      "iterators"
    ]
  }
]
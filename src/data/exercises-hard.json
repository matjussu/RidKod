[
  {
    "id": "py_hard_001",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "class Compteur:\n    count = 0\n    def __init__(self):\n        Compteur.count += 1\n\na = Compteur()\nb = Compteur()\nc = Compteur()\nprint(Compteur.count)",
    "options": [
      "0",
      "1",
      "3",
      "Error"
    ],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : count = 0 est une variable de classe\n• Elle est partagée par toutes les instances de Compteur\n\nLigne 3-4 : Méthode __init__() appelée à chaque création d'instance\n• Compteur.count += 1 incrémente la variable de classe\n\nCréation des instances :\n• Ligne 6 : a = Compteur() → Compteur.count = 1\n• Ligne 7 : b = Compteur() → Compteur.count = 2\n• Ligne 8 : c = Compteur() → Compteur.count = 3\n\nLigne 9 : print(Compteur.count) affiche 3\n\nRemarque : Une variable de classe est partagée entre toutes les instances, contrairement à une variable d'instance (self.count)",
    "highlightedLines": [
      2,
      4
    ],
    "xpGain": 30,
    "tags": [
      "classes",
      "class-variables",
      "instances"
    ]
  },
  {
    "id": "py_hard_002",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def generateur():\n    for i in range(3):\n        yield i * 2\n\ng = generateur()\nprint(next(g) + next(g))",
    "options": [
      "0",
      "2",
      "4",
      "6"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1-3 : generateur() est une fonction génératrice\n• Le mot-clé yield fait de cette fonction un générateur\n\nLigne 5 : g = generateur() crée l'objet générateur\n• Le code ne s'exécute pas encore\n\nLigne 6 : Deux appels à next(g)\n\nPremier appel next(g) :\n• i = 0 dans la boucle\n• yield 0 * 2 = 0\n• La fonction se met en pause et retourne 0\n\nDeuxième appel next(g) :\n• La fonction reprend là où elle s'était arrêtée\n• i = 1 dans la boucle\n• yield 1 * 2 = 2\n• La fonction retourne 2\n\nCalcul final : 0 + 2 = 2\n\nRemarque : Un générateur garde son état entre les appels next()",
    "highlightedLines": [
      3,
      6
    ],
    "xpGain": 30,
    "tags": [
      "generators",
      "yield",
      "next"
    ]
  },
  {
    "id": "py_hard_003",
    "language": "python",
    "difficulty": 3,
    "type": "find_error",
    "inputType": "clickable_lines",
    "question": "Quelle ligne causera une erreur à l'exécution ?",
    "code": "def calculer(a, b=5, c):\n    return a + b + c\n\nresult = calculer(1, 2, 3)\nprint(result)",
    "clickableLines": [
      1,
      2,
      3,
      4,
      5
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1 : Erreur de syntaxe dans la définition de la fonction\n\nRègle Python : Les paramètres avec valeur par défaut doivent venir APRÈS les paramètres sans défaut\n\nProblème dans def calculer(a, b=5, c) :\n• a : paramètre sans défaut ✓\n• b=5 : paramètre avec défaut ✓\n• c : paramètre sans défaut ✗ (vient après b qui a un défaut)\n\nCette erreur génère une SyntaxError avant même l'exécution du programme\n\nCorrections possibles :\n• def calculer(a, c, b=5): - Mettre c avant b\n• def calculer(a, b=5, c=0): - Donner un défaut à c aussi\n• def calculer(a, b, c): - Retirer le défaut de b",
    "highlightedLines": [
      1
    ],
    "xpGain": 30,
    "tags": [
      "functions",
      "parameters",
      "defaults",
      "syntax"
    ]
  },
  {
    "id": "py_hard_004",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Quelle est la valeur finale de result ?",
    "code": "values = [1, 2, 3, 4, 5]\nresult = sum([x for x in values if x % 2 != 0])\nprint(result)",
    "acceptedAnswers": [
      "9",
      "9.0"
    ],
    "explanation": "Ligne 1 : values = [1, 2, 3, 4, 5]\n\nLigne 2 : List comprehension avec condition\n• if x % 2 != 0 garde seulement les nombres impairs\n• L'opérateur % (modulo) donne le reste de la division\n\nVérification pour chaque nombre :\n• 1 % 2 = 1 (≠ 0) → 1 est impair ✓\n• 2 % 2 = 0 (= 0) → 2 est pair ✗\n• 3 % 2 = 1 (≠ 0) → 3 est impair ✓\n• 4 % 2 = 0 (= 0) → 4 est pair ✗\n• 5 % 2 = 1 (≠ 0) → 5 est impair ✓\n\nListe des impairs : [1, 3, 5]\nsum([1, 3, 5]) = 1 + 3 + 5 = 9\n\nLigne 3 : print() affiche 9",
    "highlightedLines": [
      2
    ],
    "xpGain": 30,
    "tags": [
      "list-comprehension",
      "sum",
      "modulo",
      "filtering"
    ]
  },
  {
    "id": "py_hard_005",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "try:\n    x = int('abc')\nexcept ValueError:\n    x = 0\nexcept:\n    x = -1\nfinally:\n    x += 10\nprint(x)",
    "options": [
      "-1",
      "0",
      "10",
      "Error"
    ],
    "correctAnswer": 2,
    "explanation": "Ligne 2 : int('abc') tente de convertir 'abc' en entier\n• Cette conversion est impossible\n• Génère une ValueError\n\nLigne 3-4 : Le bloc except ValueError attrape l'erreur spécifique\n• x = 0\n\nLigne 5-6 : Le bloc except générique n'est PAS exécuté\n• L'erreur a déjà été attrapée par except ValueError\n\nLigne 7-8 : Le bloc finally s'exécute TOUJOURS\n• Peu importe s'il y a eu une erreur ou non\n• x += 10 → x = 0 + 10 = 10\n\nLigne 9 : print(x) affiche 10\n\nRemarque : Le bloc finally s'exécute dans tous les cas, c'est utile pour nettoyer les ressources (fermer des fichiers, connexions, etc.)",
    "highlightedLines": [
      3,
      4,
      7,
      8
    ],
    "xpGain": 30,
    "tags": [
      "exceptions",
      "try-except",
      "finally",
      "error-handling"
    ]
  },
  {
    "id": "py_hard_006",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "matrix = [[1, 2], [3, 4], [5, 6]]\nresult = [row[1] for row in matrix]\nprint(sum(result))",
    "options": [
      "6",
      "9",
      "12",
      "21"
    ],
    "correctAnswer": 2,
    "explanation": "Ligne 1 : matrix = [[1, 2], [3, 4], [5, 6]]\n• Matrice 2D : 3 lignes, 2 colonnes chacune\n\nLigne 2 : List comprehension [row[1] for row in matrix]\n• Itère sur chaque ligne (row) de la matrice\n• Extrait le 2e élément (index 1) de chaque ligne\n\nExtraction détaillée :\n• row = [1, 2] → row[1] = 2\n• row = [3, 4] → row[1] = 4\n• row = [5, 6] → row[1] = 6\n• result = [2, 4, 6]\n\nLigne 3 : sum([2, 4, 6]) = 2 + 4 + 6 = 12\n\nRemarque : row[1] extrait la 2e colonne de la matrice (index 1), pas la 1ère (index 0)",
    "highlightedLines": [
      2
    ],
    "xpGain": 30,
    "tags": [
      "list-comprehension",
      "2d-lists",
      "indexing"
    ]
  },
  {
    "id": "py_hard_007",
    "language": "python",
    "difficulty": 3,
    "type": "concept_understanding",
    "inputType": "options",
    "question": "Que fait ce code ?",
    "code": "def decorator(func):\n    def wrapper(*args, **kwargs):\n        print('Avant')\n        result = func(*args, **kwargs)\n        print('Après')\n        return result\n    return wrapper\n\n@decorator\ndef dire_bonjour(nom):\n    print(f'Bonjour {nom}')",
    "options": [
      "Affiche seulement 'Bonjour {nom}'",
      "Affiche 'Avant', 'Bonjour {nom}', 'Après'",
      "Génère une erreur de syntaxe",
      "Remplace dire_bonjour par decorator"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1-7 : Définition du décorateur\n• decorator() prend une fonction en paramètre\n• wrapper() est une fonction interne qui enrobe func\n• *args, **kwargs permettent de passer tous types d'arguments\n• wrapper() retourne le résultat de func()\n\nLigne 9-11 : @decorator avant dire_bonjour\n• Équivalent à : dire_bonjour = decorator(dire_bonjour)\n• dire_bonjour devient wrapper avec func = dire_bonjour original\n\nExécution de dire_bonjour('Alice') :\n1. wrapper() s'exécute\n2. Ligne 3 : print('Avant')\n3. Ligne 4 : func('Alice') appelle dire_bonjour original\n4. Ligne 11 : print('Bonjour Alice')\n5. Ligne 5 : print('Après')\n\nRésultat affiché :\nAvant\nBonjour Alice\nAprès\n\nRemarque : Les décorateurs permettent d'ajouter du code avant/après une fonction sans modifier son code source",
    "highlightedLines": [
      1,
      2,
      3,
      4,
      5,
      9
    ],
    "xpGain": 30,
    "tags": [
      "decorators",
      "functions",
      "wrappers"
    ]
  },
  {
    "id": "py_hard_008",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "free_input",
    "keyboardType": "numeric",
    "question": "Combien de fois 'test' est-il affiché ?",
    "code": "for i in range(5):\n    if i == 2:\n        continue\n    if i == 4:\n        break\n    print('test')",
    "acceptedAnswers": [
      "3",
      "3.0"
    ],
    "explanation": "Ligne 1 : Boucle for i in range(5)\n• i prend les valeurs 0, 1, 2, 3, 4\n\nDéroulement détaillé :\n\nItération i = 0 :\n• Ligne 2-3 : 0 ≠ 2, pas de continue\n• Ligne 4-5 : 0 ≠ 4, pas de break\n• Ligne 6 : print('test') ✓ (1ère fois)\n\nItération i = 1 :\n• Ligne 2-3 : 1 ≠ 2, pas de continue\n• Ligne 4-5 : 1 ≠ 4, pas de break\n• Ligne 6 : print('test') ✓ (2ème fois)\n\nItération i = 2 :\n• Ligne 2-3 : i == 2 → continue\n• Le continue saute le reste de l'itération (pas de print)\n\nItération i = 3 :\n• Ligne 2-3 : 3 ≠ 2, pas de continue\n• Ligne 4-5 : 3 ≠ 4, pas de break\n• Ligne 6 : print('test') ✓ (3ème fois)\n\nItération i = 4 :\n• Ligne 2-3 : 4 ≠ 2, pas de continue\n• Ligne 4-5 : i == 4 → break\n• Le break sort de la boucle (pas de print)\n\nTotal : 'test' affiché 3 fois\n\nRemarque : continue saute l'itération actuelle, break sort complètement de la boucle",
    "highlightedLines": [
      2,
      3,
      4,
      5
    ],
    "xpGain": 30,
    "tags": [
      "loops",
      "continue",
      "break",
      "control-flow"
    ]
  },
  {
    "id": "py_hard_009",
    "language": "python",
    "difficulty": 3,
    "type": "predict_output",
    "inputType": "options",
    "question": "Que renvoie ce programme ?",
    "code": "def mystere(lst=[]):\n    lst.append(1)\n    return lst\n\na = mystere()\nb = mystere()\nprint(len(b))",
    "options": [
      "1",
      "2",
      "0",
      "Error"
    ],
    "correctAnswer": 1,
    "explanation": "Ligne 1-3 : Fonction mystere avec paramètre par défaut lst=[]\n\nAttention : La liste [] par défaut est créée UNE SEULE FOIS à la définition de la fonction\n• Elle est partagée entre tous les appels de mystere()\n• Ce n'est PAS une nouvelle liste à chaque appel\n\nPremier appel - Ligne 4 : a = mystere()\n• lst pointe vers la liste par défaut []\n• Ligne 2 : lst.append(1) → lst devient [1]\n• Ligne 3 : return [1]\n• a = [1]\n\nDeuxième appel - Ligne 5 : b = mystere()\n• lst pointe vers la MÊME liste [1] (partagée)\n• Ligne 2 : lst.append(1) → lst devient [1, 1]\n• Ligne 3 : return [1, 1]\n• b = [1, 1]\n\nLigne 6 : len(b) = len([1, 1]) = 2\n\nRemarque : C'est une erreur Python classique ! Les valeurs par défaut mutables (listes, dictionnaires) sont partagées. Pour éviter : def mystere(lst=None): if lst is None: lst = []",
    "highlightedLines": [
      1,
      2,
      4,
      5
    ],
    "xpGain": 30,
    "tags": [
      "functions",
      "mutable-defaults",
      "tricky",
      "common-mistakes"
    ]
  },
  {
    "id": "py_hard_010",
    "language": "python",
    "difficulty": 3,
    "type": "trace_execution",
    "inputType": "free_input",
    "keyboardType": "predefined",
    "question": "Quel est le type de 'unique' ?",
    "code": "numbers = [1, 2, 2, 3, 3, 3]\nunique = {x for x in numbers}\nprint(type(unique).__name__)",
    "acceptedAnswers": [
      "set"
    ],
    "explanation": "Ligne 1 : numbers = [1, 2, 2, 3, 3, 3]\n• Liste avec doublons\n\nLigne 2 : {x for x in numbers} est une SET COMPREHENSION\n• Les accolades {} indiquent un set (pas une liste)\n• Syntaxe similaire à list comprehension [x for x in numbers]\n• Différence : un set élimine automatiquement les doublons\n\nConstruction du set :\n• 1 est ajouté → {1}\n• 2 est ajouté → {1, 2}\n• 2 est déjà présent → {1, 2} (ignoré)\n• 3 est ajouté → {1, 2, 3}\n• 3 est déjà présent → {1, 2, 3} (ignoré)\n• 3 est déjà présent → {1, 2, 3} (ignoré)\n\nRésultat : unique = {1, 2, 3} (type: set)\n\nLigne 3 : type(unique).__name__ retourne 'set'\n\nRemarque sur les comprehensions :\n• [...] → list\n• {...} → set (ou dict si key:value)\n• (...) → generator\n\nLes sets sont non ordonnés et n'acceptent pas les doublons",
    "highlightedLines": [
      2
    ],
    "xpGain": 30,
    "tags": [
      "sets",
      "comprehensions",
      "types",
      "duplicates"
    ]
  }
]
{
  "category": "functions",
  "language": "python",
  "exerciseCount": 50,
  "exercises": [
    {
      "id": "py_func_001",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def saluer():\n    print('Bonjour')\n\nsaluer()",
      "options": [
        "Bonjour",
        "saluer",
        "None",
        "Erreur"
      ],
      "correctAnswer": 0,
      "explanation": "Ligne 1-2 : D√©finition de la fonction saluer()\n‚Ä¢ def d√©clare une fonction\n‚Ä¢ Le code dans la fonction affiche 'Bonjour'\n\nLigne 4 : saluer() appelle la fonction\n‚Ä¢ Le code de la fonction s'ex√©cute\n‚Ä¢ print() affiche 'Bonjour'\n\nR√©sultat : Bonjour",
      "highlightedLines": [2, 4],
      "xpGain": 10,
      "tags": ["functions", "definition", "call"],
      "category": "functions"
    },
    {
      "id": "py_func_002",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def double(x):\n    return x * 2\n\nresult = double(5)\nprint(result)",
      "options": [
        "5",
        "10",
        "25",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-2 : La fonction double() prend un param√®tre x et retourne x * 2\n\nLigne 4 : double(5) appelle la fonction avec x = 5\n‚Ä¢ Retourne 5 * 2 = 10\n\nLigne 5 : print() affiche 10\n\nR√©sultat : 10",
      "highlightedLines": [2, 4],
      "xpGain": 10,
      "tags": ["functions", "parameters", "return"],
      "category": "functions"
    },
    {
      "id": "py_func_003",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def ajouter(a, b):\n    return a + b\n\nprint(ajouter(3, 7))",
      "options": [
        "37",
        "10",
        "a + b",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-2 : La fonction ajouter() prend deux param√®tres a et b\n‚Ä¢ Elle retourne la somme a + b\n\nLigne 4 : ajouter(3, 7) appelle la fonction\n‚Ä¢ a = 3, b = 7\n‚Ä¢ Retourne 3 + 7 = 10\n\nR√©sultat : 10",
      "highlightedLines": [2, 4],
      "xpGain": 10,
      "tags": ["functions", "parameters", "return"],
      "category": "functions"
    },
    {
      "id": "py_func_004",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def carre(n):\n    return n ** 2\n\nprint(carre(4))",
      "options": [
        "4",
        "8",
        "16",
        "2"
      ],
      "correctAnswer": 2,
      "explanation": "Ligne 1-2 : La fonction carre() calcule le carr√© de n\n‚Ä¢ n ** 2 signifie n puissance 2\n\nLigne 4 : carre(4) appelle la fonction avec n = 4\n‚Ä¢ Retourne 4 ** 2 = 4 * 4 = 16\n\nR√©sultat : 16",
      "highlightedLines": [2, 4],
      "xpGain": 10,
      "tags": ["functions", "return", "arithmetic"],
      "category": "functions"
    },
    {
      "id": "py_func_005",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def saluer(nom):\n    return f'Bonjour {nom}'\n\nmessage = saluer('Alice')\nprint(message)",
      "options": [
        "Bonjour nom",
        "Bonjour Alice",
        "saluer('Alice')",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-2 : La fonction saluer() prend un param√®tre nom\n‚Ä¢ Elle retourne une f-string avec le nom ins√©r√©\n\nLigne 4 : saluer('Alice') appelle la fonction\n‚Ä¢ nom = 'Alice'\n‚Ä¢ Retourne 'Bonjour Alice'\n\nLigne 5 : print() affiche le message\n\nR√©sultat : Bonjour Alice",
      "highlightedLines": [2, 4],
      "xpGain": 10,
      "tags": ["functions", "parameters", "f-strings"],
      "category": "functions"
    },
    {
      "id": "py_func_006",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def dire_bonjour():\n    print('Bonjour')\n\nresult = dire_bonjour()\nprint(result)",
      "options": [
        "Bonjour puis Bonjour",
        "Bonjour puis None",
        "None puis Bonjour",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-2 : La fonction dire_bonjour() affiche 'Bonjour'\n‚Ä¢ ATTENTION : elle n'a pas de return\n\nLigne 4 : dire_bonjour() s'ex√©cute\n‚Ä¢ Affiche 'Bonjour'\n‚Ä¢ Comme il n'y a pas de return, la fonction retourne None\n\nLigne 5 : print(result) affiche None\n\nR√©sultat : Bonjour puis None\n\nüí° Une fonction sans return retourne automatiquement None",
      "highlightedLines": [2, 4, 5],
      "xpGain": 10,
      "tags": ["functions", "return", "None"],
      "category": "functions"
    },
    {
      "id": "py_func_007",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def multiplier(x, y):\n    resultat = x * y\n    return resultat\n\nprint(multiplier(3, 4))",
      "options": [
        "7",
        "12",
        "34",
        "resultat"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-3 : La fonction multiplier() :\n‚Ä¢ Ligne 2 : Calcule x * y et stocke dans resultat\n‚Ä¢ Ligne 3 : Retourne resultat\n\nLigne 5 : multiplier(3, 4) appelle la fonction\n‚Ä¢ x = 3, y = 4\n‚Ä¢ resultat = 3 * 4 = 12\n‚Ä¢ Retourne 12\n\nR√©sultat : 12",
      "highlightedLines": [2, 3, 5],
      "xpGain": 10,
      "tags": ["functions", "parameters", "return"],
      "category": "functions"
    },
    {
      "id": "py_func_008",
      "language": "python",
      "difficulty": 1,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "def greet(name):\n    print('Bonjour', nom)\n\ngreet('Alice')",
      "clickableLines": [1, 2, 3, 4],
      "correctAnswer": 2,
      "explanation": "Ligne 2 : NameError - variable 'nom' non d√©finie\n\nLe param√®tre de la fonction s'appelle 'name', pas 'nom'.\n\n‚Ä¢ Ligne 1 : def greet(name) d√©clare le param√®tre 'name'\n‚Ä¢ Ligne 2 : utilise 'nom' qui n'existe pas\n\nCorrection : print('Bonjour', name)",
      "highlightedLines": [2],
      "xpGain": 10,
      "tags": ["functions", "variables", "errors", "scope"],
      "category": "functions"
    },
    {
      "id": "py_func_009",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def maximum(a, b):\n    if a > b:\n        return a\n    return b\n\nprint(maximum(5, 8))",
      "options": [
        "5",
        "8",
        "True",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-4 : La fonction maximum() retourne le plus grand des deux nombres\n\nLigne 6 : maximum(5, 8) avec a = 5, b = 8\n‚Ä¢ Ligne 2 : 5 > 8 ? Non (False)\n‚Ä¢ Ligne 3 : Non ex√©cut√©\n‚Ä¢ Ligne 4 : return b, donc return 8\n\nR√©sultat : 8",
      "highlightedLines": [2, 4],
      "xpGain": 10,
      "tags": ["functions", "conditionals", "return"],
      "category": "functions"
    },
    {
      "id": "py_func_010",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def est_pair(n):\n    return n % 2 == 0\n\nprint(est_pair(7))",
      "options": [
        "True",
        "False",
        "1",
        "0"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-2 : La fonction est_pair() v√©rifie si n est pair\n‚Ä¢ n % 2 donne le reste de la division par 2\n‚Ä¢ Si le reste est 0, le nombre est pair\n\nLigne 4 : est_pair(7) avec n = 7\n‚Ä¢ 7 % 2 = 1 (reste de 7 / 2)\n‚Ä¢ 1 == 0 ? Non ‚Üí False\n\nR√©sultat : False\n\nüí° Un nombre pair a toujours un reste de 0 quand divis√© par 2",
      "highlightedLines": [2, 4],
      "xpGain": 10,
      "tags": ["functions", "return", "modulo"],
      "category": "functions"
    },
    {
      "id": "py_func_011",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def dire(message='Salut'):\n    print(message)\n\ndire()",
      "options": [
        "message",
        "Salut",
        "None",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1 : La fonction dire() a un param√®tre avec valeur par d√©faut\n‚Ä¢ message='Salut' signifie que si aucun argument n'est pass√©, message vaudra 'Salut'\n\nLigne 4 : dire() est appel√© SANS argument\n‚Ä¢ message prend sa valeur par d√©faut : 'Salut'\n‚Ä¢ print() affiche 'Salut'\n\nR√©sultat : Salut\n\nüí° Les valeurs par d√©faut permettent d'appeler une fonction sans tous ses arguments",
      "highlightedLines": [1, 4],
      "xpGain": 10,
      "tags": ["functions", "default-values", "parameters"],
      "category": "functions"
    },
    {
      "id": "py_func_012",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def calculer(a, b=10):\n    return a + b\n\nprint(calculer(5))",
      "options": [
        "5",
        "10",
        "15",
        "Erreur"
      ],
      "correctAnswer": 2,
      "explanation": "Ligne 1 : La fonction calculer() a deux param√®tres\n‚Ä¢ a est obligatoire\n‚Ä¢ b a une valeur par d√©faut de 10\n\nLigne 4 : calculer(5) est appel√© avec un seul argument\n‚Ä¢ a = 5\n‚Ä¢ b = 10 (valeur par d√©faut)\n‚Ä¢ Retourne 5 + 10 = 15\n\nR√©sultat : 15",
      "highlightedLines": [1, 2, 4],
      "xpGain": 10,
      "tags": ["functions", "default-values", "parameters"],
      "category": "functions"
    },
    {
      "id": "py_func_013",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "free_input",
      "keyboardType": "numeric",
      "question": "Quelle valeur est affich√©e ?",
      "code": "def incrementer(n):\n    return n + 1\n\nx = 5\ny = incrementer(incrementer(x))\nprint(y)",
      "acceptedAnswers": ["7"],
      "explanation": "Ligne 1-2 : incrementer() ajoute 1 √† n\n\nLigne 4 : x = 5\n\nLigne 5 : Appels imbriqu√©s\n‚Ä¢ incrementer(x) ‚Üí incrementer(5) ‚Üí 6\n‚Ä¢ incrementer(6) ‚Üí 7\n‚Ä¢ y = 7\n\nLigne 6 : print(y) affiche 7\n\nR√©sultat : 7\n\nüí° Les appels de fonctions imbriqu√©s s'ex√©cutent de l'int√©rieur vers l'ext√©rieur",
      "highlightedLines": [2, 5],
      "xpGain": 10,
      "tags": ["functions", "nested-calls", "return"],
      "category": "functions"
    },
    {
      "id": "py_func_014",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait cette fonction ?",
      "code": "def longueur(texte):\n    compteur = 0\n    for char in texte:\n        compteur += 1\n    return compteur",
      "options": [
        "Compte les espaces dans le texte",
        "Retourne le nombre de caract√®res",
        "Retourne le premier caract√®re",
        "Inverse le texte"
      ],
      "correctAnswer": 1,
      "explanation": "Cette fonction calcule la longueur d'un texte manuellement\n\nLigne 2 : Initialise un compteur √† 0\n\nLigne 3-4 : Boucle sur chaque caract√®re\n‚Ä¢ Pour chaque char dans texte\n‚Ä¢ Incr√©mente compteur de 1\n\nLigne 5 : Retourne le compteur final\n\nExemple : longueur('ABC')\n‚Ä¢ Boucle : 'A' ‚Üí compteur = 1, 'B' ‚Üí 2, 'C' ‚Üí 3\n‚Ä¢ Retourne 3\n\nCette fonction fait la m√™me chose que len()",
      "highlightedLines": [3, 4, 5],
      "xpGain": 10,
      "tags": ["functions", "loops", "strings"],
      "category": "functions"
    },
    {
      "id": "py_func_015",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "double = lambda x: x * 2\n\nprint(double(4))",
      "options": [
        "4",
        "8",
        "x * 2",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1 : Cr√©ation d'une fonction lambda\n‚Ä¢ lambda x: x * 2 cr√©e une fonction anonyme\n‚Ä¢ Elle prend x et retourne x * 2\n‚Ä¢ double devient une r√©f√©rence vers cette fonction\n\nLigne 3 : double(4) appelle la lambda\n‚Ä¢ x = 4\n‚Ä¢ Retourne 4 * 2 = 8\n\nR√©sultat : 8\n\nüí° lambda est une fa√ßon courte d'√©crire une fonction simple",
      "highlightedLines": [1, 3],
      "xpGain": 10,
      "tags": ["lambda", "functions"],
      "category": "functions"
    },
    {
      "id": "py_func_016",
      "language": "python",
      "difficulty": 1,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "def addition(a, b)\n    return a + b\n\nprint(addition(2, 3))",
      "clickableLines": [1, 2, 3, 4],
      "correctAnswer": 1,
      "explanation": "Ligne 1 : Il manque les deux-points ':' √† la fin\n\n‚Ä¢ En Python, la d√©finition d'une fonction doit se terminer par ':'\n‚Ä¢ def addition(a, b): est la syntaxe correcte\n\nCorrection : def addition(a, b):\n\nüí° Les deux-points ':' sont obligatoires apr√®s def, if, for, while, class",
      "highlightedLines": [1],
      "xpGain": 10,
      "tags": ["functions", "syntax", "errors"],
      "category": "functions"
    },
    {
      "id": "py_func_017",
      "language": "python",
      "difficulty": 1,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def info(nom, age):\n    return f'{nom} a {age} ans'\n\nprint(info(age=25, nom='Bob'))",
      "options": [
        "Bob a 25 ans",
        "25 a Bob ans",
        "nom a age ans",
        "Erreur"
      ],
      "correctAnswer": 0,
      "explanation": "Ligne 1-2 : La fonction info() prend nom et age\n\nLigne 4 : Appel avec arguments nomm√©s\n‚Ä¢ age=25 assigne 25 √† age\n‚Ä¢ nom='Bob' assigne 'Bob' √† nom\n‚Ä¢ L'ORDRE des arguments n'a pas d'importance avec les noms\n\nR√©sultat : Bob a 25 ans\n\nüí° Les arguments nomm√©s (keyword arguments) permettent de passer les param√®tres dans n'importe quel ordre",
      "highlightedLines": [2, 4],
      "xpGain": 10,
      "tags": ["functions", "keyword-arguments", "parameters"],
      "category": "functions"
    },
    {
      "id": "py_func_018",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def multiplier(x):\n    return lambda y: x * y\n\ndouble = multiplier(2)\nresult = double(5)\nprint(result)",
      "options": [
        "2",
        "5",
        "10",
        "Erreur"
      ],
      "correctAnswer": 2,
      "explanation": "Ligne 1-2 : La fonction multiplier(x) retourne une fonction lambda qui multiplie par x\n\nLigne 4 : double = multiplier(2) cr√©e une nouvelle fonction\n‚Ä¢ Cette fonction lambda garde en m√©moire x = 2\n\nLigne 5 : double(5) appelle la lambda avec y = 5\n‚Ä¢ La lambda calcule x * y = 2 * 5 = 10\n\nR√©sultat : 10\n\nüí° C'est une closure : la lambda 'capture' la valeur de x",
      "highlightedLines": [2, 4, 5],
      "xpGain": 20,
      "tags": ["functions", "lambda", "closures"],
      "category": "functions"
    },
    {
      "id": "py_func_019",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "free_input",
      "keyboardType": "numeric",
      "question": "Quelle est la valeur finale de x ?",
      "code": "x = 5\ndef modifier():\n    x = 10\n    return x\n\nmodifier()\nprint(x)",
      "acceptedAnswers": ["5"],
      "explanation": "Ligne 1 : x = 5 (variable globale)\n\nLigne 2-4 : La fonction modifier() cr√©e une nouvelle variable x = 10\n‚Ä¢ Cette variable x est LOCALE √† la fonction\n‚Ä¢ Elle est diff√©rente du x global\n‚Ä¢ Elle n'affecte pas le x global\n\nLigne 6 : modifier() s'ex√©cute\n‚Ä¢ Le x local = 10 existe seulement dans la fonction\n‚Ä¢ Le x global reste inchang√©\n\nLigne 7 : print(x) affiche le x global = 5\n\nüí° Pour modifier x global, il faudrait utiliser le mot-cl√© 'global'",
      "highlightedLines": [2, 3],
      "xpGain": 20,
      "tags": ["scope", "functions", "variables"],
      "category": "functions"
    },
    {
      "id": "py_func_020",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "x = 10\ndef modifier():\n    global x\n    x = 20\n\nmodifier()\nprint(x)",
      "options": [
        "10",
        "20",
        "None",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1 : x = 10 (variable globale)\n\nLigne 2-4 : La fonction modifier() utilise 'global x'\n‚Ä¢ Ligne 3 : global x indique qu'on utilise le x global\n‚Ä¢ Ligne 4 : x = 20 modifie le x global\n\nLigne 6 : modifier() s'ex√©cute\n‚Ä¢ Le x global est chang√© √† 20\n\nLigne 7 : print(x) affiche 20\n\nR√©sultat : 20\n\nüí° Le mot-cl√© 'global' permet de modifier une variable globale depuis une fonction",
      "highlightedLines": [3, 4, 7],
      "xpGain": 20,
      "tags": ["scope", "global", "functions"],
      "category": "functions"
    },
    {
      "id": "py_func_021",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait ce programme ?",
      "code": "def factorielle(n):\n    if n <= 1:\n        return 1\n    return n * factorielle(n - 1)\n\nresult = factorielle(5)",
      "options": [
        "Calcule 5 + 4 + 3 + 2 + 1",
        "Calcule 5 * 4 * 3 * 2 * 1",
        "Calcule 5^4",
        "G√©n√®re une erreur (r√©cursion infinie)"
      ],
      "correctAnswer": 1,
      "explanation": "Ce code calcule la factorielle de n de mani√®re r√©cursive\n\nLigne 2-3 : Cas de base\n‚Ä¢ Si n <= 1, la fonction retourne 1\n‚Ä¢ Cela arr√™te la r√©cursion\n\nLigne 4 : Cas r√©cursif\n‚Ä¢ La fonction s'appelle elle-m√™me avec n-1\n‚Ä¢ Multiplie n par le r√©sultat\n\nEx√©cution pour factorielle(5) :\n‚Ä¢ 5 * factorielle(4) = 5 * 24 = 120\n‚Ä¢ 4 * factorielle(3) = 4 * 6 = 24\n‚Ä¢ 3 * factorielle(2) = 3 * 2 = 6\n‚Ä¢ 2 * factorielle(1) = 2 * 1 = 2\n‚Ä¢ factorielle(1) = 1\n\nR√©sultat : 5 * 4 * 3 * 2 * 1 = 120",
      "highlightedLines": [2, 3, 4],
      "xpGain": 20,
      "tags": ["recursion", "functions", "factorielle"],
      "category": "functions"
    },
    {
      "id": "py_func_022",
      "language": "python",
      "difficulty": 2,
      "type": "trace_execution",
      "inputType": "free_input",
      "keyboardType": "predefined",
      "question": "Quel est le type de 'result' ?",
      "code": "values = [1, 2, 3]\nresult = map(lambda x: x ** 2, values)\nprint(type(result).__name__)",
      "acceptedAnswers": ["map"],
      "explanation": "Ligne 1 : values = [1, 2, 3]\n\nLigne 2 : map(lambda x: x ** 2, values)\n‚Ä¢ map() applique la fonction lambda √† chaque √©l√©ment\n‚Ä¢ lambda x: x ** 2 calcule le carr√© de x\n‚Ä¢ map() retourne un objet map (it√©rateur), pas une liste\n\nLigne 3 : type(result).__name__ retourne le nom du type\n‚Ä¢ result est de type 'map'\n\nüí° Pour obtenir [1, 4, 9], utilisez list(map(...))",
      "highlightedLines": [2],
      "xpGain": 20,
      "tags": ["map", "lambda", "types", "iterators"],
      "category": "functions"
    },
    {
      "id": "py_func_023",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def somme(*args):\n    total = 0\n    for num in args:\n        total += num\n    return total\n\nprint(somme(1, 2, 3, 4))",
      "options": [
        "1",
        "4",
        "10",
        "Erreur"
      ],
      "correctAnswer": 2,
      "explanation": "Ligne 1 : *args capture tous les arguments positionnels dans un tuple\n\nLigne 2-5 : Boucle sur args et additionne\n\nLigne 7 : somme(1, 2, 3, 4) appelle la fonction\n‚Ä¢ args = (1, 2, 3, 4)\n‚Ä¢ Boucle : total = 0 + 1 + 2 + 3 + 4 = 10\n\nR√©sultat : 10\n\nüí° *args permet d'accepter un nombre variable d'arguments",
      "highlightedLines": [1, 3, 7],
      "xpGain": 20,
      "tags": ["functions", "args", "variadic"],
      "category": "functions"
    },
    {
      "id": "py_func_024",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def afficher(**kwargs):\n    for cle, valeur in kwargs.items():\n        print(f'{cle}={valeur}')\n\nafficher(nom='Alice', age=25)",
      "options": [
        "nom=Alice puis age=25",
        "Alice puis 25",
        "('nom', 'Alice') puis ('age', 25)",
        "Erreur"
      ],
      "correctAnswer": 0,
      "explanation": "Ligne 1 : **kwargs capture tous les arguments nomm√©s dans un dictionnaire\n\nLigne 2-3 : Boucle sur les paires cl√©-valeur de kwargs\n\nLigne 5 : afficher(nom='Alice', age=25)\n‚Ä¢ kwargs = {'nom': 'Alice', 'age': 25}\n‚Ä¢ Boucle : affiche 'nom=Alice' puis 'age=25'\n\nR√©sultat : nom=Alice puis age=25\n\nüí° **kwargs permet d'accepter des arguments nomm√©s arbitraires",
      "highlightedLines": [1, 2, 5],
      "xpGain": 20,
      "tags": ["functions", "kwargs", "dictionaries"],
      "category": "functions"
    },
    {
      "id": "py_func_025",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def diviser(a, b):\n    return a // b, a % b\n\nquotient, reste = diviser(17, 5)\nprint(quotient, reste)",
      "options": [
        "3 2",
        "3.4 2",
        "17 5",
        "Erreur"
      ],
      "correctAnswer": 0,
      "explanation": "Ligne 1-2 : La fonction diviser() retourne DEUX valeurs\n‚Ä¢ a // b : division enti√®re\n‚Ä¢ a % b : reste (modulo)\n\nLigne 4 : diviser(17, 5) avec unpacking\n‚Ä¢ 17 // 5 = 3 (quotient)\n‚Ä¢ 17 % 5 = 2 (reste)\n‚Ä¢ quotient = 3, reste = 2\n\nLigne 5 : print() affiche 3 2\n\nüí° Python permet de retourner plusieurs valeurs avec return a, b",
      "highlightedLines": [2, 4],
      "xpGain": 20,
      "tags": ["functions", "return", "multiple-values", "unpacking"],
      "category": "functions"
    },
    {
      "id": "py_func_026",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "nombres = [1, 2, 3, 4, 5]\nresult = list(filter(lambda x: x % 2 == 0, nombres))\nprint(result)",
      "options": [
        "[1, 3, 5]",
        "[2, 4]",
        "[True, False, True, False, True]",
        "[1, 2, 3, 4, 5]"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1 : nombres = [1, 2, 3, 4, 5]\n\nLigne 2 : filter() garde les √©l√©ments o√π la fonction retourne True\n‚Ä¢ lambda x: x % 2 == 0 retourne True si x est pair\n‚Ä¢ filter() teste chaque √©l√©ment :\n  - 1 % 2 == 0 ? False ‚Üí exclu\n  - 2 % 2 == 0 ? True ‚Üí gard√©\n  - 3 % 2 == 0 ? False ‚Üí exclu\n  - 4 % 2 == 0 ? True ‚Üí gard√©\n  - 5 % 2 == 0 ? False ‚Üí exclu\n\nR√©sultat : [2, 4]\n\nüí° filter() filtre les √©l√©ments selon une condition",
      "highlightedLines": [2],
      "xpGain": 20,
      "tags": ["filter", "lambda", "functions"],
      "category": "functions"
    },
    {
      "id": "py_func_027",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "free_input",
      "keyboardType": "numeric",
      "question": "Quelle valeur est affich√©e ?",
      "code": "from functools import reduce\n\nnombres = [1, 2, 3, 4]\nresult = reduce(lambda a, b: a * b, nombres)\nprint(result)",
      "acceptedAnswers": ["24"],
      "explanation": "Ligne 1 : Import de reduce depuis functools\n\nLigne 3 : nombres = [1, 2, 3, 4]\n\nLigne 4 : reduce() applique la fonction de mani√®re cumulative\n‚Ä¢ lambda a, b: a * b multiplie deux nombres\n‚Ä¢ √âtapes :\n  - 1 * 2 = 2\n  - 2 * 3 = 6\n  - 6 * 4 = 24\n\nR√©sultat : 24\n\nüí° reduce() accumule les r√©sultats de gauche √† droite",
      "highlightedLines": [4],
      "xpGain": 20,
      "tags": ["reduce", "functools", "lambda"],
      "category": "functions"
    },
    {
      "id": "py_func_028",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def externe():\n    x = 'externe'\n    def interne():\n        return x\n    return interne\n\nfn = externe()\nprint(fn())",
      "options": [
        "externe",
        "interne",
        "x",
        "Erreur"
      ],
      "correctAnswer": 0,
      "explanation": "Ligne 1-5 : externe() d√©finit une fonction imbriqu√©e\n‚Ä¢ Ligne 2 : x = 'externe' est une variable locale\n‚Ä¢ Ligne 3-4 : interne() retourne x\n‚Ä¢ Ligne 5 : externe() retourne la fonction interne\n\nLigne 7 : fn = externe()\n‚Ä¢ externe() s'ex√©cute et retourne interne\n‚Ä¢ fn devient une r√©f√©rence vers interne\n‚Ä¢ x = 'externe' est captur√© (closure)\n\nLigne 8 : fn() appelle interne()\n‚Ä¢ Retourne x = 'externe'\n\nR√©sultat : externe\n\nüí° C'est une closure : interne capture x de son environnement",
      "highlightedLines": [2, 4, 5, 8],
      "xpGain": 20,
      "tags": ["closures", "functions", "nested"],
      "category": "functions"
    },
    {
      "id": "py_func_029",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def ajouter(liste=[]):\n    liste.append(1)\n    return liste\n\nprint(ajouter())\nprint(ajouter())",
      "options": [
        "[1] puis [1]",
        "[1] puis [1, 1]",
        "[] puis []",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "‚ö†Ô∏è PI√àGE CLASSIQUE Python !\n\nLigne 1 : liste=[] est une valeur par d√©faut MUTABLE\n‚Ä¢ Cette liste vide est cr√©√©e UNE SEULE FOIS √† la d√©finition\n\nLigne 5 : Premier appel ajouter()\n‚Ä¢ Utilise la liste par d√©faut\n‚Ä¢ Ajoute 1 ‚Üí liste = [1]\n\nLigne 6 : Deuxi√®me appel ajouter()\n‚Ä¢ R√©utilise la M√äME liste (pas une nouvelle)\n‚Ä¢ Ajoute 1 ‚Üí liste = [1, 1]\n\nR√©sultat : [1] puis [1, 1]\n\nüí° Ne jamais utiliser un objet mutable comme valeur par d√©faut ! Utilisez plut√¥t liste=None",
      "highlightedLines": [1, 2],
      "xpGain": 20,
      "tags": ["functions", "mutable-default", "pitfall"],
      "category": "functions"
    },
    {
      "id": "py_func_030",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def appliquer(fn, x):\n    return fn(x)\n\nresult = appliquer(abs, -5)\nprint(result)",
      "options": [
        "-5",
        "5",
        "abs",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-2 : appliquer() prend une fonction et une valeur\n‚Ä¢ fn est un param√®tre qui re√ßoit une fonction\n‚Ä¢ La fonction applique fn √† x\n\nLigne 4 : appliquer(abs, -5)\n‚Ä¢ fn = abs (la fonction valeur absolue)\n‚Ä¢ x = -5\n‚Ä¢ fn(x) = abs(-5) = 5\n\nR√©sultat : 5\n\nüí° En Python, les fonctions sont des objets 'first-class' : on peut les passer en param√®tres",
      "highlightedLines": [2, 4],
      "xpGain": 20,
      "tags": ["functions", "first-class", "higher-order"],
      "category": "functions"
    },
    {
      "id": "py_func_031",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nprint(fibonacci(6))",
      "options": [
        "6",
        "8",
        "13",
        "21"
      ],
      "correctAnswer": 1,
      "explanation": "Suite de Fibonacci r√©cursive :\n‚Ä¢ F(0) = 0, F(1) = 1\n‚Ä¢ F(n) = F(n-1) + F(n-2)\n\nCalcul de fibonacci(6) :\n‚Ä¢ F(6) = F(5) + F(4)\n‚Ä¢ F(5) = F(4) + F(3) = 3 + 2 = 5\n‚Ä¢ F(4) = F(3) + F(2) = 2 + 1 = 3\n‚Ä¢ F(3) = F(2) + F(1) = 1 + 1 = 2\n‚Ä¢ F(2) = F(1) + F(0) = 1 + 0 = 1\n‚Ä¢ F(1) = 1, F(0) = 0\n\nDonc F(6) = 5 + 3 = 8\n\nR√©sultat : 8",
      "highlightedLines": [2, 3, 4],
      "xpGain": 20,
      "tags": ["recursion", "fibonacci", "functions"],
      "category": "functions"
    },
    {
      "id": "py_func_032",
      "language": "python",
      "difficulty": 2,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne causera une erreur ?",
      "code": "def incrementer(n):\n    n += 1\n\nx = 5\nincr√©menter(x)\nprint(x)",
      "clickableLines": [1, 2, 3, 4, 5, 6],
      "correctAnswer": 5,
      "explanation": "Ligne 5 : NameError - 'incr√©menter' n'est pas d√©fini\n\n‚Ä¢ Ligne 1 : La fonction s'appelle 'incrementer' (sans accent)\n‚Ä¢ Ligne 5 : Appelle 'incr√©menter' (avec accent)\n\nEn Python, les noms sont sensibles aux accents !\n‚Ä¢ incrementer ‚â† incr√©menter\n\nCorrection : incrementer(x)",
      "highlightedLines": [5],
      "xpGain": 20,
      "tags": ["functions", "errors", "naming"],
      "category": "functions"
    },
    {
      "id": "py_func_033",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def compter():\n    compter.appels = getattr(compter, 'appels', 0) + 1\n    return compter.appels\n\nprint(compter(), compter(), compter())",
      "options": [
        "1 1 1",
        "1 2 3",
        "0 1 2",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "Cette fonction utilise un attribut sur elle-m√™me pour compter les appels\n\nLigne 2 : getattr(compter, 'appels', 0) + 1\n‚Ä¢ R√©cup√®re l'attribut 'appels' de la fonction compter\n‚Ä¢ Si l'attribut n'existe pas, retourne 0\n‚Ä¢ Puis ajoute 1\n\nLigne 5 : Trois appels successifs\n‚Ä¢ compter() : appels = 0 + 1 = 1 ‚Üí retourne 1\n‚Ä¢ compter() : appels = 1 + 1 = 2 ‚Üí retourne 2\n‚Ä¢ compter() : appels = 2 + 1 = 3 ‚Üí retourne 3\n\nR√©sultat : 1 2 3\n\nüí° Les fonctions sont des objets, on peut leur ajouter des attributs",
      "highlightedLines": [2, 5],
      "xpGain": 20,
      "tags": ["functions", "attributes", "getattr"],
      "category": "functions"
    },
    {
      "id": "py_func_034",
      "language": "python",
      "difficulty": 2,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def creer_compteur():\n    count = 0\n    def incrementer():\n        nonlocal count\n        count += 1\n        return count\n    return incrementer\n\ncompteur = creer_compteur()\nprint(compteur(), compteur())",
      "options": [
        "0 0",
        "1 1",
        "1 2",
        "Erreur"
      ],
      "correctAnswer": 2,
      "explanation": "Ligne 1-7 : creer_compteur() cr√©e une closure avec nonlocal\n‚Ä¢ count = 0 est dans l'environnement englobant\n‚Ä¢ nonlocal count permet √† incrementer() de modifier count\n\nLigne 9 : compteur = creer_compteur()\n‚Ä¢ count est initialis√© √† 0\n‚Ä¢ compteur devient la fonction incrementer\n\nLigne 10 : Deux appels\n‚Ä¢ Premier compteur() : count = 0 + 1 = 1, retourne 1\n‚Ä¢ Deuxi√®me compteur() : count = 1 + 1 = 2, retourne 2\n\nR√©sultat : 1 2\n\nüí° nonlocal permet de modifier une variable de la fonction englobante",
      "highlightedLines": [4, 5, 10],
      "xpGain": 20,
      "tags": ["closures", "nonlocal", "functions"],
      "category": "functions"
    },
    {
      "id": "py_func_035",
      "language": "python",
      "difficulty": 3,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne causera une erreur ?",
      "code": "def calculer(a, b=5, c):\n    return a + b + c\n\nresult = calculer(1, 2, 3)\nprint(result)",
      "clickableLines": [1, 2, 3, 4, 5],
      "correctAnswer": 1,
      "explanation": "Ligne 1 : SyntaxError dans la d√©finition de la fonction\n\nR√®gle Python : Les param√®tres avec valeur par d√©faut doivent venir APR√àS les param√®tres sans d√©faut\n\nProbl√®me : def calculer(a, b=5, c)\n‚Ä¢ a : param√®tre sans d√©faut ‚úì\n‚Ä¢ b=5 : param√®tre avec d√©faut ‚úì\n‚Ä¢ c : param√®tre sans d√©faut ‚úó (apr√®s un d√©faut)\n\nCorrections possibles :\n‚Ä¢ def calculer(a, c, b=5)\n‚Ä¢ def calculer(a, b=5, c=0)\n‚Ä¢ def calculer(a, b, c)",
      "highlightedLines": [1],
      "xpGain": 30,
      "tags": ["functions", "parameters", "defaults", "syntax"],
      "category": "functions"
    },
    {
      "id": "py_func_036",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait ce code ?",
      "code": "def decorator(func):\n    def wrapper(*args, **kwargs):\n        print('Avant')\n        result = func(*args, **kwargs)\n        print('Apr√®s')\n        return result\n    return wrapper\n\n@decorator\ndef dire_bonjour(nom):\n    print(f'Bonjour {nom}')",
      "options": [
        "Affiche seulement 'Bonjour {nom}'",
        "Affiche 'Avant', 'Bonjour {nom}', 'Apr√®s'",
        "G√©n√®re une erreur de syntaxe",
        "Remplace dire_bonjour par decorator"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-7 : D√©finition du d√©corateur\n‚Ä¢ decorator() prend une fonction en param√®tre\n‚Ä¢ wrapper() est une fonction interne qui enrobe func\n‚Ä¢ *args, **kwargs permettent de passer tous types d'arguments\n\nLigne 9-11 : @decorator avant dire_bonjour\n‚Ä¢ √âquivalent √† : dire_bonjour = decorator(dire_bonjour)\n\nEx√©cution de dire_bonjour('Alice') :\n1. wrapper() s'ex√©cute\n2. print('Avant')\n3. func('Alice') ‚Üí print('Bonjour Alice')\n4. print('Apr√®s')\n\nR√©sultat affich√© : Avant, Bonjour Alice, Apr√®s",
      "highlightedLines": [1, 2, 3, 4, 5, 9],
      "xpGain": 30,
      "tags": ["decorators", "functions", "wrappers"],
      "category": "functions"
    },
    {
      "id": "py_func_037",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def repeat(n):\n    def decorator(func):\n        def wrapper(*args):\n            for _ in range(n):\n                func(*args)\n        return wrapper\n    return decorator\n\n@repeat(3)\ndef dire(msg):\n    print(msg)\n\ndire('Hi')",
      "options": [
        "Hi",
        "Hi Hi Hi",
        "Hi (sur 3 lignes)",
        "Erreur"
      ],
      "correctAnswer": 2,
      "explanation": "D√©corateur avec param√®tre !\n\nLigne 1-7 : repeat(n) retourne un d√©corateur\n‚Ä¢ C'est un d√©corateur 'factory'\n‚Ä¢ n est captur√© dans la closure\n\nLigne 9 : @repeat(3) √©quivaut √† :\n‚Ä¢ decorator = repeat(3)  # n=3 est captur√©\n‚Ä¢ dire = decorator(dire)\n\nLigne 13 : dire('Hi') appelle wrapper('Hi')\n‚Ä¢ La boucle for s'ex√©cute 3 fois\n‚Ä¢ Chaque it√©ration appelle func('Hi')\n‚Ä¢ print('Hi') est appel√© 3 fois\n\nR√©sultat : Hi (affich√© 3 fois sur 3 lignes)",
      "highlightedLines": [4, 5, 9],
      "xpGain": 30,
      "tags": ["decorators", "parameters", "closures"],
      "category": "functions"
    },
    {
      "id": "py_func_038",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def memo(func):\n    cache = {}\n    def wrapper(n):\n        if n not in cache:\n            cache[n] = func(n)\n        return cache[n]\n    return wrapper\n\n@memo\ndef fib(n):\n    return n if n < 2 else fib(n-1) + fib(n-2)\n\nprint(fib(10))",
      "options": [
        "10",
        "34",
        "55",
        "89"
      ],
      "correctAnswer": 2,
      "explanation": "D√©corateur de m√©mo√Øsation pour Fibonacci\n\nLigne 1-7 : memo() cache les r√©sultats d√©j√† calcul√©s\n‚Ä¢ cache = {} stocke les r√©sultats\n‚Ä¢ Si n est dans cache, retourne directement\n‚Ä¢ Sinon, calcule et stocke\n\nLigne 9-11 : fib(n) utilise @memo\n‚Ä¢ Fibonacci r√©cursif avec cache\n‚Ä¢ Sans memo, ce serait tr√®s lent\n\nLigne 13 : fib(10)\n‚Ä¢ Suite : 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\n‚Ä¢ fib(10) = 55\n\nR√©sultat : 55\n\nüí° La m√©mo√Øsation optimise les fonctions r√©cursives",
      "highlightedLines": [2, 4, 5, 11],
      "xpGain": 30,
      "tags": ["decorators", "memoization", "recursion"],
      "category": "functions"
    },
    {
      "id": "py_func_039",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "free_input",
      "keyboardType": "numeric",
      "question": "Quelle valeur est affich√©e ?",
      "code": "from functools import partial\n\ndef puissance(base, exp):\n    return base ** exp\n\ncarre = partial(puissance, exp=2)\nprint(carre(5))",
      "acceptedAnswers": ["25"],
      "explanation": "Ligne 1 : Import de partial depuis functools\n\nLigne 3-4 : puissance() calcule base ** exp\n\nLigne 6 : partial() cr√©e une nouvelle fonction\n‚Ä¢ partial(puissance, exp=2) fixe exp=2\n‚Ä¢ carre devient puissance avec exp toujours = 2\n\nLigne 7 : carre(5) √©quivaut √† puissance(5, exp=2)\n‚Ä¢ 5 ** 2 = 25\n\nR√©sultat : 25\n\nüí° partial() permet de cr√©er des fonctions sp√©cialis√©es √† partir d'autres fonctions",
      "highlightedLines": [6, 7],
      "xpGain": 30,
      "tags": ["functools", "partial", "functions"],
      "category": "functions"
    },
    {
      "id": "py_func_040",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def outer():\n    funcs = []\n    for i in range(3):\n        funcs.append(lambda: i)\n    return funcs\n\nresult = [f() for f in outer()]\nprint(result)",
      "options": [
        "[0, 1, 2]",
        "[2, 2, 2]",
        "[0, 0, 0]",
        "Erreur"
      ],
      "correctAnswer": 1,
      "explanation": "‚ö†Ô∏è PI√àGE CLASSIQUE des closures !\n\nLigne 3-4 : La boucle cr√©e 3 lambdas\n‚Ä¢ Chaque lambda r√©f√©rence la variable i\n‚Ä¢ MAIS i est √©valu√©e au moment de l'APPEL, pas de la cr√©ation\n\nLigne 5 : Apr√®s la boucle, i = 2 (derni√®re valeur)\n\nLigne 7 : Appel des 3 fonctions\n‚Ä¢ Toutes retournent la valeur ACTUELLE de i = 2\n\nR√©sultat : [2, 2, 2]\n\nüí° Solution : lambda i=i: i capture la valeur au moment de la cr√©ation",
      "highlightedLines": [4, 7],
      "xpGain": 30,
      "tags": ["closures", "lambda", "pitfall"],
      "category": "functions"
    },
    {
      "id": "py_func_041",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def outer():\n    funcs = []\n    for i in range(3):\n        funcs.append(lambda x=i: x)\n    return funcs\n\nresult = [f() for f in outer()]\nprint(result)",
      "options": [
        "[0, 1, 2]",
        "[2, 2, 2]",
        "[0, 0, 0]",
        "Erreur"
      ],
      "correctAnswer": 0,
      "explanation": "Solution au pi√®ge des closures !\n\nLigne 4 : lambda x=i: x utilise i comme valeur par d√©faut\n‚Ä¢ Les valeurs par d√©faut sont √©valu√©es √† la CR√âATION\n‚Ä¢ Chaque lambda capture la valeur de i au moment o√π elle est cr√©√©e\n\nIt√©ration 0 : lambda avec x=0\nIt√©ration 1 : lambda avec x=1\nIt√©ration 2 : lambda avec x=2\n\nLigne 7 : Appel des 3 fonctions\n‚Ä¢ Chaque f() utilise sa valeur par d√©faut\n\nR√©sultat : [0, 1, 2]\n\nüí° Utiliser x=i force la capture imm√©diate de la valeur",
      "highlightedLines": [4, 7],
      "xpGain": 30,
      "tags": ["closures", "lambda", "default-values"],
      "category": "functions"
    },
    {
      "id": "py_func_042",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def compose(f, g):\n    return lambda x: f(g(x))\n\ndouble = lambda x: x * 2\nincrement = lambda x: x + 1\n\ncomposed = compose(double, increment)\nprint(composed(5))",
      "options": [
        "11",
        "12",
        "10",
        "7"
      ],
      "correctAnswer": 1,
      "explanation": "Ligne 1-2 : compose() cr√©e une composition de fonctions\n‚Ä¢ Retourne une fonction qui applique g puis f\n\nLigne 4 : double(x) = x * 2\nLigne 5 : increment(x) = x + 1\n\nLigne 7 : compose(double, increment)\n‚Ä¢ composed = lambda x: double(increment(x))\n\nLigne 8 : composed(5)\n‚Ä¢ √âtape 1 : increment(5) = 5 + 1 = 6\n‚Ä¢ √âtape 2 : double(6) = 6 * 2 = 12\n\nR√©sultat : 12\n\nüí° La composition de fonctions f‚àòg signifie 'f apr√®s g'",
      "highlightedLines": [2, 7, 8],
      "xpGain": 30,
      "tags": ["composition", "lambda", "higher-order"],
      "category": "functions"
    },
    {
      "id": "py_func_043",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def gen_powers(n):\n    return [lambda x, p=i: x**p for i in range(n)]\n\npowers = gen_powers(4)\nresult = [p(2) for p in powers]\nprint(result)",
      "options": [
        "[1, 2, 4, 8]",
        "[8, 8, 8, 8]",
        "[0, 1, 2, 3]",
        "[2, 2, 2, 2]"
      ],
      "correctAnswer": 0,
      "explanation": "Ligne 1-2 : gen_powers() cr√©e n fonctions puissance\n‚Ä¢ lambda x, p=i: x**p capture i dans p\n‚Ä¢ Chaque lambda calcule x √† la puissance p\n\nLigne 4 : gen_powers(4) cr√©e 4 fonctions\n‚Ä¢ p=0 : lambda x: x**0\n‚Ä¢ p=1 : lambda x: x**1\n‚Ä¢ p=2 : lambda x: x**2\n‚Ä¢ p=3 : lambda x: x**3\n\nLigne 5 : Appelle chaque fonction avec x=2\n‚Ä¢ 2**0 = 1\n‚Ä¢ 2**1 = 2\n‚Ä¢ 2**2 = 4\n‚Ä¢ 2**3 = 8\n\nR√©sultat : [1, 2, 4, 8]",
      "highlightedLines": [2, 5],
      "xpGain": 30,
      "tags": ["lambda", "closures", "list-comprehension"],
      "category": "functions"
    },
    {
      "id": "py_func_044",
      "language": "python",
      "difficulty": 3,
      "type": "trace_execution",
      "inputType": "free_input",
      "keyboardType": "numeric",
      "question": "Combien de fois 'Appel' est affich√© ?",
      "code": "def trace(func):\n    def wrapper(*args):\n        print('Appel')\n        return func(*args)\n    return wrapper\n\n@trace\ndef somme(a, b):\n    return a + b\n\nresult = somme(1, 2) + somme(3, 4)",
      "acceptedAnswers": ["2"],
      "explanation": "Ligne 1-5 : trace() est un d√©corateur qui affiche 'Appel'\n\nLigne 7-9 : somme() est d√©cor√©e par @trace\n‚Ä¢ Chaque appel √† somme() passe par wrapper()\n‚Ä¢ wrapper() affiche 'Appel' puis appelle la vraie fonction\n\nLigne 11 : result = somme(1, 2) + somme(3, 4)\n‚Ä¢ Premier appel somme(1, 2) ‚Üí 'Appel' affich√©, retourne 3\n‚Ä¢ Deuxi√®me appel somme(3, 4) ‚Üí 'Appel' affich√©, retourne 7\n\nR√©sultat : 'Appel' est affich√© 2 fois\n\nüí° Le d√©corateur enrobe chaque appel de fonction",
      "highlightedLines": [3, 11],
      "xpGain": 30,
      "tags": ["decorators", "tracing", "functions"],
      "category": "functions"
    },
    {
      "id": "py_func_045",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def curry(f):\n    def curried(a):\n        return lambda b: f(a, b)\n    return curried\n\n@curry\ndef add(x, y):\n    return x + y\n\nresult = add(3)(5)\nprint(result)",
      "options": [
        "3",
        "5",
        "8",
        "Erreur"
      ],
      "correctAnswer": 2,
      "explanation": "Curryfication : transformer f(a, b) en f(a)(b)\n\nLigne 1-4 : curry() transforme une fonction √† 2 args\n‚Ä¢ curried(a) retourne une lambda qui prend b\n‚Ä¢ La lambda appelle f(a, b)\n\nLigne 6-8 : add est curryfi√©e\n‚Ä¢ add(x, y) devient add(x)(y)\n\nLigne 10 : add(3)(5)\n‚Ä¢ add(3) retourne lambda b: f(3, b)\n‚Ä¢ (5) appelle cette lambda avec b=5\n‚Ä¢ f(3, 5) = 3 + 5 = 8\n\nR√©sultat : 8\n\nüí° Le currying permet l'application partielle de fonctions",
      "highlightedLines": [3, 10],
      "xpGain": 30,
      "tags": ["currying", "lambda", "higher-order"],
      "category": "functions"
    },
    {
      "id": "py_func_046",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def validate(min_val, max_val):\n    def decorator(func):\n        def wrapper(x):\n            if not min_val <= x <= max_val:\n                raise ValueError('Hors limites')\n            return func(x)\n        return wrapper\n    return decorator\n\n@validate(0, 100)\ndef percentage(x):\n    return f'{x}%'\n\nprint(percentage(50))",
      "options": [
        "50%",
        "50",
        "ValueError",
        "Erreur de syntaxe"
      ],
      "correctAnswer": 0,
      "explanation": "D√©corateur de validation avec param√®tres\n\nLigne 1-8 : validate(min_val, max_val) cr√©e un d√©corateur\n‚Ä¢ V√©rifie que x est entre min_val et max_val\n‚Ä¢ L√®ve une erreur sinon\n\nLigne 10-12 : @validate(0, 100) d√©core percentage\n‚Ä¢ Valide que l'argument est entre 0 et 100\n\nLigne 14 : percentage(50)\n‚Ä¢ wrapper(50) est appel√©\n‚Ä¢ 0 <= 50 <= 100 ? Oui ‚úì\n‚Ä¢ func(50) retourne '50%'\n\nR√©sultat : 50%\n\nüí° Les d√©corateurs avec param√®tres permettent de configurer le comportement",
      "highlightedLines": [4, 10, 14],
      "xpGain": 30,
      "tags": ["decorators", "validation", "parameters"],
      "category": "functions"
    },
    {
      "id": "py_func_047",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "class Compteur:\n    def __init__(self):\n        self.count = 0\n    def __call__(self):\n        self.count += 1\n        return self.count\n\nc = Compteur()\nprint(c(), c(), c())",
      "options": [
        "0 0 0",
        "1 1 1",
        "1 2 3",
        "Erreur"
      ],
      "correctAnswer": 2,
      "explanation": "Classe avec __call__ : l'instance devient appelable comme une fonction\n\nLigne 1-6 : Classe Compteur\n‚Ä¢ __init__ : initialise count √† 0\n‚Ä¢ __call__ : rend l'instance appelable, incr√©mente et retourne count\n\nLigne 8 : c = Compteur() cr√©e une instance\n\nLigne 9 : c(), c(), c() appelle l'instance 3 fois\n‚Ä¢ Chaque appel ex√©cute __call__\n‚Ä¢ c() : count = 1, retourne 1\n‚Ä¢ c() : count = 2, retourne 2\n‚Ä¢ c() : count = 3, retourne 3\n\nR√©sultat : 1 2 3\n\nüí° __call__ permet d'utiliser un objet comme une fonction",
      "highlightedLines": [4, 5, 6, 9],
      "xpGain": 30,
      "tags": ["classes", "__call__", "callable"],
      "category": "functions"
    },
    {
      "id": "py_func_048",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "import functools\n\n@functools.lru_cache(maxsize=None)\ndef fib(n):\n    return n if n < 2 else fib(n-1) + fib(n-2)\n\nprint(fib(50))",
      "options": [
        "50",
        "12586269025",
        "Recursion error",
        "Memory error"
      ],
      "correctAnswer": 1,
      "explanation": "lru_cache est un d√©corateur de m√©mo√Øsation int√©gr√© √† Python\n\nLigne 3 : @functools.lru_cache(maxsize=None)\n‚Ä¢ Cache les r√©sultats de la fonction\n‚Ä¢ maxsize=None = cache illimit√©\n\nLigne 4-5 : Fibonacci r√©cursif\n‚Ä¢ Sans cache : tr√®s lent pour n=50\n‚Ä¢ Avec cache : instantan√© !\n\nLigne 7 : fib(50) calcule le 50√®me nombre de Fibonacci\n‚Ä¢ Gr√¢ce au cache, chaque valeur n'est calcul√©e qu'une fois\n‚Ä¢ fib(50) = 12586269025\n\nR√©sultat : 12586269025\n\nüí° lru_cache est plus efficace qu'une impl√©mentation manuelle",
      "highlightedLines": [3, 7],
      "xpGain": 30,
      "tags": ["functools", "lru_cache", "memoization"],
      "category": "functions"
    },
    {
      "id": "py_func_049",
      "language": "python",
      "difficulty": 3,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne causera une erreur ?",
      "code": "def process(items):\n    def modifier(x):\n        return x * multiplier\n    multiplier = 2\n    return [modifier(i) for i in items]\n\nprint(process([1, 2, 3]))",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7],
      "correctAnswer": 7,
      "explanation": "‚ö†Ô∏è PI√àGE : Ce code fonctionne correctement !\n\nLa ligne 7 ne cause pas d'erreur. Le code affiche [2, 4, 6].\n\nPourquoi √ßa marche :\n‚Ä¢ modifier() est d√©finie √† la ligne 2-3\n‚Ä¢ Elle r√©f√©rence multiplier (pas encore d√©fini)\n‚Ä¢ MAIS modifier() n'est appel√©e qu'√† la ligne 5\n‚Ä¢ √Ä ce moment, multiplier = 2 existe d√©j√† (ligne 4)\n\nEx√©cution :\n‚Ä¢ process([1, 2, 3]) d√©marre\n‚Ä¢ multiplier = 2 est d√©fini\n‚Ä¢ La compr√©hension appelle modifier() pour chaque √©l√©ment\n‚Ä¢ modifier(1) = 1 * 2 = 2, etc.\n\nR√©sultat : [2, 4, 6]\n\nüí° Python √©value les variables au moment de l'ex√©cution, pas de la d√©finition",
      "highlightedLines": [],
      "xpGain": 30,
      "tags": ["closures", "scope", "evaluation"],
      "category": "functions"
    },
    {
      "id": "py_func_050",
      "language": "python",
      "difficulty": 3,
      "type": "predict_output",
      "inputType": "options",
      "question": "Que renvoie ce programme ?",
      "code": "def safe_divide(a, b, default=None):\n    try:\n        return a / b\n    except ZeroDivisionError:\n        return default\n\nresults = [safe_divide(10, x, 0) for x in [2, 0, 5]]\nprint(results)",
      "options": [
        "[5.0, None, 2.0]",
        "[5.0, 0, 2.0]",
        "[5, 0, 2]",
        "ZeroDivisionError"
      ],
      "correctAnswer": 1,
      "explanation": "Fonction avec gestion d'erreur et valeur par d√©faut\n\nLigne 1-5 : safe_divide() g√®re la division par z√©ro\n‚Ä¢ try: tente la division\n‚Ä¢ except: retourne default si division par z√©ro\n\nLigne 7 : Liste avec x = [2, 0, 5]\n‚Ä¢ safe_divide(10, 2, 0) = 10 / 2 = 5.0\n‚Ä¢ safe_divide(10, 0, 0) ‚Üí ZeroDivisionError ‚Üí retourne 0\n‚Ä¢ safe_divide(10, 5, 0) = 10 / 5 = 2.0\n\nR√©sultat : [5.0, 0, 2.0]\n\nüí° Les fonctions peuvent g√©rer les erreurs gracieusement avec des valeurs par d√©faut",
      "highlightedLines": [3, 5, 7],
      "xpGain": 30,
      "tags": ["functions", "exceptions", "default-values"],
      "category": "functions"
    }
  ]
}

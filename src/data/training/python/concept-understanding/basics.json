{
  "category": "basics",
  "type": "concept-understanding",
  "language": "python",
  "exerciseCount": 16,
  "exercises": [
    {
      "id": "py_cu_basics_001",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence principale entre print() et return ?",
      "code": "def exemple():\n    print('A')\n    return 'B'",
      "options": [
        "print() affiche √† l'√©cran, return renvoie une valeur",
        "return affiche √† l'√©cran, print renvoie une valeur",
        "Ils font exactement la m√™me chose",
        "print() est plus rapide que return"
      ],
      "correctAnswer": 0,
      "explanation": "print() vs return :\n\n‚Ä¢ print() affiche du texte √† l'√©cran (console)\n‚Ä¢ return renvoie une valeur au code appelant\n\nexemple() affiche 'A' ET retourne 'B'\nresultat = exemple()  # resultat = 'B'",
      "xpGain": 10,
      "tags": ["print", "return", "function"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_002",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi Python est-il appel√© un langage 'dynamiquement typ√©' ?",
      "code": "x = 5\nx = 'hello'\nx = [1, 2, 3]",
      "options": [
        "Le type des variables est v√©rifi√© √† l'ex√©cution, pas √† la compilation",
        "Python est plus rapide que les autres langages",
        "On doit d√©clarer le type avant d'utiliser une variable",
        "Python ne supporte qu'un seul type de donn√©es"
      ],
      "correctAnswer": 0,
      "explanation": "Typage dynamique :\n\n‚Ä¢ Pas besoin de d√©clarer le type\n‚Ä¢ Le type peut changer pendant l'ex√©cution\n‚Ä¢ x peut √™tre int, puis str, puis list\n\nContraire : typage statique (Java, C++)",
      "xpGain": 10,
      "tags": ["dynamic-typing", "variables", "types"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_003",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que signifie 'immutable' en Python ?",
      "code": "s = 'hello'\n# s[0] = 'H'  # Erreur!",
      "options": [
        "L'objet ne peut pas √™tre modifi√© apr√®s sa cr√©ation",
        "L'objet est tr√®s rapide",
        "L'objet peut stocker beaucoup de donn√©es",
        "L'objet est prot√©g√© par mot de passe"
      ],
      "correctAnswer": 0,
      "explanation": "Immutable = non modifiable :\n\n‚Ä¢ Les strings sont immutables\n‚Ä¢ s[0] = 'H' est interdit\n‚Ä¢ Il faut cr√©er une nouvelle string\n\nImmutables : str, int, float, tuple\nMutables : list, dict, set",
      "xpGain": 10,
      "tags": ["immutable", "mutable", "strings"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_004",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre '==' et 'is' ?",
      "code": "a = [1, 2, 3]\nb = [1, 2, 3]\nprint(a == b)  # True\nprint(a is b)  # False",
      "options": [
        "== compare les valeurs, is compare les identit√©s (m√™me objet en m√©moire)",
        "== compare les types, is compare les valeurs",
        "Ils sont identiques",
        "== est plus rapide que is"
      ],
      "correctAnswer": 0,
      "explanation": "== vs is :\n\n‚Ä¢ == : compare les VALEURS (contenu)\n‚Ä¢ is : compare les IDENTIT√âS (m√™me objet)\n\na et b ont le m√™me contenu (==)\nMais sont deux objets diff√©rents (is)",
      "xpGain": 10,
      "tags": ["equality", "identity", "operators"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_005",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi l'indentation est-elle importante en Python ?",
      "code": "if True:\n    print('A')  # indent√©\nprint('B')      # non indent√©",
      "options": [
        "Elle d√©finit les blocs de code (structure du programme)",
        "Elle rend le code plus joli uniquement",
        "Python ne fonctionne pas sans espaces",
        "Elle acc√©l√®re l'ex√©cution"
      ],
      "correctAnswer": 0,
      "explanation": "L'indentation d√©finit les blocs :\n\n‚Ä¢ En Python, l'indentation remplace les accolades {}\n‚Ä¢ Elle indique quel code appartient √† quel bloc\n‚Ä¢ G√©n√©ralement 4 espaces par niveau\n\n'A' est dans le if, 'B' est hors du if",
      "xpGain": 10,
      "tags": ["indentation", "syntax", "blocks"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_006",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que sont les 'truthy' et 'falsy' values ?",
      "code": "if '':\n    print('A')\nif 'hello':\n    print('B')",
      "options": [
        "Valeurs √©valu√©es comme True ou False dans un contexte bool√©en",
        "Des types sp√©ciaux de Python",
        "Des erreurs de programmation",
        "Des variables non d√©finies"
      ],
      "correctAnswer": 0,
      "explanation": "Truthy/Falsy :\n\n‚Ä¢ Falsy : '', 0, None, [], {}, False\n‚Ä¢ Truthy : tout le reste\n\n'' est falsy ‚Üí 'A' pas affich√©\n'hello' est truthy ‚Üí 'B' affich√©",
      "xpGain": 10,
      "tags": ["truthy", "falsy", "boolean"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_007",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait l'op√©rateur // en Python ?",
      "code": "print(7 // 2)   # R√©sultat: 3\nprint(-7 // 2)  # R√©sultat: -4",
      "options": [
        "Division enti√®re (floor division) - arrondit vers le bas",
        "Division normale",
        "Reste de la division (modulo)",
        "Division puis multiplication"
      ],
      "correctAnswer": 0,
      "explanation": "Floor division (//) :\n\n‚Ä¢ Divise et arrondit vers le BAS (floor)\n‚Ä¢ 7 // 2 = 3 (pas 3.5)\n‚Ä¢ -7 // 2 = -4 (pas -3, car floor(-3.5) = -4)\n\nüí° Toujours vers -‚àû, pas vers 0",
      "xpGain": 20,
      "tags": ["floor-division", "operators", "arithmetic"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_008",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre une expression et une instruction ?",
      "code": "x = 5 + 3      # instruction avec expression\nresult = x > 0  # instruction avec expression",
      "options": [
        "Une expression produit une valeur, une instruction ex√©cute une action",
        "Elles sont identiques",
        "Les expressions sont plus longues",
        "Les instructions contiennent toujours des mots-cl√©s"
      ],
      "correctAnswer": 0,
      "explanation": "Expression vs Instruction :\n\n‚Ä¢ Expression : produit une valeur (5+3, x>0)\n‚Ä¢ Instruction : effectue une action (x = ..., print())\n\nx = 5 + 3 : instruction d'assignation\n5 + 3 : expression qui vaut 8",
      "xpGain": 20,
      "tags": ["expression", "statement", "syntax"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_009",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi 0.1 + 0.2 != 0.3 en Python ?",
      "code": "print(0.1 + 0.2)  # 0.30000000000000004\nprint(0.1 + 0.2 == 0.3)  # False",
      "options": [
        "Les nombres flottants ont une pr√©cision limit√©e en binaire",
        "Python a un bug",
        "Les nombres d√©cimaux sont mal impl√©ment√©s",
        "Il faut utiliser des guillemets"
      ],
      "correctAnswer": 0,
      "explanation": "Pr√©cision des flottants :\n\n‚Ä¢ 0.1 ne peut pas √™tre repr√©sent√© exactement en binaire\n‚Ä¢ Comme 1/3 en d√©cimal (0.333...)\n‚Ä¢ Erreurs d'arrondi minuscules s'accumulent\n\nüí° Utiliser math.isclose() pour comparer",
      "xpGain": 20,
      "tags": ["float", "precision", "binary"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_010",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que signifie 'short-circuit evaluation' avec and/or ?",
      "code": "def check():\n    print('Appel√©')\n    return True\n\nFalse and check()  # check() pas appel√©",
      "options": [
        "Python arr√™te l'√©valuation d√®s que le r√©sultat est d√©termin√©",
        "Python ex√©cute les deux c√¥t√©s en parall√®le",
        "Python ignore les fonctions dans les conditions",
        "Python optimise le code automatiquement"
      ],
      "correctAnswer": 0,
      "explanation": "Short-circuit :\n\n‚Ä¢ False and X ‚Üí False (peu importe X)\n‚Ä¢ True or X ‚Üí True (peu importe X)\n\nPython n'√©value pas X si inutile\ncheck() n'est jamais appel√© ici",
      "xpGain": 20,
      "tags": ["short-circuit", "and", "or"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_011",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la port√©e (scope) d'une variable en Python ?",
      "code": "x = 'global'\ndef f():\n    x = 'local'\n    print(x)  # 'local'\nf()\nprint(x)  # 'global'",
      "options": [
        "LEGB : Local, Enclosing, Global, Built-in",
        "Toutes les variables sont globales",
        "Les variables n'existent que dans les fonctions",
        "Python n'a pas de syst√®me de port√©e"
      ],
      "correctAnswer": 0,
      "explanation": "R√®gle LEGB :\n\n‚Ä¢ L : Local (dans la fonction)\n‚Ä¢ E : Enclosing (fonction englobante)\n‚Ä¢ G : Global (module)\n‚Ä¢ B : Built-in (Python)\n\nPython cherche dans cet ordre",
      "xpGain": 20,
      "tags": ["scope", "LEGB", "variables"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_012",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi utilise-t-on if __name__ == '__main__' ?",
      "code": "def main():\n    print('Programme principal')\n\nif __name__ == '__main__':\n    main()",
      "options": [
        "Pour ex√©cuter du code seulement quand le fichier est lanc√© directement",
        "Pour rendre le code plus rapide",
        "C'est obligatoire en Python",
        "Pour cr√©er une fonction main"
      ],
      "correctAnswer": 0,
      "explanation": "__name__ == '__main__' :\n\n‚Ä¢ __name__ vaut '__main__' si ex√©cut√© directement\n‚Ä¢ __name__ vaut le nom du module si import√©\n\nPermet d'avoir du code de test qui ne s'ex√©cute pas √† l'import",
      "xpGain": 20,
      "tags": ["__name__", "__main__", "module"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_013",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que se passe-t-il lors d'une assignation multiple simultan√©e ?",
      "code": "a = 1\na, b = a + 1, a\nprint(a, b)",
      "options": [
        "Le c√¥t√© droit est √©valu√© en entier AVANT l'assignation",
        "Les assignations se font de gauche √† droite",
        "Python g√©n√®re une erreur",
        "Le r√©sultat est impr√©visible"
      ],
      "correctAnswer": 0,
      "explanation": "Assignation simultan√©e :\n\n‚Ä¢ D'abord : √©value (a+1, a) = (2, 1)\n‚Ä¢ Puis : a=2, b=1\n\nTout le c√¥t√© droit utilise les anciennes valeurs\nb re√ßoit l'ancienne valeur de a (1)",
      "xpGain": 30,
      "tags": ["assignment", "tuple-unpacking", "simultaneous"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_014",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne la comparaison en cha√Æne ?",
      "code": "x = 5\nprint(1 < x < 10)  # True\nprint(1 < x and x < 10)  # √âquivalent",
      "options": [
        "Python √©value 1 < x ET x < 10 simultan√©ment",
        "C'est une syntaxe sp√©ciale qui ne fonctionne qu'avec <",
        "Python compare 1 < x puis compare le r√©sultat avec 10",
        "C'est invalide en Python"
      ],
      "correctAnswer": 0,
      "explanation": "Comparaison en cha√Æne :\n\n‚Ä¢ 1 < x < 10 √©quivaut √† (1 < x) and (x < 10)\n‚Ä¢ Fonctionne avec tous les op√©rateurs de comparaison\n‚Ä¢ x n'est √©valu√© qu'une fois\n\n√âl√©gant et lisible !",
      "xpGain": 30,
      "tags": ["chained-comparison", "operators", "syntax"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_015",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait l'op√©rateur walrus := ?",
      "code": "if (n := len('hello')) > 3:\n    print(f'Long: {n}')",
      "options": [
        "Assigne une valeur ET retourne cette valeur dans une expression",
        "Compare deux valeurs",
        "Divise et assigne",
        "Cr√©e une r√©f√©rence √† une variable"
      ],
      "correctAnswer": 0,
      "explanation": "Op√©rateur walrus (:=) :\n\n‚Ä¢ Assigne ET retourne la valeur\n‚Ä¢ n := len('hello') ‚Üí n=5 et retourne 5\n‚Ä¢ Permet d'assigner dans des expressions\n\nNouveau en Python 3.8",
      "xpGain": 30,
      "tags": ["walrus", "assignment-expression", "Python3.8"],
      "category": "basics"
    },
    {
      "id": "py_cu_basics_016",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi les entiers sont-ils immutables mais semblent modifiables ?",
      "code": "x = 5\nprint(id(x))\nx += 1\nprint(id(x))  # ID diff√©rent !",
      "options": [
        "x += 1 cr√©e un NOUVEL objet, x pointe vers ce nouvel objet",
        "Python modifie l'entier en place",
        "Les entiers ne sont pas vraiment immutables",
        "id() donne des r√©sultats al√©atoires"
      ],
      "correctAnswer": 0,
      "explanation": "Immutabilit√© des int :\n\n‚Ä¢ x = 5 : x pointe vers l'objet 5\n‚Ä¢ x += 1 : cr√©e un nouvel objet 6\n‚Ä¢ x pointe maintenant vers 6\n\nL'objet 5 n'a pas chang√©, x a chang√© de cible",
      "xpGain": 30,
      "tags": ["immutable", "id", "integers"],
      "category": "basics"
    }
  ]
}

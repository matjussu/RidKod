{
  "category": "control-flow",
  "type": "concept-understanding",
  "language": "python",
  "exerciseCount": 16,
  "exercises": [
    {
      "id": "py_cu_cf_001",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre for et while ?",
      "code": "for i in range(5):  # it√®re sur une s√©quence\n    print(i)\n\ni = 0\nwhile i < 5:  # v√©rifie une condition\n    print(i)\n    i += 1",
      "options": [
        "for it√®re sur une s√©quence, while r√©p√®te tant qu'une condition est vraie",
        "while est plus rapide",
        "for ne peut utiliser que des nombres",
        "Ils sont identiques"
      ],
      "correctAnswer": 0,
      "explanation": "for vs while :\n\n‚Ä¢ for : parcourt un it√©rable (liste, range, etc.)\n‚Ä¢ while : r√©p√®te tant que condition vraie\n\nüí° for quand on conna√Æt les √©l√©ments\nüí° while quand on a une condition d'arr√™t",
      "xpGain": 10,
      "tags": ["for", "while", "loops"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_002",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre break et continue ?",
      "code": "for i in range(5):\n    if i == 2:\n        break  # Sort de la boucle\n\nfor i in range(5):\n    if i == 2:\n        continue  # Passe √† l'it√©ration suivante",
      "options": [
        "break sort de la boucle, continue passe √† l'it√©ration suivante",
        "continue sort de la boucle, break passe √† l'it√©ration suivante",
        "Ils arr√™tent tous les deux la boucle",
        "break est pour for, continue pour while"
      ],
      "correctAnswer": 0,
      "explanation": "break vs continue :\n\n‚Ä¢ break : sort COMPL√àTEMENT de la boucle\n‚Ä¢ continue : saute √† l'it√©ration SUIVANTE\n\nbreak √† i=2 ‚Üí boucle termin√©e\ncontinue √† i=2 ‚Üí 2 saut√©, continue avec 3,4...",
      "xpGain": 10,
      "tags": ["break", "continue", "loops"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_003",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne range() ?",
      "code": "range(5)      # 0, 1, 2, 3, 4\nrange(2, 5)   # 2, 3, 4\nrange(1, 10, 2)  # 1, 3, 5, 7, 9",
      "options": [
        "range(start, stop, step) g√©n√®re des entiers de start √† stop-1",
        "range g√©n√®re tous les entiers de start √† stop inclus",
        "range cr√©e une liste en m√©moire",
        "range ne fonctionne qu'avec un argument"
      ],
      "correctAnswer": 0,
      "explanation": "range(start, stop, step) :\n\n‚Ä¢ start : d√©but (inclus), d√©faut 0\n‚Ä¢ stop : fin (EXCLU)\n‚Ä¢ step : pas, d√©faut 1\n\nrange(5) = [0,1,2,3,4] (5 exclu)",
      "xpGain": 10,
      "tags": ["range", "for", "sequence"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_004",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait le else apr√®s une boucle for/while ?",
      "code": "for i in range(5):\n    if i == 10:\n        break\nelse:\n    print('Pas de break')",
      "options": [
        "S'ex√©cute si la boucle termine sans break",
        "S'ex√©cute si la boucle termine avec break",
        "S'ex√©cute toujours",
        "C'est invalide en Python"
      ],
      "correctAnswer": 0,
      "explanation": "else apr√®s boucle :\n\n‚Ä¢ S'ex√©cute si PAS de break\n‚Ä¢ 'Pas de break' s'affiche ici\n‚Ä¢ Si break avait √©t√© atteint, else ignor√©\n\nüí° Utile pour les recherches : else = 'non trouv√©'",
      "xpGain": 10,
      "tags": ["for-else", "while-else", "break"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_005",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre if, elif et else ?",
      "code": "if x > 10:\n    print('Grand')\nelif x > 5:\n    print('Moyen')\nelse:\n    print('Petit')",
      "options": [
        "if teste d'abord, elif teste si if est faux, else si tout est faux",
        "Toutes les conditions sont test√©es",
        "elif peut exister sans if",
        "else est obligatoire"
      ],
      "correctAnswer": 0,
      "explanation": "if/elif/else :\n\n‚Ä¢ if : premi√®re condition test√©e\n‚Ä¢ elif : test√© seulement si if est False\n‚Ä¢ else : ex√©cut√© si tout est False\n\nUNE SEULE branche s'ex√©cute",
      "xpGain": 10,
      "tags": ["if", "elif", "else"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_006",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait pass en Python ?",
      "code": "if True:\n    pass  # Ne fait rien\n\nfor i in range(5):\n    pass  # Boucle vide",
      "options": [
        "C'est une instruction qui ne fait rien (placeholder)",
        "Elle saute l'it√©ration suivante",
        "Elle termine le programme",
        "Elle affiche 'pass'"
      ],
      "correctAnswer": 0,
      "explanation": "pass :\n\n‚Ä¢ Instruction vide, ne fait rien\n‚Ä¢ Utilis√©e quand syntaxe exige un bloc\n‚Ä¢ Placeholder pour code √† √©crire plus tard\n\nDiff√©rent de continue (qui passe √† l'it√©ration suivante)",
      "xpGain": 10,
      "tags": ["pass", "placeholder", "syntax"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_007",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi ne pas modifier une liste pendant qu'on it√®re dessus ?",
      "code": "liste = [1, 2, 3, 4]\nfor item in liste:\n    if item % 2 == 0:\n        liste.remove(item)  # Dangereux!",
      "options": [
        "Certains √©l√©ments peuvent √™tre saut√©s ou l'it√©rateur devient invalide",
        "Python refuse cette op√©ration",
        "C'est plus lent",
        "La liste est verrouill√©e pendant l'it√©ration"
      ],
      "correctAnswer": 0,
      "explanation": "Modification pendant it√©ration :\n\n‚Ä¢ L'it√©rateur interne est perturb√©\n‚Ä¢ √âl√©ments saut√©s ou erreurs possibles\n‚Ä¢ R√©sultats impr√©visibles\n\nüí° Solution : it√©rer sur une copie\nfor item in liste.copy():",
      "xpGain": 20,
      "tags": ["iteration", "mutation", "list"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_008",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne l'expression ternaire ?",
      "code": "x = 10\nresult = 'pair' if x % 2 == 0 else 'impair'",
      "options": [
        "valeur_si_vrai if condition else valeur_si_faux",
        "condition ? valeur_vraie : valeur_fausse",
        "if condition then valeur else valeur",
        "valeur if condition"
      ],
      "correctAnswer": 0,
      "explanation": "Expression ternaire Python :\n\n‚Ä¢ Syntaxe : A if condition else B\n‚Ä¢ Retourne A si condition vraie\n‚Ä¢ Retourne B si condition fausse\n\nPlus concis qu'un if/else classique",
      "xpGain": 20,
      "tags": ["ternary", "expression", "conditional"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_009",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait enumerate() ?",
      "code": "for i, val in enumerate(['a', 'b', 'c']):\n    print(i, val)\n# 0 a, 1 b, 2 c",
      "options": [
        "Retourne l'index et la valeur √† chaque it√©ration",
        "Compte le nombre d'√©l√©ments",
        "Trie la liste",
        "Num√©rote les √©l√©ments d√©finitivement"
      ],
      "correctAnswer": 0,
      "explanation": "enumerate() :\n\n‚Ä¢ Retourne (index, valeur) √† chaque it√©ration\n‚Ä¢ √âvite d'utiliser range(len(liste))\n‚Ä¢ enumerate(liste, start=1) pour commencer √† 1\n\nPlus pythonique que for i in range(len(liste)):",
      "xpGain": 20,
      "tags": ["enumerate", "iteration", "index"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_010",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait zip() ?",
      "code": "noms = ['Alice', 'Bob']\nages = [25, 30]\nfor nom, age in zip(noms, ages):\n    print(nom, age)",
      "options": [
        "Combine plusieurs it√©rables en parall√®le",
        "Compresse les donn√©es",
        "Fusionne deux listes en une seule",
        "Inverse les listes"
      ],
      "correctAnswer": 0,
      "explanation": "zip() :\n\n‚Ä¢ Combine des it√©rables √©l√©ment par √©l√©ment\n‚Ä¢ ('Alice', 25), ('Bob', 30)\n‚Ä¢ S'arr√™te au plus court it√©rable\n\nüí° zip_longest() pour continuer avec None",
      "xpGain": 20,
      "tags": ["zip", "iteration", "parallel"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_011",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne match/case (Python 3.10+) ?",
      "code": "match commande:\n    case 'quit':\n        exit()\n    case 'save':\n        save()\n    case _:\n        print('Inconnu')",
      "options": [
        "Pattern matching structurel - compare la valeur √† des patterns",
        "C'est juste un switch/case classique",
        "√âvalue toutes les conditions",
        "Fonctionne uniquement avec des strings"
      ],
      "correctAnswer": 0,
      "explanation": "match/case (Python 3.10+) :\n\n‚Ä¢ Pattern matching puissant\n‚Ä¢ _ = pattern par d√©faut (wildcard)\n‚Ä¢ Peut matcher des structures complexes\n\nPlus puissant qu'un switch classique",
      "xpGain": 20,
      "tags": ["match", "case", "pattern-matching"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_012",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi range() retourne un objet et pas une liste ?",
      "code": "r = range(1000000)\n# Ne cr√©e pas 1 million d'√©l√©ments en m√©moire\nprint(r[500000])  # Acc√®s direct",
      "options": [
        "Pour √©conomiser la m√©moire - g√©n√®re les valeurs √† la demande",
        "Pour √™tre compatible avec Python 2",
        "C'est un bug",
        "Les listes ne peuvent pas √™tre aussi grandes"
      ],
      "correctAnswer": 0,
      "explanation": "range() est lazy :\n\n‚Ä¢ Ne stocke pas tous les √©l√©ments\n‚Ä¢ Calcule les valeurs √† la demande\n‚Ä¢ range(10**9) utilise tr√®s peu de m√©moire\n\nüí° G√©n√©rateur vs liste = √©conomie m√©moire",
      "xpGain": 20,
      "tags": ["range", "lazy", "memory"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_013",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne le d√©ballage dans for ?",
      "code": "points = [(1, 2), (3, 4), (5, 6)]\nfor x, y in points:\n    print(x, y)",
      "options": [
        "Chaque tuple est d√©ball√© en variables x et y automatiquement",
        "x re√ßoit le tuple, y est ignor√©",
        "Cela g√©n√®re une erreur",
        "x et y re√ßoivent des listes"
      ],
      "correctAnswer": 0,
      "explanation": "D√©ballage (unpacking) dans for :\n\n‚Ä¢ (1, 2) ‚Üí x=1, y=2\n‚Ä¢ Fonctionne avec tuples, listes, etc.\n‚Ä¢ Nombre de variables doit correspondre\n\n√âl√©gant pour it√©rer sur des paires/triplets",
      "xpGain": 30,
      "tags": ["unpacking", "for", "tuple"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_014",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la complexit√© de 'in' selon le type ?",
      "code": "5 in [1,2,3,4,5]     # O(n) - liste\n5 in {1,2,3,4,5}     # O(1) - set\n'a' in {'a': 1}      # O(1) - dict",
      "options": [
        "O(n) pour list, O(1) pour set et dict (hash table)",
        "O(1) pour tous",
        "O(n) pour tous",
        "O(log n) pour tous"
      ],
      "correctAnswer": 0,
      "explanation": "Complexit√© de 'in' :\n\n‚Ä¢ list/tuple : O(n) - parcours lin√©aire\n‚Ä¢ set/dict : O(1) - lookup par hash\n\nüí° Utiliser set pour des recherches fr√©quentes",
      "xpGain": 30,
      "tags": ["in", "complexity", "set"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_015",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment any() et all() fonctionnent-ils ?",
      "code": "print(any([False, False, True]))  # True\nprint(all([True, True, False]))   # False",
      "options": [
        "any() : au moins un True, all() : tous True",
        "any() : tous True, all() : au moins un True",
        "Ils retournent le nombre de True",
        "Ils modifient la liste"
      ],
      "correctAnswer": 0,
      "explanation": "any() et all() :\n\n‚Ä¢ any() : True si AU MOINS UN √©l√©ment est truthy\n‚Ä¢ all() : True si TOUS les √©l√©ments sont truthy\n\nany([]) = False (rien n'est True)\nall([]) = True (rien n'est False)",
      "xpGain": 30,
      "tags": ["any", "all", "boolean"],
      "category": "control-flow"
    },
    {
      "id": "py_cu_cf_016",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi √©viter les conditions comme 'if x == True' ?",
      "code": "x = True\n# Mauvais\nif x == True:\n    pass\n# Bon\nif x:\n    pass",
      "options": [
        "Redondant et peut √©chouer avec des valeurs truthy non-bool√©ennes",
        "C'est plus lent",
        "Python ne comprend pas == True",
        "C'est parfaitement correct"
      ],
      "correctAnswer": 0,
      "explanation": "'if x' vs 'if x == True' :\n\n‚Ä¢ if x accepte toutes les valeurs truthy\n‚Ä¢ if x == True ne marche qu'avec True exactement\n\nif 1 == True ‚Üí True (1 == True en Python)\nif [1] == True ‚Üí False (mais [1] est truthy!)",
      "xpGain": 30,
      "tags": ["boolean", "truthy", "best-practice"],
      "category": "control-flow"
    }
  ]
}

{
  "category": "strings",
  "type": "concept-understanding",
  "language": "python",
  "exerciseCount": 16,
  "exercises": [
    {
      "id": "py_cu_str_001",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi les strings sont-elles immutables en Python ?",
      "code": "s = 'hello'\n# s[0] = 'H'  # TypeError!",
      "options": [
        "Pour permettre le hashing et l'optimisation m√©moire",
        "Pour rendre le code plus difficile",
        "C'est un bug de Python",
        "Pour √©conomiser de la m√©moire uniquement"
      ],
      "correctAnswer": 0,
      "explanation": "Immutabilit√© des strings :\n\n‚Ä¢ Permet d'utiliser les strings comme cl√©s de dict\n‚Ä¢ Python peut r√©utiliser les m√™mes objets (interning)\n‚Ä¢ Plus s√ªr pour le multithreading\n\nCompromis : cr√©er une nouvelle string pour modifier",
      "xpGain": 10,
      "tags": ["strings", "immutable", "hashing"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_002",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre split() et split(' ') ?",
      "code": "s = 'a  b   c'\nprint(s.split())     # ['a', 'b', 'c']\nprint(s.split(' '))  # ['a', '', 'b', '', '', 'c']",
      "options": [
        "split() ignore les espaces multiples, split(' ') les compte",
        "split(' ') est plus rapide",
        "Ils sont identiques",
        "split() ne fonctionne qu'avec des lettres"
      ],
      "correctAnswer": 0,
      "explanation": "split() vs split(' ') :\n\n‚Ä¢ split() : divise sur tout whitespace, ignore les multiples\n‚Ä¢ split(' ') : divise sur chaque espace unique\n\n'a  b' ‚Üí split(): ['a','b'], split(' '): ['a','','b']",
      "xpGain": 10,
      "tags": ["split", "whitespace", "methods"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_003",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait la m√©thode strip() ?",
      "code": "s = '  hello  '\nprint(s.strip())  # 'hello'",
      "options": [
        "Supprime les espaces au d√©but et √† la fin",
        "Supprime tous les espaces",
        "Inverse la cha√Æne",
        "Convertit en majuscules"
      ],
      "correctAnswer": 0,
      "explanation": "strip() :\n\n‚Ä¢ Supprime les espaces/whitespace aux extr√©mit√©s\n‚Ä¢ Ne touche pas les espaces internes\n‚Ä¢ lstrip() : gauche seulement\n‚Ä¢ rstrip() : droite seulement",
      "xpGain": 10,
      "tags": ["strip", "whitespace", "methods"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_004",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre find() et index() ?",
      "code": "s = 'hello'\nprint(s.find('x'))   # -1\n# print(s.index('x'))  # ValueError!",
      "options": [
        "find() retourne -1 si non trouv√©, index() l√®ve une exception",
        "index() est plus rapide",
        "find() ne fonctionne qu'avec des caract√®res uniques",
        "Ils sont identiques"
      ],
      "correctAnswer": 0,
      "explanation": "find() vs index() :\n\n‚Ä¢ find('x') ‚Üí -1 si non trouv√©\n‚Ä¢ index('x') ‚Üí ValueError si non trouv√©\n\nüí° Utilisez find() si l'absence est possible\nüí° Utilisez index() si l'√©l√©ment doit exister",
      "xpGain": 10,
      "tags": ["find", "index", "methods"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_005",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que sont les f-strings en Python ?",
      "code": "nom = 'Alice'\nage = 25\nprint(f'Je suis {nom}, j\\'ai {age} ans')",
      "options": [
        "Des cha√Ænes format√©es avec des expressions int√©gr√©es",
        "Des cha√Ænes plus rapides",
        "Des cha√Ænes en lecture seule",
        "Des cha√Ænes pour les fichiers"
      ],
      "correctAnswer": 0,
      "explanation": "f-strings (Python 3.6+) :\n\n‚Ä¢ Pr√©fixe f devant la cha√Æne\n‚Ä¢ {expression} est √©valu√©e et ins√©r√©e\n‚Ä¢ Plus lisible que .format()\n‚Ä¢ Peut contenir des calculs : {2+2}",
      "xpGain": 10,
      "tags": ["f-string", "formatting", "Python3.6"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_006",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait le pr√©fixe r devant une cha√Æne ?",
      "code": "chemin = r'C:\\nouveau\\fichier'\nprint(chemin)  # C:\\nouveau\\fichier",
      "options": [
        "Cr√©e une raw string o√π les backslashes sont litt√©raux",
        "Rend la cha√Æne en lecture seule",
        "Inverse la cha√Æne",
        "R√©p√®te la cha√Æne"
      ],
      "correctAnswer": 0,
      "explanation": "Raw strings (r'...') :\n\n‚Ä¢ Les \\ sont trait√©s litt√©ralement\n‚Ä¢ \\n reste \\n (pas un saut de ligne)\n‚Ä¢ Utile pour les regex et chemins Windows\n\nSans r: 'C:\\nouveau' ‚Üí C: + newline + ouveau",
      "xpGain": 10,
      "tags": ["raw-string", "escape", "backslash"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_007",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi join() est-elle une m√©thode de string et pas de list ?",
      "code": "mots = ['a', 'b', 'c']\nresultat = '-'.join(mots)  # 'a-b-c'",
      "options": [
        "Car le s√©parateur d√©finit le r√©sultat, pas la liste",
        "C'est une erreur de conception",
        "Pour des raisons de performance",
        "Les listes n'ont pas de m√©thodes"
      ],
      "correctAnswer": 0,
      "explanation": "Design de join() :\n\n‚Ä¢ '-'.join(liste) ‚Üí le s√©parateur est central\n‚Ä¢ On peut joindre n'importe quel it√©rable\n‚Ä¢ Le r√©sultat est une string\n\nüí° Logique : la string 'cr√©e' le r√©sultat",
      "xpGain": 20,
      "tags": ["join", "design", "methods"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_008",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne le slicing avec des indices n√©gatifs ?",
      "code": "s = 'Python'\nprint(s[-3:])   # 'hon'\nprint(s[:-2])   # 'Pyth'",
      "options": [
        "Les indices n√©gatifs comptent depuis la fin",
        "Ils inversent la cha√Æne",
        "Ils suppriment des caract√®res",
        "Ils sont invalides"
      ],
      "correctAnswer": 0,
      "explanation": "Indices n√©gatifs :\n\n‚Ä¢ -1 = dernier caract√®re\n‚Ä¢ -2 = avant-dernier, etc.\n\n'Python'\n P  y  t  h  o  n\n 0  1  2  3  4  5\n-6 -5 -4 -3 -2 -1",
      "xpGain": 20,
      "tags": ["slicing", "negative-index", "strings"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_009",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre encode() et decode() ?",
      "code": "texte = 'caf√©'\noctets = texte.encode('utf-8')  # bytes\nretour = octets.decode('utf-8')  # str",
      "options": [
        "encode() convertit str‚Üíbytes, decode() convertit bytes‚Üístr",
        "encode() compresse, decode() d√©compresse",
        "Ils font la m√™me chose",
        "encode() crypte, decode() d√©crypte"
      ],
      "correctAnswer": 0,
      "explanation": "Encodage/D√©codage :\n\n‚Ä¢ str ‚Üí bytes : encode('utf-8')\n‚Ä¢ bytes ‚Üí str : decode('utf-8')\n\nLes strings sont Unicode, les bytes sont des octets bruts",
      "xpGain": 20,
      "tags": ["encode", "decode", "unicode"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_010",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi ''.join(liste) est plus efficace que += dans une boucle ?",
      "code": "# Inefficace\nresult = ''\nfor s in liste:\n    result += s\n\n# Efficace\nresult = ''.join(liste)",
      "options": [
        "join() cr√©e une seule string, += cr√©e une nouvelle string √† chaque it√©ration",
        "join() utilise moins de m√©moire",
        "Ce n'est pas vrai, += est plus rapide",
        "join() est compil√© en C"
      ],
      "correctAnswer": 0,
      "explanation": "Performance de join() :\n\n‚Ä¢ += : O(n¬≤) car copie √† chaque fois\n‚Ä¢ join() : O(n) car calcule la taille totale d'abord\n\nüí° Toujours pr√©f√©rer join() pour concat√©ner plusieurs strings",
      "xpGain": 20,
      "tags": ["join", "performance", "concatenation"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_011",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait la m√©thode partition() ?",
      "code": "s = 'hello:world:test'\nprint(s.partition(':'))  # ('hello', ':', 'world:test')",
      "options": [
        "Divise en 3 parties : avant, s√©parateur, apr√®s",
        "Divise sur tous les s√©parateurs",
        "Supprime le s√©parateur",
        "Inverse la cha√Æne"
      ],
      "correctAnswer": 0,
      "explanation": "partition() :\n\n‚Ä¢ Retourne un tuple de 3 √©l√©ments\n‚Ä¢ (avant, s√©parateur, apr√®s)\n‚Ä¢ Ne divise que sur la premi√®re occurrence\n\nVoir aussi rpartition() pour la derni√®re occurrence",
      "xpGain": 20,
      "tags": ["partition", "split", "tuple"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_012",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Qu'est-ce que le string interning en Python ?",
      "code": "a = 'hello'\nb = 'hello'\nprint(a is b)  # True (m√™me objet!)",
      "options": [
        "Python r√©utilise les m√™mes objets string pour √©conomiser la m√©moire",
        "Python copie les strings automatiquement",
        "Python crypte les strings",
        "Python v√©rifie les strings √† la compilation"
      ],
      "correctAnswer": 0,
      "explanation": "String interning :\n\n‚Ä¢ Python r√©utilise certaines strings identiques\n‚Ä¢ 'hello' et 'hello' peuvent √™tre le m√™me objet\n‚Ä¢ √âconomise la m√©moire\n\nüí° Fonctionne pour les strings courtes/simples",
      "xpGain": 20,
      "tags": ["interning", "memory", "optimization"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_013",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne le formatage avec des sp√©cificateurs ?",
      "code": "x = 3.14159\nprint(f'{x:.2f}')  # '3.14'\nprint(f'{x:10.2f}')  # '      3.14'",
      "options": [
        ".2f = 2 d√©cimales, 10 = largeur totale, align√© √† droite",
        ".2f = 2 chiffres, 10 = d√©cimales",
        "Ces syntaxes sont invalides",
        ".2f = pourcentage, 10 = exposant"
      ],
      "correctAnswer": 0,
      "explanation": "Sp√©cificateurs de format :\n\n‚Ä¢ .2f : 2 chiffres apr√®s la virgule\n‚Ä¢ 10 : largeur minimale (padding)\n‚Ä¢ Alignement par d√©faut : droite pour nombres\n\n{valeur:largeur.pr√©cision type}",
      "xpGain": 30,
      "tags": ["formatting", "f-string", "specifiers"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_014",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre str et repr ?",
      "code": "s = 'hello\\nworld'\nprint(str(s))   # hello\n                # world\nprint(repr(s))  # 'hello\\\\nworld'",
      "options": [
        "str() pour l'affichage humain, repr() pour la repr√©sentation Python",
        "repr() est plus court",
        "str() est pour le debug",
        "Ils sont identiques"
      ],
      "correctAnswer": 0,
      "explanation": "str() vs repr() :\n\n‚Ä¢ str() : lisible par un humain\n‚Ä¢ repr() : repr√©sentation Python valide\n\nrepr() montre les guillemets et caract√®res sp√©ciaux\nüí° repr() devrait produire du code valide",
      "xpGain": 30,
      "tags": ["str", "repr", "__repr__"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_015",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne translate() avec maketrans() ?",
      "code": "table = str.maketrans('aeiou', '12345')\nprint('hello'.translate(table))  # 'h2ll4'",
      "options": [
        "maketrans() cr√©e une table de correspondance, translate() l'applique",
        "translate() traduit en une autre langue",
        "maketrans() encode la cha√Æne",
        "Ces m√©thodes sont d√©pr√©ci√©es"
      ],
      "correctAnswer": 0,
      "explanation": "translate() + maketrans() :\n\n‚Ä¢ maketrans(from, to) : table de remplacement\n‚Ä¢ translate(table) : applique les remplacements\n\na‚Üí1, e‚Üí2, i‚Üí3, o‚Üí4, u‚Üí5\n'hello' ‚Üí 'h2ll4'",
      "xpGain": 30,
      "tags": ["translate", "maketrans", "replacement"],
      "category": "strings"
    },
    {
      "id": "py_cu_str_016",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi les strings supportent l'op√©rateur * mais pas + avec des int ?",
      "code": "print('ab' * 3)  # 'ababab'\n# print('ab' + 3)  # TypeError!",
      "options": [
        "'ab' * 3 a un sens (r√©p√©tition), 'ab' + 3 est ambigu",
        "C'est un bug de Python",
        "* est plus rapide que +",
        "Les deux devraient fonctionner"
      ],
      "correctAnswer": 0,
      "explanation": "Design des op√©rateurs string :\n\n‚Ä¢ 'ab' * 3 : r√©p√©tition, sens clair\n‚Ä¢ 'ab' + 3 : ambigu ('ab3' ? 'ab' r√©p√©t√© ? concat√©nation ?)\n\nPython refuse l'ambigu√Øt√©\nUtilisez str(3) explicitement : 'ab' + str(3)",
      "xpGain": 30,
      "tags": ["operators", "multiplication", "design"],
      "category": "strings"
    }
  ]
}

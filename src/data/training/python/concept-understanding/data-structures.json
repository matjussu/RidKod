{
  "category": "data-structures",
  "type": "concept-understanding",
  "language": "python",
  "exerciseCount": 16,
  "exercises": [
    {
      "id": "py_cu_ds_001",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence principale entre list et tuple ?",
      "code": "liste = [1, 2, 3]  # mutable\ntuple_ = (1, 2, 3)  # immutable",
      "options": [
        "Les listes sont mutables, les tuples sont immutables",
        "Les tuples sont plus rapides",
        "Les listes ne peuvent contenir que des nombres",
        "Les tuples utilisent des crochets"
      ],
      "correctAnswer": 0,
      "explanation": "list vs tuple :\n\n‚Ä¢ list : mutable (modifiable)\n‚Ä¢ tuple : immutable (non modifiable)\n\nTuple = plus l√©ger, hashable\nListe = flexible, modifiable",
      "xpGain": 10,
      "tags": ["list", "tuple", "mutable"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_002",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi un set ne peut-il pas contenir de listes ?",
      "code": "s = {1, 2, [3, 4]}  # TypeError!",
      "options": [
        "Les √©l√©ments d'un set doivent √™tre hashables (immutables)",
        "Les sets ne peuvent contenir que des nombres",
        "Les listes sont trop grandes",
        "C'est un bug de Python"
      ],
      "correctAnswer": 0,
      "explanation": "Set et hashabilit√© :\n\n‚Ä¢ Les sets utilisent le hashing pour la recherche O(1)\n‚Ä¢ Les listes sont mutables ‚Üí non hashables\n‚Ä¢ Utilisez des tuples √† la place\n\n{1, 2, (3, 4)} fonctionne",
      "xpGain": 10,
      "tags": ["set", "hashable", "list"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_003",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne l'acc√®s aux dictionnaires ?",
      "code": "d = {'a': 1, 'b': 2}\nprint(d['a'])  # 1\nprint(d.get('c', 0))  # 0",
      "options": [
        "d[cl√©] l√®ve KeyError si absent, get() retourne une valeur par d√©faut",
        "get() est plus lent",
        "Ils sont identiques",
        "d[cl√©] retourne None si absent"
      ],
      "correctAnswer": 0,
      "explanation": "Acc√®s dict :\n\n‚Ä¢ d[cl√©] : KeyError si cl√© absente\n‚Ä¢ d.get(cl√©, d√©faut) : retourne d√©faut si absent\n\nüí° get() plus s√ªr quand l'absence est possible",
      "xpGain": 10,
      "tags": ["dict", "get", "KeyError"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_004",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que garantit un set ?",
      "code": "s = {1, 2, 2, 3, 3, 3}\nprint(s)  # {1, 2, 3}",
      "options": [
        "Unicit√© des √©l√©ments (pas de doublons)",
        "Ordre des √©l√©ments",
        "√âl√©ments tri√©s",
        "Taille fixe"
      ],
      "correctAnswer": 0,
      "explanation": "Propri√©t√©s des sets :\n\n‚Ä¢ √âl√©ments uniques (pas de doublons)\n‚Ä¢ Non ordonn√©s (ordre d'it√©ration non garanti)\n‚Ä¢ Recherche O(1) gr√¢ce au hashing\n\nüí° Parfait pour √©liminer les doublons",
      "xpGain": 10,
      "tags": ["set", "unique", "duplicates"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_005",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre append() et extend() ?",
      "code": "a = [1, 2]\na.append([3, 4])  # [1, 2, [3, 4]]\n\nb = [1, 2]\nb.extend([3, 4])  # [1, 2, 3, 4]",
      "options": [
        "append() ajoute un √©l√©ment, extend() ajoute chaque √©l√©ment d'un it√©rable",
        "extend() est plus rapide",
        "append() ne fonctionne qu'avec des nombres",
        "Ils sont identiques"
      ],
      "correctAnswer": 0,
      "explanation": "append() vs extend() :\n\n‚Ä¢ append(x) : ajoute x comme UN √©l√©ment\n‚Ä¢ extend(iterable) : ajoute CHAQUE √©l√©ment\n\nappend([3,4]) ‚Üí [1,2,[3,4]]\nextend([3,4]) ‚Üí [1,2,3,4]",
      "xpGain": 10,
      "tags": ["list", "append", "extend"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_006",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que sont les dict.keys(), dict.values(), dict.items() ?",
      "code": "d = {'a': 1, 'b': 2}\nprint(d.keys())   # dict_keys(['a', 'b'])\nprint(d.values()) # dict_values([1, 2])\nprint(d.items())  # dict_items([('a', 1), ('b', 2)])",
      "options": [
        "Vues dynamiques sur les cl√©s, valeurs, et paires cl√©-valeur",
        "Copies des donn√©es du dictionnaire",
        "M√©thodes qui modifient le dictionnaire",
        "G√©n√©rateurs qui consomment le dictionnaire"
      ],
      "correctAnswer": 0,
      "explanation": "Vues de dictionnaire :\n\n‚Ä¢ keys() : vue sur les cl√©s\n‚Ä¢ values() : vue sur les valeurs\n‚Ä¢ items() : vue sur les paires (cl√©, valeur)\n\nüí° Vues dynamiques = refl√®tent les modifications",
      "xpGain": 10,
      "tags": ["dict", "keys", "values", "items"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_007",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre shallow copy et deep copy ?",
      "code": "import copy\noriginal = [[1, 2], [3, 4]]\nshallow = copy.copy(original)\ndeep = copy.deepcopy(original)",
      "options": [
        "Shallow copie la structure, deep copie aussi les objets imbriqu√©s",
        "Deep copy est plus rapide",
        "Shallow copy cr√©e des r√©f√©rences",
        "Ils sont identiques pour les listes"
      ],
      "correctAnswer": 0,
      "explanation": "Shallow vs Deep copy :\n\n‚Ä¢ Shallow : copie le conteneur, pas le contenu\n‚Ä¢ Deep : copie tout r√©cursivement\n\nshallow[0][0] = 99 modifie original[0][0]\ndeep[0][0] = 99 ne modifie PAS original",
      "xpGain": 20,
      "tags": ["copy", "shallow", "deep"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_008",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne le slicing avec un pas n√©gatif ?",
      "code": "liste = [0, 1, 2, 3, 4]\nprint(liste[::-1])  # [4, 3, 2, 1, 0]\nprint(liste[4:1:-1])  # [4, 3, 2]",
      "options": [
        "Parcourt la liste en sens inverse",
        "Supprime les √©l√©ments",
        "Trie en ordre d√©croissant",
        "Inverse les indices"
      ],
      "correctAnswer": 0,
      "explanation": "Slicing avec pas n√©gatif :\n\n‚Ä¢ step=-1 : direction invers√©e\n‚Ä¢ liste[::-1] : copie invers√©e\n‚Ä¢ liste[4:1:-1] : de 4 √† 2 (1 exclu)\n\nüí° Avec step n√©gatif, start > stop",
      "xpGain": 20,
      "tags": ["slicing", "negative-step", "reverse"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_009",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi les dictionnaires conservent-ils l'ordre d'insertion ?",
      "code": "d = {'c': 3, 'a': 1, 'b': 2}\nfor k in d:\n    print(k)  # c, a, b (ordre d'insertion)",
      "options": [
        "Depuis Python 3.7, c'est garanti par le langage",
        "Les dictionnaires trient par cl√©",
        "C'est un hasard",
        "Seulement pour les petits dictionnaires"
      ],
      "correctAnswer": 0,
      "explanation": "Ordre des dict (Python 3.7+) :\n\n‚Ä¢ L'ordre d'insertion est pr√©serv√©\n‚Ä¢ Garanti par la sp√©cification du langage\n‚Ä¢ Impl√©mentation efficace avec array compact\n\nAvant 3.7 : utilisez OrderedDict",
      "xpGain": 20,
      "tags": ["dict", "order", "Python3.7"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_010",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que sont les op√©rations ensemblistes sur les sets ?",
      "code": "a = {1, 2, 3}\nb = {2, 3, 4}\nprint(a | b)  # Union {1,2,3,4}\nprint(a & b)  # Intersection {2,3}\nprint(a - b)  # Diff√©rence {1}",
      "options": [
        "Union (|), Intersection (&), Diff√©rence (-), Diff√©rence sym√©trique (^)",
        "Ce sont des op√©rations math√©matiques",
        "Ces op√©rateurs ne fonctionnent pas sur les sets",
        "Ils modifient les sets originaux"
      ],
      "correctAnswer": 0,
      "explanation": "Op√©rations sur sets :\n\n‚Ä¢ a | b : √©l√©ments dans a OU b\n‚Ä¢ a & b : √©l√©ments dans a ET b\n‚Ä¢ a - b : √©l√©ments dans a mais pas b\n‚Ä¢ a ^ b : √©l√©ments dans a XOR b\n\nRetournent de nouveaux sets",
      "xpGain": 20,
      "tags": ["set", "union", "intersection"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_011",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne defaultdict ?",
      "code": "from collections import defaultdict\nd = defaultdict(list)\nd['a'].append(1)  # Pas de KeyError!",
      "options": [
        "Cr√©e automatiquement une valeur par d√©faut pour les cl√©s absentes",
        "Est plus rapide qu'un dict normal",
        "Ne peut contenir que des listes",
        "Est identique √† un dict normal"
      ],
      "correctAnswer": 0,
      "explanation": "defaultdict :\n\n‚Ä¢ defaultdict(type) : cr√©e automatiquement\n‚Ä¢ d['nouvelle_cl√©'] cr√©e une valeur du type\n‚Ä¢ √âvite les v√©rifications 'if key in d'\n\ndefaultdict(int) ‚Üí 0, defaultdict(list) ‚Üí []",
      "xpGain": 20,
      "tags": ["defaultdict", "collections", "dict"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_012",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre pop() et remove() sur une liste ?",
      "code": "liste = [1, 2, 3, 2]\nliste.pop(1)     # Retire l'√©l√©ment √† l'index 1\nliste.remove(2)  # Retire la premi√®re occurrence de 2",
      "options": [
        "pop() utilise l'index, remove() utilise la valeur",
        "pop() est plus rapide",
        "remove() retourne l'√©l√©ment",
        "Ils sont identiques"
      ],
      "correctAnswer": 0,
      "explanation": "pop() vs remove() :\n\n‚Ä¢ pop(index) : retire et retourne par position\n‚Ä¢ remove(value) : retire par valeur (premi√®re occurrence)\n\npop() retourne l'√©l√©ment\nremove() ne retourne rien",
      "xpGain": 20,
      "tags": ["list", "pop", "remove"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_013",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi [[0]*3]*3 cr√©e-t-il un pi√®ge ?",
      "code": "matrix = [[0] * 3] * 3\nmatrix[0][0] = 1\nprint(matrix)  # [[1,0,0], [1,0,0], [1,0,0]] !",
      "options": [
        "Les 3 lignes sont des r√©f√©rences au m√™me objet liste",
        "C'est un bug de Python",
        "La multiplication ne fonctionne pas sur les listes",
        "Le r√©sultat est correct"
      ],
      "correctAnswer": 0,
      "explanation": "Pi√®ge de la multiplication de listes :\n\n‚Ä¢ [x] * 3 cr√©e 3 R√âF√âRENCES √† x\n‚Ä¢ Modifier une ligne modifie toutes les lignes\n\nSolution : [[0]*3 for _ in range(3)]\nChaque it√©ration cr√©e une NOUVELLE liste",
      "xpGain": 30,
      "tags": ["list", "reference", "multiplication"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_014",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne le dict comprehension ?",
      "code": "carres = {x: x**2 for x in range(5)}\n# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}",
      "options": [
        "Cr√©e un dictionnaire avec une expression cl√©: valeur",
        "Cr√©e une liste de tuples",
        "Modifie un dictionnaire existant",
        "Est identique √† une list comprehension"
      ],
      "correctAnswer": 0,
      "explanation": "Dict comprehension :\n\n‚Ä¢ {cl√©: valeur for x in iterable}\n‚Ä¢ Cr√©e un dictionnaire en une ligne\n‚Ä¢ Peut inclure des conditions if\n\n{x: x**2 for x in range(5) if x % 2 == 0}",
      "xpGain": 30,
      "tags": ["dict-comprehension", "dict", "expression"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_015",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait collections.Counter ?",
      "code": "from collections import Counter\nc = Counter('abracadabra')\nprint(c.most_common(2))  # [('a', 5), ('b', 2)]",
      "options": [
        "Compte les occurrences et offre des m√©thodes utiles",
        "Cr√©e un compteur incr√©mental",
        "Est identique √† un dictionnaire",
        "Ne fonctionne qu'avec des strings"
      ],
      "correctAnswer": 0,
      "explanation": "Counter :\n\n‚Ä¢ Compte les occurrences automatiquement\n‚Ä¢ most_common(n) : n plus fr√©quents\n‚Ä¢ Supporte +, -, &, | entre Counters\n\nCounter([1,1,2,3,3,3]) ‚Üí {3:3, 1:2, 2:1}",
      "xpGain": 30,
      "tags": ["Counter", "collections", "counting"],
      "category": "data-structures"
    },
    {
      "id": "py_cu_ds_016",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre deque et list ?",
      "code": "from collections import deque\nd = deque([1, 2, 3])\nd.appendleft(0)  # O(1)\nd.popleft()      # O(1)",
      "options": [
        "deque a des op√©rations O(1) aux deux extr√©mit√©s",
        "deque est identique √† list",
        "list est toujours plus rapide",
        "deque ne peut pas √™tre index√©e"
      ],
      "correctAnswer": 0,
      "explanation": "deque vs list :\n\n‚Ä¢ list.insert(0, x) : O(n)\n‚Ä¢ deque.appendleft(x) : O(1)\n\ndeque = optimis√© pour les deux extr√©mit√©s\nüí° Parfait pour files/piles",
      "xpGain": 30,
      "tags": ["deque", "list", "complexity"],
      "category": "data-structures"
    }
  ]
}

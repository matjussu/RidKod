{
  "category": "advanced",
  "type": "concept-understanding",
  "language": "python",
  "exerciseCount": 16,
  "exercises": [
    {
      "id": "py_cu_adv_001",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre __init__ et __new__ ?",
      "code": "class MaClasse:\n    def __new__(cls):\n        return super().__new__(cls)\n    def __init__(self):\n        self.data = []",
      "options": [
        "__new__ cr√©e l'instance, __init__ l'initialise",
        "__init__ cr√©e l'instance, __new__ l'initialise",
        "Ils font la m√™me chose",
        "__new__ est pour les singletons uniquement"
      ],
      "correctAnswer": 0,
      "explanation": "__new__ vs __init__ :\n\n‚Ä¢ __new__ : constructeur, CR√âE l'objet\n‚Ä¢ __init__ : initialiseur, CONFIGURE l'objet\n\n__new__ re√ßoit cls, retourne l'instance\n__init__ re√ßoit self (instance d√©j√† cr√©√©e)",
      "xpGain": 10,
      "tags": ["__new__", "__init__", "constructor"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_002",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que sont les m√©thodes magiques (dunder) ?",
      "code": "class Nombre:\n    def __add__(self, other):\n        return self.val + other.val\n    def __str__(self):\n        return str(self.val)",
      "options": [
        "M√©thodes sp√©ciales avec double underscore pour surcharger les op√©rateurs",
        "M√©thodes priv√©es inaccessibles",
        "M√©thodes automatiquement appel√©es",
        "M√©thodes qui font de la magie"
      ],
      "correctAnswer": 0,
      "explanation": "M√©thodes dunder (__xxx__) :\n\n‚Ä¢ __add__ : op√©rateur +\n‚Ä¢ __str__ : conversion en string\n‚Ä¢ __len__ : fonction len()\n‚Ä¢ __getitem__ : indexation []\n\nPermettent de personnaliser le comportement",
      "xpGain": 10,
      "tags": ["dunder", "magic-methods", "operators"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_003",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre @staticmethod et @classmethod ?",
      "code": "class MaClasse:\n    @staticmethod\n    def statique():\n        pass\n    @classmethod\n    def de_classe(cls):\n        pass",
      "options": [
        "@staticmethod n'a pas acc√®s √† la classe, @classmethod re√ßoit cls",
        "@classmethod est plus rapide",
        "Ils sont identiques",
        "@staticmethod est pour les m√©thodes priv√©es"
      ],
      "correctAnswer": 0,
      "explanation": "@staticmethod vs @classmethod :\n\n‚Ä¢ @staticmethod : pas de self ni cls\n‚Ä¢ @classmethod : re√ßoit cls (la classe)\n\nclassmethod peut cr√©er des instances : cls()\nstaticmethod est une fonction rang√©e dans la classe",
      "xpGain": 10,
      "tags": ["staticmethod", "classmethod", "decorator"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_004",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne l'h√©ritage en Python ?",
      "code": "class Animal:\n    def parler(self):\n        return 'Son'\n\nclass Chien(Animal):\n    def parler(self):\n        return 'Wouf'",
      "options": [
        "La classe enfant h√©rite des attributs/m√©thodes et peut les surcharger",
        "L'enfant remplace compl√®tement le parent",
        "Python ne supporte pas l'h√©ritage",
        "L'h√©ritage ne fonctionne qu'avec une seule classe"
      ],
      "correctAnswer": 0,
      "explanation": "H√©ritage Python :\n\n‚Ä¢ class Enfant(Parent) h√©rite de Parent\n‚Ä¢ Peut surcharger (override) les m√©thodes\n‚Ä¢ super() acc√®de √† la classe parente\n‚Ä¢ H√©ritage multiple support√©",
      "xpGain": 10,
      "tags": ["inheritance", "override", "OOP"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_005",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait super() en Python ?",
      "code": "class B(A):\n    def __init__(self):\n        super().__init__()  # Appelle A.__init__",
      "options": [
        "Donne acc√®s √† la classe parente dans la hi√©rarchie MRO",
        "Rend la classe plus puissante",
        "Appelle toujours la m√©thode __init__",
        "Cr√©e une copie de la classe parente"
      ],
      "correctAnswer": 0,
      "explanation": "super() :\n\n‚Ä¢ Retourne un proxy vers la classe parente\n‚Ä¢ Suit le MRO (Method Resolution Order)\n‚Ä¢ super().__init__() : appelle le parent\n\nüí° Toujours utiliser super() plut√¥t que Parent.method()",
      "xpGain": 10,
      "tags": ["super", "inheritance", "MRO"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_006",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne try/except/finally ?",
      "code": "try:\n    x = 1/0\nexcept ZeroDivisionError:\n    x = 0\nfinally:\n    print('Toujours ex√©cut√©')",
      "options": [
        "try teste, except attrape les erreurs, finally s'ex√©cute toujours",
        "finally remplace except",
        "finally n'est ex√©cut√© que si pas d'erreur",
        "except est optionnel"
      ],
      "correctAnswer": 0,
      "explanation": "try/except/finally :\n\n‚Ä¢ try : code qui peut √©chouer\n‚Ä¢ except : g√®re l'exception\n‚Ä¢ finally : s'ex√©cute TOUJOURS\n\nfinally utile pour cleanup (fermer fichiers, etc.)",
      "xpGain": 10,
      "tags": ["try", "except", "finally"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_007",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Qu'est-ce qu'un context manager ?",
      "code": "with open('file.txt') as f:\n    data = f.read()\n# f est automatiquement ferm√© ici",
      "options": [
        "Objet avec __enter__ et __exit__ pour g√©rer des ressources",
        "Un gestionnaire de contexte syst√®me",
        "Une fa√ßon d'ouvrir des fichiers",
        "Un d√©corateur sp√©cial"
      ],
      "correctAnswer": 0,
      "explanation": "Context manager :\n\n‚Ä¢ __enter__ : appel√© au 'with'\n‚Ä¢ __exit__ : appel√© √† la sortie (m√™me si erreur)\n‚Ä¢ Garantit le cleanup (fermeture fichiers, etc.)\n\nwith g√®re automatiquement les ressources",
      "xpGain": 20,
      "tags": ["context-manager", "with", "__enter__"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_008",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne @property ?",
      "code": "class Cercle:\n    def __init__(self, rayon):\n        self._rayon = rayon\n    @property\n    def rayon(self):\n        return self._rayon",
      "options": [
        "Transforme une m√©thode en attribut accessible sans parenth√®ses",
        "Rend l'attribut priv√©",
        "Acc√©l√®re l'acc√®s √† l'attribut",
        "Copie l'attribut"
      ],
      "correctAnswer": 0,
      "explanation": "@property :\n\n‚Ä¢ Getter : c.rayon (sans ())\n‚Ä¢ Setter : @rayon.setter\n‚Ä¢ Deleter : @rayon.deleter\n\nPermet validation/calcul transparent",
      "xpGain": 20,
      "tags": ["property", "getter", "setter"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_009",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Qu'est-ce que le MRO (Method Resolution Order) ?",
      "code": "class A: pass\nclass B(A): pass\nclass C(A): pass\nclass D(B, C): pass\nprint(D.__mro__)",
      "options": [
        "L'ordre dans lequel Python cherche les m√©thodes dans l'h√©ritage",
        "L'ordre d'ex√©cution des m√©thodes",
        "La liste des m√©thodes d'une classe",
        "L'ordre alphab√©tique des m√©thodes"
      ],
      "correctAnswer": 0,
      "explanation": "MRO (Method Resolution Order) :\n\n‚Ä¢ Ordre de recherche des m√©thodes\n‚Ä¢ Algorithme C3 linearization\n‚Ä¢ D ‚Üí B ‚Üí C ‚Üí A ‚Üí object\n\nR√©sout le probl√®me du diamant en h√©ritage multiple",
      "xpGain": 20,
      "tags": ["MRO", "inheritance", "diamond"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_010",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que sont les slots en Python ?",
      "code": "class Point:\n    __slots__ = ['x', 'y']\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y",
      "options": [
        "R√©serve de la m√©moire fixe pour les attributs, plus efficace",
        "Limite le nombre d'instances",
        "Rend les attributs priv√©s",
        "Acc√©l√®re les m√©thodes"
      ],
      "correctAnswer": 0,
      "explanation": "__slots__ :\n\n‚Ä¢ Pas de __dict__ par instance\n‚Ä¢ Moins de m√©moire par instance\n‚Ä¢ Plus rapide pour l'acc√®s aux attributs\n‚Ä¢ Pas d'ajout dynamique d'attributs\n\nüí° Utile pour beaucoup d'instances",
      "xpGain": 20,
      "tags": ["__slots__", "memory", "optimization"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_011",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Qu'est-ce qu'une ABC (Abstract Base Class) ?",
      "code": "from abc import ABC, abstractmethod\n\nclass Forme(ABC):\n    @abstractmethod\n    def aire(self):\n        pass",
      "options": [
        "Classe avec m√©thodes abstraites que les sous-classes doivent impl√©menter",
        "Classe de base pour l'alphabet",
        "Classe automatiquement cr√©√©e",
        "Classe qui ne peut pas avoir d'instances"
      ],
      "correctAnswer": 0,
      "explanation": "ABC :\n\n‚Ä¢ D√©finit une interface\n‚Ä¢ @abstractmethod : doit √™tre impl√©ment√©\n‚Ä¢ Impossible d'instancier directement ABC\n‚Ä¢ Sous-classes DOIVENT impl√©menter les m√©thodes abstraites\n\nüí° Contrat de programmation",
      "xpGain": 20,
      "tags": ["ABC", "abstractmethod", "interface"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_012",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne raise from ?",
      "code": "try:\n    x = int('abc')\nexcept ValueError as e:\n    raise RuntimeError('Erreur conversion') from e",
      "options": [
        "Cha√Æne les exceptions en pr√©servant la cause originale",
        "Remplace l'exception",
        "Ignore l'exception originale",
        "L√®ve deux exceptions"
      ],
      "correctAnswer": 0,
      "explanation": "raise ... from ... :\n\n‚Ä¢ Pr√©serve l'exception originale (__cause__)\n‚Ä¢ Affiche la cha√Æne compl√®te d'exceptions\n‚Ä¢ raise ... from None : supprime le contexte\n\nüí° Meilleur debugging avec la cause visible",
      "xpGain": 20,
      "tags": ["raise", "exception", "chaining"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_013",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Qu'est-ce qu'une m√©taclasse ?",
      "code": "class Meta(type):\n    def __new__(cls, name, bases, dct):\n        return super().__new__(cls, name, bases, dct)\n\nclass MaClasse(metaclass=Meta):\n    pass",
      "options": [
        "Une classe qui cr√©e des classes",
        "Une super-classe",
        "Une classe abstraite",
        "Une classe priv√©e"
      ],
      "correctAnswer": 0,
      "explanation": "M√©taclasse :\n\n‚Ä¢ 'Classe de classe'\n‚Ä¢ Contr√¥le la cr√©ation des classes\n‚Ä¢ type est la m√©taclasse par d√©faut\n‚Ä¢ Permet de modifier les classes √† leur cr√©ation\n\nüí° Puissant mais rarement n√©cessaire",
      "xpGain": 30,
      "tags": ["metaclass", "type", "advanced"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_014",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne un descripteur ?",
      "code": "class Descripteur:\n    def __get__(self, obj, objtype):\n        return self._val\n    def __set__(self, obj, val):\n        self._val = val",
      "options": [
        "Objet qui personnalise l'acc√®s aux attributs via __get__/__set__",
        "Un d√©corateur pour les attributs",
        "Une fa√ßon de d√©crire les classes",
        "Un g√©n√©rateur de documentation"
      ],
      "correctAnswer": 0,
      "explanation": "Descripteur :\n\n‚Ä¢ __get__ : lecture attribut\n‚Ä¢ __set__ : √©criture attribut\n‚Ä¢ __delete__ : suppression\n\nproperty, classmethod, staticmethod sont des descripteurs\nüí° Contr√¥le fin de l'acc√®s aux attributs",
      "xpGain": 30,
      "tags": ["descriptor", "__get__", "__set__"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_015",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que sont les annotations de type ?",
      "code": "def saluer(nom: str) -> str:\n    return f'Bonjour {nom}'\n\nx: int = 5",
      "options": [
        "Indications de type pour documentation/outils, non v√©rifi√©es √† l'ex√©cution",
        "Contraintes de type v√©rifi√©es √† l'ex√©cution",
        "Commentaires sp√©ciaux",
        "Optimisations automatiques"
      ],
      "correctAnswer": 0,
      "explanation": "Type annotations :\n\n‚Ä¢ nom: str = type attendu\n‚Ä¢ -> str = type de retour\n‚Ä¢ NON v√©rifi√©es par Python\n‚Ä¢ Pour : documentation, mypy, IDE\n\nüí° Optionnelles mais recommand√©es",
      "xpGain": 30,
      "tags": ["type-hints", "annotations", "typing"],
      "category": "advanced"
    },
    {
      "id": "py_cu_adv_016",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne __getattr__ vs __getattribute__ ?",
      "code": "class A:\n    def __getattr__(self, name):\n        return f'{name} non trouv√©'\n    def __getattribute__(self, name):\n        return super().__getattribute__(name)",
      "options": [
        "__getattribute__ pour tout acc√®s, __getattr__ seulement si attribut absent",
        "Ils sont identiques",
        "__getattr__ est appel√© en premier",
        "__getattribute__ ne fonctionne qu'avec des strings"
      ],
      "correctAnswer": 0,
      "explanation": "__getattr__ vs __getattribute__ :\n\n‚Ä¢ __getattribute__ : CHAQUE acc√®s attribut\n‚Ä¢ __getattr__ : seulement si AttributeError\n\n__getattr__ = fallback\n__getattribute__ = interception totale (dangereux)",
      "xpGain": 30,
      "tags": ["__getattr__", "__getattribute__", "attribute"],
      "category": "advanced"
    }
  ]
}

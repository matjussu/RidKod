{
  "category": "functions",
  "type": "concept-understanding",
  "language": "python",
  "exerciseCount": 16,
  "exercises": [
    {
      "id": "py_cu_func_001",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre param√®tre et argument ?",
      "code": "def saluer(nom):  # 'nom' est un param√®tre\n    print(f'Bonjour {nom}')\n\nsaluer('Alice')  # 'Alice' est un argument",
      "options": [
        "Param√®tre = dans la d√©finition, Argument = dans l'appel",
        "Ils sont identiques",
        "Param√®tre = variable, Argument = constante",
        "Argument = dans la d√©finition, Param√®tre = dans l'appel"
      ],
      "correctAnswer": 0,
      "explanation": "Param√®tre vs Argument :\n\n‚Ä¢ Param√®tre : variable dans def (nom)\n‚Ä¢ Argument : valeur pass√©e √† l'appel ('Alice')\n\nüí° Les param√®tres re√ßoivent les arguments",
      "xpGain": 10,
      "tags": ["function", "parameter", "argument"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_002",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que retourne une fonction sans return explicite ?",
      "code": "def afficher(x):\n    print(x)\n\nresultat = afficher(5)\nprint(resultat)",
      "options": [
        "None",
        "0",
        "Une erreur",
        "La derni√®re valeur calcul√©e"
      ],
      "correctAnswer": 0,
      "explanation": "Return implicite :\n\n‚Ä¢ Sans return ‚Üí retourne None\n‚Ä¢ print() affiche mais ne retourne pas\n‚Ä¢ resultat = None\n\nüí° Toujours return si valeur attendue",
      "xpGain": 10,
      "tags": ["function", "return", "None"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_003",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait *args dans une fonction ?",
      "code": "def somme(*args):\n    return sum(args)\n\nprint(somme(1, 2, 3, 4))  # 10",
      "options": [
        "Capture un nombre variable d'arguments positionnels en tuple",
        "Multiplie les arguments",
        "Rend les arguments optionnels",
        "Cr√©e une liste d'arguments"
      ],
      "correctAnswer": 0,
      "explanation": "*args :\n\n‚Ä¢ Capture tous les args positionnels suppl√©mentaires\n‚Ä¢ args devient un tuple : (1, 2, 3, 4)\n‚Ä¢ Permet des fonctions √† nombre variable d'arguments\n\nüí° Le nom 'args' est une convention",
      "xpGain": 10,
      "tags": ["*args", "variadic", "function"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_004",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait **kwargs dans une fonction ?",
      "code": "def info(**kwargs):\n    for k, v in kwargs.items():\n        print(f'{k}: {v}')\n\ninfo(nom='Alice', age=25)",
      "options": [
        "Capture les arguments nomm√©s en dictionnaire",
        "Double les arguments",
        "Rend les arguments obligatoires",
        "Cr√©e une liste de tuples"
      ],
      "correctAnswer": 0,
      "explanation": "**kwargs :\n\n‚Ä¢ Capture les arguments nomm√©s suppl√©mentaires\n‚Ä¢ kwargs devient un dict : {'nom': 'Alice', 'age': 25}\n‚Ä¢ Permet des arguments nomm√©s variables\n\nüí° Le nom 'kwargs' est une convention",
      "xpGain": 10,
      "tags": ["**kwargs", "variadic", "function"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_005",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Qu'est-ce qu'une fonction lambda ?",
      "code": "carre = lambda x: x ** 2\nprint(carre(5))  # 25",
      "options": [
        "Une fonction anonyme en une seule expression",
        "Une fonction plus rapide",
        "Une fonction r√©cursive",
        "Une fonction qui retourne None"
      ],
      "correctAnswer": 0,
      "explanation": "Lambda :\n\n‚Ä¢ Fonction anonyme (sans nom)\n‚Ä¢ Une seule expression (pas de bloc)\n‚Ä¢ lambda args: expression\n\nüí° Utile pour fonctions simples/temporaires",
      "xpGain": 10,
      "tags": ["lambda", "anonymous", "function"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_006",
      "language": "python",
      "difficulty": 1,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi les arguments mutables par d√©faut sont dangereux ?",
      "code": "def ajouter(item, liste=[]):\n    liste.append(item)\n    return liste\n\nprint(ajouter(1))  # [1]\nprint(ajouter(2))  # [1, 2] ‚Üê Inattendu!",
      "options": [
        "La liste par d√©faut est cr√©√©e une seule fois et r√©utilis√©e",
        "Les listes ne peuvent pas √™tre des d√©fauts",
        "C'est un bug de Python",
        "La fonction est mal √©crite"
      ],
      "correctAnswer": 0,
      "explanation": "Arguments mutables par d√©faut :\n\n‚Ä¢ liste=[] cr√©√© UNE SEULE fois\n‚Ä¢ Chaque appel modifie la M√äME liste\n‚Ä¢ Solution : liste=None puis liste = liste or []\n\nüí° JAMAIS de mutable comme d√©faut",
      "xpGain": 10,
      "tags": ["default-argument", "mutable", "pitfall"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_007",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Qu'est-ce qu'une closure ?",
      "code": "def creer_compteur():\n    count = 0\n    def incrementer():\n        nonlocal count\n        count += 1\n        return count\n    return incrementer",
      "options": [
        "Une fonction qui capture des variables de son environnement englobant",
        "Une fonction ferm√©e qui ne peut pas √™tre modifi√©e",
        "Une fonction qui s'appelle elle-m√™me",
        "Une fonction sans param√®tres"
      ],
      "correctAnswer": 0,
      "explanation": "Closure :\n\n‚Ä¢ incrementer 'capture' count\n‚Ä¢ count survit apr√®s creer_compteur()\n‚Ä¢ La fonction 'se souvient' de son contexte\n\nüí° Fermeture lexicale sur les variables libres",
      "xpGain": 20,
      "tags": ["closure", "nested", "nonlocal"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_008",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre global et nonlocal ?",
      "code": "x = 'global'\ndef outer():\n    x = 'outer'\n    def inner():\n        nonlocal x  # Modifie outer.x\n        x = 'inner'",
      "options": [
        "global = module, nonlocal = fonction englobante",
        "Ils sont identiques",
        "nonlocal = module, global = fonction englobante",
        "global ne fonctionne pas dans les fonctions"
      ],
      "correctAnswer": 0,
      "explanation": "global vs nonlocal :\n\n‚Ä¢ global : variable du module\n‚Ä¢ nonlocal : variable de la fonction englobante\n\nSans ces mots-cl√©s, assigner cr√©e une nouvelle variable locale",
      "xpGain": 20,
      "tags": ["global", "nonlocal", "scope"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_009",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Qu'est-ce qu'une fonction de premier ordre ?",
      "code": "def appliquer(func, x):\n    return func(x)\n\nresultat = appliquer(lambda x: x*2, 5)  # 10",
      "options": [
        "Les fonctions peuvent √™tre pass√©es comme arguments et retourn√©es",
        "Les fonctions s'ex√©cutent en premier",
        "Les fonctions ont une priorit√© sp√©ciale",
        "Les fonctions ne peuvent pas avoir d'arguments"
      ],
      "correctAnswer": 0,
      "explanation": "Fonctions de premier ordre :\n\n‚Ä¢ Les fonctions sont des objets\n‚Ä¢ Peuvent √™tre pass√©es en argument\n‚Ä¢ Peuvent √™tre retourn√©es\n‚Ä¢ Peuvent √™tre stock√©es dans des variables\n\nüí° Python traite les fonctions comme des valeurs",
      "xpGain": 20,
      "tags": ["first-class", "higher-order", "function"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_010",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne un d√©corateur ?",
      "code": "@mon_decorateur\ndef ma_fonction():\n    pass\n\n# √âquivalent √† :\nma_fonction = mon_decorateur(ma_fonction)",
      "options": [
        "Un d√©corateur enveloppe une fonction pour modifier son comportement",
        "Un d√©corateur supprime une fonction",
        "Un d√©corateur est un commentaire sp√©cial",
        "Un d√©corateur acc√©l√®re l'ex√©cution"
      ],
      "correctAnswer": 0,
      "explanation": "D√©corateur :\n\n‚Ä¢ @decorator = fonction = decorator(fonction)\n‚Ä¢ Enveloppe la fonction originale\n‚Ä¢ Peut ajouter du code avant/apr√®s\n‚Ä¢ Peut modifier les arguments/r√©sultats\n\nüí° Pattern tr√®s puissant pour DRY",
      "xpGain": 20,
      "tags": ["decorator", "wrapper", "pattern"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_011",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Que fait functools.partial ?",
      "code": "from functools import partial\n\ndef puissance(base, exp):\n    return base ** exp\n\ncarre = partial(puissance, exp=2)\nprint(carre(5))  # 25",
      "options": [
        "Cr√©e une nouvelle fonction avec certains arguments pr√©-remplis",
        "Ex√©cute partiellement une fonction",
        "Divise une fonction en parties",
        "Rend une fonction incompl√®te"
      ],
      "correctAnswer": 0,
      "explanation": "partial() :\n\n‚Ä¢ 'Fige' certains arguments\n‚Ä¢ Cr√©e une nouvelle fonction\n‚Ä¢ carre = puissance avec exp=2 fix√©\n\nüí° Utile pour cr√©er des variantes de fonctions",
      "xpGain": 20,
      "tags": ["partial", "functools", "currying"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_012",
      "language": "python",
      "difficulty": 2,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Quelle est la diff√©rence entre map(), filter(), reduce() ?",
      "code": "map(func, iterable)    # Applique func √† chaque √©l√©ment\nfilter(func, iterable) # Garde si func(elem) est True\nreduce(func, iterable) # Accumule avec func(acc, elem)",
      "options": [
        "map transforme, filter s√©lectionne, reduce accumule",
        "Ils font tous la m√™me chose",
        "map et filter retournent des listes, reduce un it√©rateur",
        "reduce est le plus rapide"
      ],
      "correctAnswer": 0,
      "explanation": "map/filter/reduce :\n\n‚Ä¢ map : transforme chaque √©l√©ment\n‚Ä¢ filter : s√©lectionne des √©l√©ments\n‚Ä¢ reduce : combine tous en une valeur\n\nüí° Programmation fonctionnelle",
      "xpGain": 20,
      "tags": ["map", "filter", "reduce"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_013",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Pourquoi utiliser @functools.wraps dans un d√©corateur ?",
      "code": "from functools import wraps\ndef mon_deco(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        return func(*args, **kwargs)\n    return wrapper",
      "options": [
        "Pr√©serve les m√©tadonn√©es de la fonction originale (__name__, __doc__)",
        "Acc√©l√®re le d√©corateur",
        "Rend le d√©corateur obligatoire",
        "Permet d'empiler les d√©corateurs"
      ],
      "correctAnswer": 0,
      "explanation": "@wraps(func) :\n\n‚Ä¢ Copie __name__, __doc__, etc. de func vers wrapper\n‚Ä¢ Sans @wraps : wrapper.__name__ = 'wrapper'\n‚Ä¢ Avec @wraps : wrapper.__name__ = func.__name__\n\nüí° Toujours utiliser @wraps dans les d√©corateurs",
      "xpGain": 30,
      "tags": ["wraps", "decorator", "metadata"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_014",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne un g√©n√©rateur ?",
      "code": "def compteur(max):\n    n = 0\n    while n < max:\n        yield n\n        n += 1\n\nfor i in compteur(3):\n    print(i)  # 0, 1, 2",
      "options": [
        "yield suspend l'ex√©cution et retourne une valeur, reprend au prochain next()",
        "yield termine la fonction",
        "yield est identique √† return",
        "Les g√©n√©rateurs sont plus lents que les listes"
      ],
      "correctAnswer": 0,
      "explanation": "G√©n√©rateurs avec yield :\n\n‚Ä¢ yield 'pause' la fonction\n‚Ä¢ L'√©tat est pr√©serv√© entre les appels\n‚Ä¢ Lazy evaluation : valeurs g√©n√©r√©es √† la demande\n\nüí° √âconome en m√©moire pour grandes s√©quences",
      "xpGain": 30,
      "tags": ["generator", "yield", "lazy"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_015",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Qu'est-ce que la r√©cursion terminale ?",
      "code": "# Non terminale\ndef fact(n):\n    if n <= 1: return 1\n    return n * fact(n-1)\n\n# Terminale (avec accumulateur)\ndef fact_tail(n, acc=1):\n    if n <= 1: return acc\n    return fact_tail(n-1, n*acc)",
      "options": [
        "L'appel r√©cursif est la derni√®re op√©ration (optimisable en boucle)",
        "La r√©cursion s'arr√™te √† la fin",
        "Python optimise automatiquement",
        "C'est la fa√ßon la plus lente"
      ],
      "correctAnswer": 0,
      "explanation": "R√©cursion terminale :\n\n‚Ä¢ L'appel r√©cursif est la DERNI√àRE op√©ration\n‚Ä¢ Peut √™tre optimis√© en boucle (tail call optimization)\n‚Ä¢ Python ne l'optimise PAS automatiquement\n\nüí° Utile conceptuellement, pas en pratique Python",
      "xpGain": 30,
      "tags": ["recursion", "tail-call", "optimization"],
      "category": "functions"
    },
    {
      "id": "py_cu_func_016",
      "language": "python",
      "difficulty": 3,
      "type": "concept_understanding",
      "inputType": "options",
      "question": "Comment fonctionne @lru_cache ?",
      "code": "from functools import lru_cache\n\n@lru_cache(maxsize=128)\ndef fib(n):\n    if n < 2: return n\n    return fib(n-1) + fib(n-2)",
      "options": [
        "M√©mo√Øse les r√©sultats pour √©viter les recalculs",
        "Limite la r√©cursion",
        "Rend la fonction plus lente",
        "Stocke la fonction en cache"
      ],
      "correctAnswer": 0,
      "explanation": "lru_cache (memoization) :\n\n‚Ä¢ Cache les r√©sultats des appels pr√©c√©dents\n‚Ä¢ LRU = Least Recently Used\n‚Ä¢ fib(n) calcul√© une seule fois\n\nfib(35) : sans cache ~3s, avec cache ~instant",
      "xpGain": 30,
      "tags": ["lru_cache", "memoization", "optimization"],
      "category": "functions"
    }
  ]
}

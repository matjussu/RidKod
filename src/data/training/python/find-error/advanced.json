{
  "category": "advanced",
  "type": "find-error",
  "language": "python",
  "exerciseCount": 17,
  "exercises": [
    {
      "id": "py_fe_adv_001",
      "language": "python",
      "difficulty": 1,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Personne:\n    def __init__(nom, age):\n        self.nom = nom\n        self.age = age\n\np = Personne('Alice', 25)",
      "clickableLines": [1, 2, 3, 4, 5, 6],
      "correctAnswer": 2,
      "explanation": "Ligne 2 : Il manque 'self' comme premier param√®tre\n\n‚Ä¢ __init__ est une m√©thode d'instance\n‚Ä¢ Le premier param√®tre doit √™tre self\n‚Ä¢ Sans self, Python passe l'instance √† 'nom'\n\nErreur : TypeError: __init__() takes 2 positional arguments but 3 were given\n\nCorrection : def __init__(self, nom, age):",
      "highlightedLines": [2],
      "xpGain": 10,
      "tags": ["class", "self", "__init__"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_002",
      "language": "python",
      "difficulty": 1,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Animal:\n    def __init__(self, nom):\n        self.nom = nom\n\n    def parler():\n        print('...')\n\na = Animal('Rex')\na.parler()",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9],
      "correctAnswer": 5,
      "explanation": "Ligne 5 : Il manque 'self' dans la m√©thode parler()\n\n‚Ä¢ Les m√©thodes d'instance re√ßoivent self automatiquement\n‚Ä¢ Sans self, l'appel a.parler() passe l'instance en trop\n\nErreur : TypeError: parler() takes 0 positional arguments but 1 was given\n\nCorrection : def parler(self):",
      "highlightedLines": [5],
      "xpGain": 10,
      "tags": ["class", "method", "self"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_003",
      "language": "python",
      "difficulty": 1,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "try:\n    x = int('abc')\nexcept:\n    print('Erreur')\n    raise\nprint('Fin')",
      "clickableLines": [1, 2, 3, 4, 5, 6],
      "correctAnswer": 5,
      "explanation": "Ligne 5 : raise relance l'exception, donc 'Fin' ne s'affiche jamais\n\n‚Ä¢ raise sans argument relance l'exception courante\n‚Ä¢ Le programme se termine avec l'exception\n‚Ä¢ 'Fin' n'est jamais atteint\n\nüí° Ce n'est pas une erreur de syntaxe, mais le comportement peut √™tre inattendu\n\nSi on veut continuer apr√®s logging : retirer le raise",
      "highlightedLines": [5],
      "xpGain": 10,
      "tags": ["exception", "raise", "try-except"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_004",
      "language": "python",
      "difficulty": 1,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur de syntaxe ?",
      "code": "class Voiture:\n    def __init__(self, marque):\n        self.marque = marque\n\nclass Voiture:\n    roues = 4",
      "clickableLines": [1, 2, 3, 4, 5, 6],
      "correctAnswer": 5,
      "explanation": "Ligne 5 : Red√©finition de la classe Voiture\n\n‚Ä¢ Python permet de red√©finir une classe\n‚Ä¢ MAIS la premi√®re d√©finition est √©cras√©e\n‚Ä¢ Voiture n'aura plus __init__ ni marque\n\nüí° Pas d'erreur syntaxique, mais comportement inattendu\nLa classe finale n'a que l'attribut 'roues'\n\nCorrection : Utiliser un nom diff√©rent ou fusionner les d√©finitions",
      "highlightedLines": [5],
      "xpGain": 10,
      "tags": ["class", "redefinition", "overwrite"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_005",
      "language": "python",
      "difficulty": 1,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Compteur:\n    total = 0\n\n    def incrementer(self):\n        total += 1\n\nc = Compteur()\nc.incrementer()",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8],
      "correctAnswer": 5,
      "explanation": "Ligne 5 : total n'est pas qualifi√© correctement\n\n‚Ä¢ total est un attribut de classe (ligne 2)\n‚Ä¢ Dans la m√©thode, total += 1 cherche une variable locale\n‚Ä¢ Il faut utiliser Compteur.total ou self.total\n\nErreur : UnboundLocalError: local variable 'total' referenced before assignment\n\nCorrection : Compteur.total += 1",
      "highlightedLines": [5],
      "xpGain": 10,
      "tags": ["class", "class-attribute", "scope"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_006",
      "language": "python",
      "difficulty": 1,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "try:\n    resultat = 10 / 0\nexcept ValueError:\n    print('Erreur de valeur')",
      "clickableLines": [1, 2, 3, 4],
      "correctAnswer": 3,
      "explanation": "Ligne 3 : Mauvais type d'exception attrap√©\n\n‚Ä¢ La division par z√©ro l√®ve ZeroDivisionError\n‚Ä¢ except ValueError ne l'attrape pas\n‚Ä¢ L'exception se propage et crashe le programme\n\nErreur : ZeroDivisionError: division by zero\n\nCorrection : except ZeroDivisionError:\nOu : except Exception: (attrape tout)",
      "highlightedLines": [3],
      "xpGain": 10,
      "tags": ["exception", "except", "ZeroDivisionError"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_007",
      "language": "python",
      "difficulty": 2,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Animal:\n    def __init__(self, nom):\n        self.nom = nom\n\nclass Chien(Animal):\n    def __init__(self, nom, race):\n        super().__init__()\n        self.race = race\n\nc = Chien('Rex', 'Berger')",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      "correctAnswer": 7,
      "explanation": "Ligne 7 : super().__init__() ne passe pas 'nom'\n\n‚Ä¢ Animal.__init__ attend self et nom\n‚Ä¢ super().__init__() ne passe que self\n‚Ä¢ nom manque dans l'appel au parent\n\nErreur : TypeError: __init__() missing 1 required positional argument: 'nom'\n\nCorrection : super().__init__(nom)",
      "highlightedLines": [7],
      "xpGain": 20,
      "tags": ["class", "super", "inheritance"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_008",
      "language": "python",
      "difficulty": 2,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class MaClasse:\n    @staticmethod\n    def ma_methode(self):\n        return 'Hello'\n\nresultat = MaClasse.ma_methode()",
      "clickableLines": [1, 2, 3, 4, 5, 6],
      "correctAnswer": 3,
      "explanation": "Ligne 3 : @staticmethod ne re√ßoit pas self\n\n‚Ä¢ Les m√©thodes statiques n'ont pas acc√®s √† l'instance\n‚Ä¢ self ne devrait pas √™tre un param√®tre\n‚Ä¢ L'appel sans argument √©choue\n\nErreur : TypeError: ma_methode() missing 1 required positional argument: 'self'\n\nCorrection :\n@staticmethod\ndef ma_methode():\n    return 'Hello'",
      "highlightedLines": [3],
      "xpGain": 20,
      "tags": ["class", "staticmethod", "self"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_009",
      "language": "python",
      "difficulty": 2,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Cercle:\n    def __init__(self, rayon):\n        self._rayon = rayon\n\n    @property\n    def rayon(self):\n        return self._rayon\n\nc = Cercle(5)\nc.rayon = 10",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      "correctAnswer": 10,
      "explanation": "Ligne 10 : Impossible d'assigner √† une property sans setter\n\n‚Ä¢ @property cr√©e un getter (lecture seule)\n‚Ä¢ Pour modifier, il faut d√©finir @rayon.setter\n‚Ä¢ c.rayon = 10 √©choue sans setter\n\nErreur : AttributeError: can't set attribute\n\nCorrection : Ajouter un setter\n@rayon.setter\ndef rayon(self, value):\n    self._rayon = value",
      "highlightedLines": [10],
      "xpGain": 20,
      "tags": ["property", "setter", "AttributeError"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_010",
      "language": "python",
      "difficulty": 2,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Fichier:\n    def __enter__(self):\n        print('Ouverture')\n        return self\n\n    def __exit__(self):\n        print('Fermeture')\n\nwith Fichier() as f:\n    print('Utilisation')",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      "correctAnswer": 6,
      "explanation": "Ligne 6 : __exit__ doit avoir 4 param√®tres\n\n‚Ä¢ __exit__(self, exc_type, exc_val, exc_tb)\n‚Ä¢ exc_type, exc_val, exc_tb pour g√©rer les exceptions\n‚Ä¢ Sans ces param√®tres, le context manager √©choue\n\nErreur : TypeError: __exit__() takes 1 positional argument but 4 were given\n\nCorrection :\ndef __exit__(self, exc_type, exc_val, exc_tb):",
      "highlightedLines": [6],
      "xpGain": 20,
      "tags": ["context-manager", "__exit__", "TypeError"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_011",
      "language": "python",
      "difficulty": 2,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Nombre:\n    def __init__(self, valeur):\n        self.valeur = valeur\n\n    def __add__(self, autre):\n        return self.valeur + autre\n\nn = Nombre(5)\nresultat = n + 3\nprint(resultat)",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      "correctAnswer": 6,
      "explanation": "Ligne 6 : __add__ devrait retourner un Nombre, pas un int\n\n‚Ä¢ n + 3 retourne un int (8)\n‚Ä¢ On perd le type Nombre\n‚Ä¢ Les op√©rations cha√Æn√©es √©chouent\n\nüí° Pas d'erreur imm√©diate, mais design probl√©matique\n\nCorrection : return Nombre(self.valeur + autre)\nOu : return Nombre(self.valeur + autre.valeur) si autre est Nombre",
      "highlightedLines": [6],
      "xpGain": 20,
      "tags": ["class", "__add__", "magic-method"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_012",
      "language": "python",
      "difficulty": 2,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "from abc import ABC, abstractmethod\n\nclass Forme(ABC):\n    @abstractmethod\n    def aire(self):\n        pass\n\nclass Carre(Forme):\n    def __init__(self, cote):\n        self.cote = cote\n\nc = Carre(5)\nprint(c.aire())",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
      "correctAnswer": 12,
      "explanation": "Ligne 12 : Carre n'impl√©mente pas la m√©thode abstraite aire()\n\n‚Ä¢ Forme.aire est @abstractmethod\n‚Ä¢ Carre h√©rite de Forme\n‚Ä¢ Carre doit impl√©menter aire() pour √™tre instanciable\n\nErreur : TypeError: Can't instantiate abstract class Carre with abstract method aire\n\nCorrection : Ajouter dans Carre:\ndef aire(self):\n    return self.cote ** 2",
      "highlightedLines": [12],
      "xpGain": 20,
      "tags": ["ABC", "abstractmethod", "TypeError"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_013",
      "language": "python",
      "difficulty": 3,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Meta(type):\n    def __new__(cls, name, bases, dct):\n        return super().__new__(cls, name, bases)\n\nclass MaClasse(metaclass=Meta):\n    pass\n\nobj = MaClasse()",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8],
      "correctAnswer": 3,
      "explanation": "Ligne 3 : type.__new__ attend 4 arguments\n\n‚Ä¢ super().__new__(cls, name, bases, dct)\n‚Ä¢ dct (le dictionnaire de classe) est manquant\n‚Ä¢ La cr√©ation de classe √©choue\n\nErreur : TypeError: type.__new__() takes exactly 3 arguments (2 given)\n\nCorrection :\nreturn super().__new__(cls, name, bases, dct)",
      "highlightedLines": [3],
      "xpGain": 30,
      "tags": ["metaclass", "__new__", "TypeError"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_014",
      "language": "python",
      "difficulty": 3,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Descripteur:\n    def __get__(self, obj, objtype):\n        return self.value\n\n    def __set__(self, obj, value):\n        self.value = value\n\nclass MaClasse:\n    attr = Descripteur()\n\na = MaClasse()\nb = MaClasse()\na.attr = 10\nprint(b.attr)",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],
      "correctAnswer": 6,
      "explanation": "Ligne 6 : La valeur est stock√©e sur le descripteur, pas sur l'instance\n\n‚Ä¢ self.value stocke sur le Descripteur\n‚Ä¢ Toutes les instances partagent la m√™me valeur\n‚Ä¢ a.attr = 10 affecte aussi b.attr\n\nR√©sultat : b.attr = 10 (partag√©!)\n\nCorrection : Stocker sur l'instance\nobj.__dict__[self.name] = value",
      "highlightedLines": [6],
      "xpGain": 30,
      "tags": ["descriptor", "__set__", "instance"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_015",
      "language": "python",
      "difficulty": 3,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class Singleton:\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n    def __init__(self, value):\n        self.value = value\n\ns = Singleton(42)",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
      "correctAnswer": 4,
      "explanation": "Ligne 4 : __new__ ne prend pas le m√™me nombre d'arguments que __init__\n\n‚Ä¢ __init__(self, value) attend 'value'\n‚Ä¢ __new__(cls) ne le prend pas\n‚Ä¢ Singleton(42) passe 42 mais __new__ l'ignore\n\nErreur : TypeError: __new__() takes 1 positional argument but 2 were given\n\nCorrection :\ndef __new__(cls, *args, **kwargs):",
      "highlightedLines": [4],
      "xpGain": 30,
      "tags": ["singleton", "__new__", "TypeError"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_016",
      "language": "python",
      "difficulty": 3,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "class A:\n    def method(self):\n        return 'A'\n\nclass B(A):\n    def method(self):\n        return 'B' + super.method()\n\nb = B()\nprint(b.method())",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
      "correctAnswer": 7,
      "explanation": "Ligne 7 : super doit √™tre appel√© avec ()\n\n‚Ä¢ super est une fonction, pas un objet\n‚Ä¢ super.method() ‚Üí erreur\n‚Ä¢ super().method() ‚Üí correct\n\nErreur : TypeError: descriptor 'method' for 'super' objects doesn't apply to a 'str' object\n\nCorrection : return 'B' + super().method()",
      "highlightedLines": [7],
      "xpGain": 30,
      "tags": ["super", "inheritance", "TypeError"],
      "category": "advanced"
    },
    {
      "id": "py_fe_adv_017",
      "language": "python",
      "difficulty": 3,
      "type": "find_error",
      "inputType": "clickable_lines",
      "question": "Quelle ligne contient une erreur ?",
      "code": "from typing import Generic, TypeVar\n\nT = TypeVar('T')\n\nclass Boite(Generic[T]):\n    def __init__(self, contenu: T):\n        self.contenu = contenu\n\n    def obtenir(self) -> T:\n        return self.contenu\n\nb: Boite[str] = Boite(42)\nprint(b.obtenir())",
      "clickableLines": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13],
      "correctAnswer": 12,
      "explanation": "Ligne 12 : Type annotation ne correspond pas au type r√©el\n\n‚Ä¢ b: Boite[str] annonce une bo√Æte de strings\n‚Ä¢ Boite(42) cr√©e une bo√Æte avec un int\n‚Ä¢ Les types ne correspondent pas\n\nüí° Pas d'erreur √† l'ex√©cution (Python ignore les annotations)\nMais les type checkers (mypy) signaleront l'erreur\n\nCorrection : Boite[int] = Boite(42)\nOu : Boite[str] = Boite('hello')",
      "highlightedLines": [12],
      "xpGain": 30,
      "tags": ["typing", "Generic", "type-annotation"],
      "category": "advanced"
    }
  ]
}
